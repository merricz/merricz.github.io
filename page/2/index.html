<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Myoboku">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Myoboku">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="merric">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Myoboku</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Myoboku</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">merric</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/10/%E9%9A%8F%E7%AC%94/%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/10/%E9%9A%8F%E7%AC%94/%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">线上故障引发的思考</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-09-10 22:53:43" itemprop="dateCreated datePublished" datetime="2020-09-10T22:53:43+00:00">2020-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1、养成自己的编码规范清单很重要，清单不需要太多，最重要的几条列在前面要严格遵守</p>
<p>2、我的编码规范清单:<br>a.要严格识别出写的代码是强依赖、弱依赖，弱依赖不能引起核心流程受阻。<br>反例:一个查询国家列表的下游接口(弱依赖)挂了导致整个收银台挂掉。</p>
<p>3、对一些原则要有敬畏之心，比如: 开闭原则，单一原则。不遵守原则，大概率会发生一些你意料不到的case(你觉得考虑全面了，但实际被打脸)，但遵守原则，会避免很多意料不到的 case。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/09/jvm/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/09/jvm/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java中线程安全的集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-09-09 22:30:00" itemprop="dateCreated datePublished" datetime="2020-09-09T22:30:00+00:00">2020-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>在实际编程中，会经常使用到 JDK 中 Collection 集合框架中的各种容器类如实现 List,Map,Queue 接口的容器类，但是这些容器类基本上不是线程安全的，除了使用 Collections 可以将其转换为线程安全的容器，Doug Lea 大师为我们都准备了对应的线程安全的容器，如实现 List 接口的 CopyOnWriteArrayList，实现 Map 接口的 ConcurrentHashMap，实现 Queue 接口的 ConcurrentLinkedQueue。</p>
<p>最常用的”<strong>生产者-消费者</strong>“问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</strong></p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>放入数据：<br>　　<strong>offer(anObject)</strong>:表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）<br>　　<strong>offer(E o, long timeout, TimeUnit unit)</strong>,可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。<br>　　<strong>put(anObject)</strong>:把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.<br>获取数据：<br>　　<strong>poll(time)</strong>:取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;<br>　　**poll(long timeout, TimeUnit unit)**：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。<br>　　take()**:取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;<br>　　**drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>
<h2 id="常用的BlockingQueue"><a href="#常用的BlockingQueue" class="headerlink" title="常用的BlockingQueue"></a>常用的BlockingQueue</h2><blockquote>
<p>1.ArrayBlockingQueue</p>
</blockquote>
<p><strong>ArrayBlockingQueue</strong>是由数组实现的有界阻塞队列。该队列命令元素 FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue 可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue 一旦创建，容量不能改变。</p>
<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，一旦 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。<strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10,true);</span><br></pre></td></tr></table></figure>

<p>关于 ArrayBlockingQueue 的实现原理，可以看这篇文章。</p>
<blockquote>
<p>2.LinkedBlockingQueue</p>
</blockquote>
<p>LinkedBlockingQueue 是用链表实现的有界阻塞队列，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE</p>
<blockquote>
<p>3.PriorityBlockingQueue</p>
</blockquote>
<p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p>
<blockquote>
<p>4.SynchronousQueue</p>
</blockquote>
<p>SynchronousQueue 每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue 实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue 也可以通过构造器参数来为其指定公平性。</p>
<blockquote>
<p>5.LinkedTransferQueue</p>
</blockquote>
<p>LinkedTransferQueue 是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了 TransferQueue 接口，与其他阻塞队列相比主要有以下不同的方法：</p>
<p><strong>transfer(E e)</strong> 如果当前有线程（消费者）正在调用 take()方法或者可延时的 poll()方法进行消费数据时，生产者线程可以调用 transfer 方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；</p>
<p><strong>tryTransfer(E e)</strong> tryTransfer 方法如果当前有消费者线程（调用 take 方法或者具有超时特性的 poll 方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回<code>false</code>。因此，与 transfer 方法相比，transfer 方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而 tryTransfer 方法能够立即返回结果退出。</p>
<p><strong>tryTransfer(E e,long timeout,imeUnit unit)</strong><br>与 transfer 基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回<code>false</code>。</p>
<blockquote>
<p>6.LinkedBlockingDeque</p>
</blockquote>
<p>LinkedBlockingDeque 是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为 Integer.MAX_VALUE。与 LinkedBlockingQueue 相比，主要的不同点在于，LinkedBlockingDeque 具有双端队列的特性。</p>
<blockquote>
<p>7.DelayQueue</p>
</blockquote>
<p>DelayQueue 是一个存放实现 Delayed 接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过 poll 等方法获取数据元素则返回 null。所谓数据延时期满时，则是通过 Delayed 接口的<code>getDelay(TimeUnit.NANOSECONDS)</code>来进行判定，如果该方法返回的是小于等于 0 则说明该数据元素的延时期已满。</p>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>有很多业务往往是读多写少的，比如系统配置的信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻其他模块之后对系统信息只需要进行读取，又比如白名单，黑名单等配置，只需要读取名单配置然后检测当前用户是否在该配置范围以内。类似的还有很多业务场景，它们都是属于<strong>读多写少</strong>的场景。如果在这种情况用到上述的方法，使用 Vector,Collections 转换的这些方式是不合理的，因为尽管多个读线程从同一个数据容器中读取数据，但是读线程对数据容器的数据并不会发生发生修改。很自然而然的我们会联想到 ReenTrantReadWriteLock，通过<strong>读写分离</strong>的思想，使得读读之间不会阻塞，无疑如果一个 list 能够做到被多个读线程读取的话，性能会大大提升不少。但是，如果仅仅是将 list 通过读写锁（ReentrantReadWriteLock）进行再一次封装的话，由于读写锁的特性，当写锁被写线程获取后，读写线程都会被阻塞。如果仅仅使用读写锁对 list 进行封装的话，这里仍然存在读线程在读数据的时候被阻塞的情况，如果想 list 的读效率更高的话，这里就是我们的突破口，如果我们保证读线程无论什么时候都不被阻塞，效率岂不是会更高？</p>
<p>Doug Lea 大师就为我们提供 CopyOnWriteArrayList 容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList 也被广泛应用于很多业务场景之中，CopyOnWriteArrayList 值得被我们好好认识一番。</p>
<h2 id="cow的思想"><a href="#cow的思想" class="headerlink" title="cow的思想"></a>cow的思想</h2><p>回到上面所说的，如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在<strong>读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性</strong>。既然我们说到要进行优化，必然有 trade-off,我们就可以<strong>牺牲数据实时性满足数据的最终一致性即可</strong>。而 CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。</p>
<p>COW 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。</p>
<h2 id="CopyOnWriteArrayList-的实现原理"><a href="#CopyOnWriteArrayList-的实现原理" class="headerlink" title="CopyOnWriteArrayList 的实现原理"></a>CopyOnWriteArrayList 的实现原理</h2><p>现在我们来通过看源码的方式来理解 CopyOnWriteArrayList，实际上 CopyOnWriteArrayList 内部维护的就是一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** The array, accessed only via getArray/setArray. */</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>

<p>并且该数组引用是被 volatile 修饰，注意这里<strong>仅仅是修饰的是数组引用</strong>，其中另有玄机，稍后揭晓。关于 volatile 很重要的一条性质是它能够够保证可见性。对 list 来说，我们自然而然最关心的就是读写的时候，分别为 get 和 add 方法的实现。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>get 方法的源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Gets the array.  Non-private so as to also be accessible</span><br><span class="line"> * from CopyOnWriteArraySet class.</span><br><span class="line"> */</span><br><span class="line">final Object[] getArray() &#123;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来 get 方法实现非常简单，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有 CAS 操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。</p>
<h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>再来看下如何进行添加数据的？add 方法的源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">	//1. 使用Lock,保证写线程在同一时刻只有一个</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">		//2. 获取旧数组引用</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">		//3. 创建新的数组，并将旧数组的数据复制到新数组中</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">		//4. 往新数组中添加新的数据</span><br><span class="line">		newElements[len] = e;</span><br><span class="line">		//5. 将旧数组引用指向新的数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：</p>
<ol>
<li>采用 ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据；</li>
<li>前面说过数组引用是 volatile 修饰的，因此将旧的数组引用指向新的数组，根据 volatile 的 happens-before 规则，写线程对数组引用的修改对读线程是可见的。</li>
<li>由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道 COW 和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：</p>
<p><strong>COW vs 读写锁</strong></p>
<p>相同点：1. 两者都是通过读写分离的思想实现；2.读线程间是互不阻塞的</p>
<p>不同点：<strong>对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而 COW 则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况</strong>。</p>
<p>这里还有这样一个问题： <strong>为什么需要复制呢？ 如果将 array 数组设定为 volitile 的， 对 volatile 变量写 happens-before 读，读线程不是能够感知到 volatile 变量的变化</strong>。</p>
<p>原因是，这里 volatile 的修饰的<strong>仅仅</strong>只是<strong>数组引用</strong>，<strong>数组中的元素的修改是不能保证可见性的</strong>。因此 COW 采用的是新旧两个数据容器，通过第 5 行代码将数组引用指向新的数组。</p>
<p>这也是为什么 concurrentHashMap 只具有弱一致性的原因</p>
<p><strong>COW 的缺点</strong></p>
<p>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ol>
<li><strong>内存占用问题</strong>：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 minor GC 和 major GC。</li>
<li><strong>数据一致性问题</strong>：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</li>
</ol>
<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><h2 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="操作Node的几个CAS方法"><a href="#操作Node的几个CAS方法" class="headerlink" title="操作Node的几个CAS方法"></a>操作Node的几个CAS方法</h3><p>在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持<strong>CMPXCHG</strong>指令后，在 java 源码中涉及到并发处理都会使用 CAS 操作<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903600334831629">(关于 CAS 操作可以看这篇文章的第 3.1 节</a>)，那么在 ConcurrentLinkedQueue 对 Node 的 CAS 操作有这样几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//更改Node中的数据域item</span><br><span class="line">boolean casItem(E cmp, E val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line">//更改Node中的指针域next</span><br><span class="line">void lazySetNext(Node&lt;E&gt; val) &#123;</span><br><span class="line">    UNSAFE.putOrderedObject(this, nextOffset, val);</span><br><span class="line">&#125;</span><br><span class="line">//更改Node中的指针域next</span><br><span class="line">boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这些方法实际上是通过调用 UNSAFE 实例的方法，UNSAFE 为<strong>sun.misc.Unsafe</strong>类，该类是 hotspot 底层方法，目前为止了解即可，知道 CAS 的操作归根结底是由该类提供就好。</p>
<h3 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h3><p>这是一段看着头疼的代码，暂时看懂了可能睡一觉就忘了。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    //e为null则抛出空指针异常</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    //从尾节点插入</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line"></span><br><span class="line">        //如果q=null说明p是尾节点则插入</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line"></span><br><span class="line">            //cas插入（1）</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                //cas成功说明新增节点已经被放入链表，然后设置当前尾节点（包含head，1，3，5.。。个节点为尾节点）</span><br><span class="line">                if (p != t) // hop two nodes at a time</span><br><span class="line">                    casTail(t, newNode);  // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p == q)//(2)</span><br><span class="line">            //多线程操作时候，由于poll时候会把老的head变为自引用，然后head的next变为新head，所以这里需要</span><br><span class="line">            //重新找新的head，因为新的head后面的节点才是激活的节点</span><br><span class="line">            //或者是新的集合，p节点==p节点的next节点，正准备第一次添加节点，所以返回head节点</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">            // 寻找尾节点(3)</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从源代码角度来看整个入队过程主要做二件事情</strong>。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。<br><strong>第一步定位尾节点。</strong>tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点；或者多线程的情况</p>
<p><strong>第二步设置入队节点为尾节点。</strong> p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
<h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    //死循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //死循环</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            //保存当前节点值</span><br><span class="line">            E item = p.item;</span><br><span class="line">            //当前节点有值则cas变为null（1）</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //cas成功标志当前节点以及从链表中移除</span><br><span class="line">                if (p != h) // 类似tail间隔2设置一次头节点（2）</span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前队列为空则返回null（3）</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //自引用了，则重新找新的队列头节点（4）</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else//(5)</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">        if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">            h.lazySetNext(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h1 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h1><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile Node&lt;K,V&gt;[] table</span><br></pre></td></tr></table></figure>

<p>：装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方(因为继承自HashMap)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile Node&lt;K,V&gt;[] nextTable</span><br></pre></td></tr></table></figure>

<p>：扩容时使用，平时为null，只有在扩容的时候才为非null。逻辑机制和ArrayList底层的数组扩容一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile long baseCount</span><br></pre></td></tr></table></figure>

<p>：元素数量基础计数器，该值也是一个阶段性的值(产出的时候可能容器正在被修改)。通过<code>CAS</code>的方式进行更改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile int sizeCtl</span><br></pre></td></tr></table></figure>

<p>：散列表初始化和扩容的大小都是由该变量来控制。</p>
<ul>
<li><p>当为负数时，它正在被初始化或者扩容。</p>
<ul>
<li>-1表示正在初始化</li>
<li>-N表示N-1个线程正在扩容</li>
</ul>
</li>
<li><p>当为整数时，</p>
<ul>
<li>此时如果当前table数组为null的话表示table正在初始化过程中，sizeCtl表示为需要新建的数组的长度，默认为0</li>
</ul>
</li>
<li><p>若已经初始化了,表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容）,具体指为数组的长度n 乘以 加载因子loadFactor。 当值为0时，即数组长度为默认初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final sun.misc.Unsafe U</span><br></pre></td></tr></table></figure></li>
</ul>
<p>：在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突(变量实际值!&#x3D;期望值)，当且仅当冲突发生的时候再去尝试。</p>
<ul>
<li><p>在大量的同步组件和并发容器的实现中使用CAS是通过<code>sun.misc.Unsafe</code>类实现的。该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        ······</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>CAS操作依赖于现代处理器指令集，通过底层<code>CMPXCHG</code>指令实现。CAS(V,O,N)核心思想为：若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，再进行重试。</p>
<h2 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span><br><span class="line">ConcurrentHashMap()</span><br><span class="line">// 2. 给定map的大小</span><br><span class="line">ConcurrentHashMap(int initialCapacity)</span><br><span class="line">// 3. 给定一个map</span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line">// 4. 给定map的大小以及加载因子</span><br><span class="line">ConcurrentHashMap(int initialCapacity, float loadFactor)</span><br><span class="line">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span><br><span class="line">ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">	//1. 小于0直接抛异常</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">	//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">	//3. 赋值给sizeCtl</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 cap 赋值给 sizeCtl,关于 sizeCtl 的说明请看上面的说明，<strong>当调用构造器方法之后，sizeCtl 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度</strong>。tableSizeFor 做了哪些事情了？源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a power of two table size for the given desired capacity.</span><br><span class="line"> * See Hackers Delight, sec 3.2</span><br><span class="line"> */</span><br><span class="line">private static final int tableSizeFor(int c) &#123;</span><br><span class="line">    int n = c - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个和前一篇文章中写的的方法一样，可以复习一下</p>
<h3 id="初始化-initTable方法"><a href="#初始化-initTable方法" class="headerlink" title="初始化 initTable方法"></a>初始化 initTable方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">			// 1. 保证只有一个线程正在进行初始化操作</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">					// 2. 得出数组的大小</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">					// 3. 这里才真正的初始化数组</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">					// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第 1 步中会先通过 if 进行判断，若当前已经有一个线程正在初始化即 sizeCtl 值变为-1，这个时候其他线程在 If 判断为 true 从而调用 Thread.yield()让出 CPU 时间片。正在进行初始化的线程会调用 U.compareAndSwapInt 方法将 sizeCtl 改为-1 即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小 n 乘以加载因子 0.75.可以看看这里乘以 0.75 是怎么算的，0.75 为四分之三，这里<code>n - (n &gt;&gt;&gt; 2)</code>是不是刚好是 n-(1&#x2F;4)n&#x3D;(3&#x2F;4)n，挺有意思的吧:)。如果选择是无参的构造器的话，这里在 new Node 数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子 0.75 为 12，也就是说数组的可用大小为 12。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">	//1. 计算key的hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">		//2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">		//3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">		//4. 当前正在扩容</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">					//5. 当前为链表，在链表中插入新的键值对</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					// 6.当前为红黑树，将新的键值对插入到红黑树中</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容，而且对map的count值+1</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了代码里的注释我觉得已经很清楚了，可以看到开头有 如果key或者value是null的话会抛出空指针异常，这也是为什么ConcurrentHashMap中key和value不能为null的原因，之所以这样，首先value不能为null是因为ConcurrentHashMap调用map.get(key)的时候，如果返回了null，那么这个null，都有两重含义:</p>
<ol>
<li>这个key从来没有在map中映射过。</li>
<li>这个key的value在设置的时候，就是null。</li>
</ol>
<p>在非线程安全的map集合(HashMap)中可以使用map.contains(key)方法来判断，而ConcurrentHashMap却不可以。因为多线程情况下get和contains方法之间可能容器已经有了改变。<a target="_blank" rel="noopener" href="http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html">这里有源码作者大佬的回答</a></p>
<p><img src="/images/concurrentHashMap%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F.png" alt="concurrentHashMap加锁方式.png"></p>
<h3 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer 方法"></a>transfer 方法</h3><p>当 ConcurrentHashMap 容量不足的时候，需要对 table 进行扩容。这个方法的基本思想跟 HashMap 是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足 concurrent 的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer 方法源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    // 将 length / 8 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16。</span><br><span class="line">    // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range 细分范围 stridea：TODO</span><br><span class="line">    // 新的 table 尚未初始化</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            // 扩容  2 倍</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            // 更新</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            // 扩容失败， sizeCtl 使用 int 最大值。</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;// 结束</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新成员变量</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        // 更新转移下标，就是 老的 tab 的 length</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    // 新 tab 的 length</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    // 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    // 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    // 完成状态，如果是 true，就结束此方法。</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    // 死循环,i 表示下标，bound 表示当前线程可以处理的当前桶区间最小下标</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        // 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            // 对 i 减一，判断是否大于等于 bound （正常情况下，如果大于 bound 不成立，说明该线程上次领取的任务已经完成了。那么，需要在下面继续领取任务）</span><br><span class="line">            // 如果对 i 减一大于等于 bound（还需要继续做任务），或者完成了，修改推进状态为 false，不能推进了。任务成功后修改推进状态为 true。</span><br><span class="line">            // 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span><br><span class="line">            // 这里的目的是：1. 当一个线程进入时，会选取最新的转移下标。2. 当一个线程处理完自己的区间时，如果还有剩余区间的没有别的线程处理。再次获取区间。</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                // 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了</span><br><span class="line">                // 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进</span><br><span class="line">            &#125;// CAS 修改 transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;// 这个值就是当前线程可以处理的最小当前区间最小下标</span><br><span class="line">                i = nextIndex - 1; // 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标</span><br><span class="line">                advance = false; // 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进，这样对导致漏掉某个桶。下面的 if (tabAt(tab, i) == f) 判断会出现这样的情况。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束）</span><br><span class="line">        //  如果 i &gt;= tab.length(不知道为什么这么判断)</span><br><span class="line">        //  如果 i + tab.length &gt;= nextTable.length  （不知道为什么这么判断）</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123; // 如果完成了扩容</span><br><span class="line">                nextTable = null;// 删除成员变量</span><br><span class="line">                table = nextTab;// 更新 table</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); // 更新阈值</span><br><span class="line">                return;// 结束方法。</span><br><span class="line">            &#125;// 如果没完成</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)// 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</span><br><span class="line">                    return;// 不相等，说明没结束，当前线程结束方法。</span><br><span class="line">                finishing = advance = true;// 如果相等，扩容结束了，更新 finising 变量</span><br><span class="line">                i = n; // 再次循环检查一下整张表</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null) // 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);// 如果成功写入 fwd 占位，再次推进一个下标</span><br><span class="line">        else if ((fh = f.hash) == MOVED)// 如果不是 null 且 hash 值是 MOVED。</span><br><span class="line">            advance = true; // already processed // 说明别的线程已经处理过了，再次推进一个下标</span><br><span class="line">        else &#123;// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                // 判断 i 下标处的桶节点是否和 f 相同</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;// low, height 高位桶，低位桶</span><br><span class="line">                    // 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        // 对老长度进行与运算（第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）</span><br><span class="line">                        // 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1</span><br><span class="line">                        //  如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，让新的取于算法能够击中他。</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f; // 尾节点，且和头节点的 hash 值取于不相等</span><br><span class="line">                        // 遍历这个桶</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            // 取于桶中每个节点的 hash 值</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            // 如果节点的 hash 值和首节点的 hash 值取于结果不同</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b; // 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。</span><br><span class="line">                                lastRun = p; // 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;// 如果最后更新的 runBit 是 0 ，设置低位节点</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun; // 如果最后更新的 runBit 是 1， 设置高位节点</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果）</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            // 如果与运算结果是 0，那么就还在低位</span><br><span class="line">                            if ((ph &amp; n) == 0) // 如果是0 ，那么创建低位节点</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else // 1 则创建高位</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 其实这里类似 hashMap </span><br><span class="line">                        // 设置低位链表放在新链表的 i</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        // 设置高位链表，在原有长度上加 n</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        // 将旧的链表设置成占位符</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        // 继续向后推进</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;// 如果是红黑树</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        // 遍历</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            // 和链表相同的判断，与运算 == 0 的放在低位</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; // 不是 0 的放在高位</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        // 低位树</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        // 高位数</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        // 旧的设置成占位符</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        // 继续向后推进</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的执行逻辑如下：</p>
<ol>
<li><p>通过计算 CPU 核心数和 Map 数组的长度得到每个线程（CPU）要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理 16 个桶。因此，如果长度是 16 的时候，扩容的时候只会有一个线程扩容。</p>
</li>
<li><p>初始化临时变量 nextTable。将其在原有基础上扩容两倍。</p>
</li>
<li><p>死循环开始转移。多线程并发转移就是在这个死循环中，根据一个 finishing 变量来判断，该变量为 true 表示扩容结束，否则继续扩容。</p>
<p>3.1 进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16. 从大到小进行分配。当拿到分配值后，进行 i– 递减。这个 i 就是数组下标。（<code>其中有一个 bound 参数，这个参数指的是该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容，还有一个 advance 参数，该参数指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后推进，反之，说明还没有处理好当前桶，不能推进</code>)<br>3.2 出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临死变量，更新 table 变量，更新库容阈值。如果没完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（<code>这里主要是判断扩容任务是否结束，如果结束了就让线程退出该方法，并更新相关变量</code>）。然后检查所有的桶，防止遗漏。<br>3.3 如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让 putVal 方法的线程感知。<br>3.4 如果 i 对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。<br>3.5 如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个桶。<br>3.6 到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据或已经被占位了，就跳过了。</p>
</li>
<li><p>处理每个桶的行为都是同步的。防止 putVal 的时候向链表插入数据。<br>4.1 如果这个桶是链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。<br>4.2 如果这个桶是红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，改造成链表。反之，继续使用红黑树结构。<br>4.3 到这里，就完成了一个桶从旧表转移到新表的过程。</p>
</li>
</ol>
<p>这段代码是既牛逼又头疼，这注释和逻辑也可能不完全对，后面需要再看再修改</p>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h3><p><strong><code>ConcurrentHashMap</code>提供了<code>baseCount、counterCells</code>两个辅助变量和一个<code>CounterCell</code>辅助内部类。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class CounterCell &#123;</span><br><span class="line">        volatile long value;</span><br><span class="line">        CounterCell(long x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ConcurrentHashMap中元素个数,但返回的不一定是当前Map的真实元素个数。基于CAS无锁更新</span><br><span class="line">private transient volatile long baseCount;</span><br><span class="line"></span><br><span class="line">private transient volatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<p><strong>size()方法定义如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        long n = sumCount();</span><br><span class="line">        return ((n &lt; 0L) ? 0 :</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (int)n);</span><br><span class="line">&#125;</span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        long sum = baseCount;</span><br><span class="line">        if (as != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                //遍历，所有counter求和</span><br><span class="line">                if ((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述size()逻辑可以知道：**<code>size = baseCount + counterCells[0...n-1].value</code>**，我们通过增加一个元素的逻辑代码来看这两个变量的含义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        // s = b + x，完成baseCount++操作；</span><br><span class="line">        if ((as = counterCells) != null ||</span><br><span class="line">            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            boolean uncontended = true;</span><br><span class="line">            if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                //  多线程CAS发生失败时执行</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;= 1)</span><br><span class="line">                return;</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查是否进行扩容</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在并发量很高时，<strong>如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，使用CounterCell记录元素个数的变化；</strong><br>如果通过CAS设置cellsBusy字段失败的话，则继续尝试通过CAS修改baseCount字段，如果修改baseCount字段成功的话，就退出循环，否则继续循环插入CounterCell对象；<br>所以在1.8中的size实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中，实现如下：<br><strong>通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/13/jvm/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/13/jvm/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java线程学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-07-13 22:30:00" itemprop="dateCreated datePublished" datetime="2020-07-13T22:30:00+00:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程的生命周期及基本状态"><a href="#线程的生命周期及基本状态" class="headerlink" title="线程的生命周期及基本状态"></a>线程的生命周期及基本状态</h1><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.png" alt="图片"></p>
<ol>
<li><p>新建(new)：新创建了一个线程对象。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p>
</li>
<li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
<li><p>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。</p>
<p>阻塞的情况分三种：<br>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；<br>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；<br>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p>
</li>
<li><p>死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
<h1 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h1><ul>
<li>继承 Thread 类；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>使用 Executors 工具类创建线程池</li>
</ul>
<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a><strong>继承 Thread 类</strong></h2><ol>
<li>定义一个Thread类的子类，重写run方法，将相关逻辑实现，run()方法就是线程要执行的业务逻辑方法</li>
<li>创建自定义的线程子类对象</li>
<li>调用子类实例的star()方法来启动线程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run()方法正在执行...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TheadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThread = new MyThread(); 	</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main main()方法执行结束</span><br><span class="line">Thread-0 run()方法正在执行...</span><br></pre></td></tr></table></figure>

<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a><strong>实现 Runnable 接口</strong></h2><ol>
<li>定义Runnable接口实现类MyRunnable，并重写run()方法</li>
<li>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，<strong>该Thread对象才是真正的线程对象</strong></li>
<li>调用线程对象的start()方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class RunnableTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyRunnable myRunnable = new MyRunnable();</span><br><span class="line">        Thread thread = new Thread(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main main()方法执行完成</span><br><span class="line">Thread-0 run()方法执行中...</span><br></pre></td></tr></table></figure>

<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a><strong>实现 Callable 接口</strong></h2><ol>
<li>创建实现Callable接口的类myCallable</li>
<li>以myCallable为参数创建FutureTask对象</li>
<li>将FutureTask作为参数创建Thread对象</li>
<li>调用线程对象的start()方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; call()方法执行中...&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyCallable());</span><br><span class="line">        Thread thread = new Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;返回结果 &quot; + futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; main()方法执行完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 call()方法执行中...</span><br><span class="line">返回结果 1</span><br><span class="line">main main()方法执行完成</span><br></pre></td></tr></table></figure>

<h2 id="使用-Executors-工具类创建线程池"><a href="#使用-Executors-工具类创建线程池" class="headerlink" title="使用 Executors 工具类创建线程池"></a><strong>使用 Executors 工具类创建线程池</strong></h2><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。</p>
<p>主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run()方法执行中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SingleThreadExecutorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        MyRunnable runnableTest = new MyRunnable();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            executorService.execute(runnableTest);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程任务开始执行&quot;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程任务开始执行</span><br><span class="line">pool-1-thread-1 is running...</span><br><span class="line">pool-1-thread-1 is running...</span><br><span class="line">pool-1-thread-1 is running...</span><br><span class="line">pool-1-thread-1 is running...</span><br><span class="line">pool-1-thread-1 is running...</span><br></pre></td></tr></table></figure>

<h2 id="runnable-和-callable-的区别"><a href="#runnable-和-callable-的区别" class="headerlink" title="runnable 和 callable 的区别"></a>runnable 和 callable 的区别</h2><p>相同点</p>
<ul>
<li>都是接口</li>
<li>都可以编写多线程程序</li>
<li>都采用Thread.start()启动线程</li>
</ul>
<p>主要区别</p>
<ul>
<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</li>
</ul>
<p><strong>注</strong>：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<h2 id="线程的-run-和-start-的区别"><a href="#线程的-run-和-start-的区别" class="headerlink" title="线程的 run()和 start()的区别"></a>线程的 run()和 start()的区别</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>
<h1 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h1><ol>
<li>创建&#x2F;销毁线程伴随着系统开销，过于频繁的创建&#x2F;销毁线程，会很大程度上影响处理效率，应用能够更加充分合理地协调利用CPU、内存、网络、I&#x2F;O等系统资源；</li>
<li>线程并发数量过多，抢占系统资源从而导致阻塞，利用线程池管理并复用线程，控制最大并发数；</li>
<li>使用线程池可以对线程进行一些简单的管理，实现任务线程队列缓存策略和拒绝机制，实现某些与时间相关的功能，例如定时执行、周期执行等，另外还可以隔离线程环境；</li>
</ol>
<h1 id="ThreadPoolExecutor的重要参数"><a href="#ThreadPoolExecutor的重要参数" class="headerlink" title="ThreadPoolExecutor的重要参数"></a>ThreadPoolExecutor的重要参数</h1><h2 id="corePoolSize：核心线程数"><a href="#corePoolSize：核心线程数" class="headerlink" title="corePoolSize：核心线程数"></a>corePoolSize：核心线程数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 核心线程会一直存活，即使没有任务需要执行</span><br><span class="line">* 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理</span><br><span class="line">* 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭</span><br></pre></td></tr></table></figure>

<p>一般来说：</p>
<ul>
<li>CPU密集型：corePoolSize &#x3D; CPU核数 + 1</li>
<li>IO密集型：corePoolSize &#x3D; CPU核数 * 2</li>
</ul>
<h2 id="maximumPoolSize：最大线程数"><a href="#maximumPoolSize：最大线程数" class="headerlink" title="maximumPoolSize：最大线程数"></a>maximumPoolSize：最大线程数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 当线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务</span><br><span class="line">* 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常</span><br></pre></td></tr></table></figure>

<h2 id="keepAliveTime：线程空闲时间"><a href="#keepAliveTime：线程空闲时间" class="headerlink" title="keepAliveTime：线程空闲时间"></a>keepAliveTime：线程空闲时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize</span><br><span class="line">* 如果allowCoreThreadTimeout=true，则会直到线程数量=0</span><br></pre></td></tr></table></figure>

<h2 id="unit：线程空闲时间的单位"><a href="#unit：线程空闲时间的单位" class="headerlink" title="unit：线程空闲时间的单位"></a>unit：线程空闲时间的单位</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* NANOSECONDS ： 1微毫秒 = 1微秒 / 1000</span><br><span class="line">* MICROSECONDS ： 1微秒 = 1毫秒 / 1000</span><br><span class="line">* MILLISECONDS ： 1毫秒 = 1秒 /1000</span><br><span class="line">* SECONDS ： 秒</span><br><span class="line">* MINUTES ： 分</span><br><span class="line">* HOURS ： 小时</span><br><span class="line">* DAYS ： 天</span><br></pre></td></tr></table></figure>

<h2 id="workQueue：用于缓存任务的阻塞队列"><a href="#workQueue：用于缓存任务的阻塞队列" class="headerlink" title="workQueue：用于缓存任务的阻塞队列"></a>workQueue：用于缓存任务的阻塞队列</h2><p>常用的workQueue类型：</p>
<ul>
<li>SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</li>
<li>LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</li>
<li>ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</li>
<li>DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li>
</ul>
<h2 id="handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。"><a href="#handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。" class="headerlink" title="handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。"></a>handler：表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* AbortPolicy 丢弃任务，抛运行时异常 （默认）</span><br><span class="line">* CallerRunsPolicy 执行任务</span><br><span class="line">* DiscardPolicy 忽视，什么都不会发生</span><br><span class="line">* DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务</span><br><span class="line">* 实现RejectedExecutionHandler接口，可自定义处理器</span><br></pre></td></tr></table></figure>

<h2 id="threadFactory：指定创建线程的工厂"><a href="#threadFactory：指定创建线程的工厂" class="headerlink" title="threadFactory：指定创建线程的工厂"></a>threadFactory：指定创建线程的工厂</h2><p>在阿里巴巴java开发手册以及一些sonar扫描规则中，需要手动创建线程池，和线程工厂，来对线程池进行命名。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadFactory NAMED_THREAD_FACTORY = new ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(&quot;thread-name-%d&quot;).build();</span><br><span class="line">    private static final ExecutorService THREAD_POOL = new ThreadPoolExecutor(1, 1,</span><br><span class="line">            0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(), NAMED_THREAD_FACTORY);</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="图片"></p>
<h1 id="默认常用线程池"><a href="#默认常用线程池" class="headerlink" title="默认常用线程池"></a>默认常用线程池</h1><p>虽然是默认常用，但是如果加了sonar规则的话这几个还不能直接用。。还是要用线程池的构造函数自己去构造。</p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>创建固定线程数的线程池因为最大线程数和核心线程数相等，并且是无界队列，可控制线程最大并发数（同时执行的线程数），超出的线程会在队列中等待；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>单任务队列的线程池,最大线程数和核心线程数都是1，无界队列，所有的任务都按照顺序进行执行；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>支持定时周期性执行任务的线程池；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">       return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建&#x2F;销毁线程，减少系统开销.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h2><p>submit方法源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task == null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个方法一共有三个重载方法，分别是重写Callable和Runnable方法的重载。submit的实现方法位于抽象类AbstractExecutorService中，而此时execute方法还未实现（而是在AbstractExecutorService的继承类ThreadPoolExecutor中实现），可以看出无论哪个submit方法都最终调用了execute方法。</p>
<hr>
<p>execute方法源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"> </span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  简要分析一下execute源码，执行一个Runnable对象时，首先通过workerCountOf(c)获取线程池中线程的数量，如果池中的数量小于corePoolSize就调用addWorker添加一个线程来执行这个任务。否则通过workQueue.offer(command)方法入列。如果入列成功还需要在一次判断池中的线程数，因为我们创建线程池时可能要求核心线程数量为0，所以我们必须使用addWorker(null, false)来创建一个临时线程去阻塞队列中获取任务来执行。</p>
<p>第二次addWorker是在工作线程为0时调用的，我们现在假设此时是创建核心线程，即<code>false</code>改为<code>true</code>；那么<code>addWorker</code>方法中<code>wc &gt;= (core ? corePoolSize : maximumPoolSize)</code>这个地方会去判断当前工作线程是否大于核心线程，在高并发的情况下，会存在其他线程将工作线程的数量创建的大于核心线程数，导致返回<code>false</code>，并且不会创建新线程，虽然有工作线程的存在，但是会导致原本可以及时处理的任务，要去排队执行。</p>
<p>  isRunning(c) 的作用是判断线程池是否处于运行状态，如果入列后发现线程池已经关闭，则出列。不需要在入列前判断线程池的状态，因为判断一个线程池工作处于RUNNING状态到执行入列操作这段时间，线程池可能被其它线程关闭了，所以提前判断毫无意义。</p>
<hr>
<p>其中addWorker方法就是创建一个线程来执行Runnable对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // Check if queue empty only if necessary.</span><br><span class="line">            //判断线程池的是否可以接收新任务</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == null &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            	//获取工作线程的数量</span><br><span class="line">                int wc = workerCountOf(c);</span><br><span class="line">                //判断工作线程的数量是否大于等于线程池的上限或者核心或者最大线程数</span><br><span class="line">                if (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    return false;</span><br><span class="line">                //使用cas增加工作线程数</span><br><span class="line">                if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    break retry;</span><br><span class="line">                c = ctl.get();  // Re-read ctl</span><br><span class="line">                //如果添加失败，并且线程池状态发生了改变，重来一遍</span><br><span class="line">                if (runStateOf(c) != rs)</span><br><span class="line">                    continue retry;</span><br><span class="line">                // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		//上面的逻辑是考虑是否能够添加线程，如果可以使用cas来增加工作线程数量</span><br><span class="line">		//下面正式启动线程</span><br><span class="line">        boolean workerStarted = false;</span><br><span class="line">        boolean workerAdded = false;</span><br><span class="line">        Worker w = null;</span><br><span class="line">        try &#123;</span><br><span class="line">        	//新建worker</span><br><span class="line">            w = new Worker(firstTask);</span><br><span class="line">            // 获取当前线程</span><br><span class="line">            final Thread t = w.thread;</span><br><span class="line">            if (t != null) &#123;</span><br><span class="line">            	//获取重入锁</span><br><span class="line">                final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">                //锁住</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    // Recheck while holding lock.</span><br><span class="line">                    // Back out on ThreadFactory failure or if</span><br><span class="line">                    // shut down before lock acquired.</span><br><span class="line">                    int rs = runStateOf(ctl.get());</span><br><span class="line">					// rs &lt; SHUTDOWN  -- 状态即为：RUNNING</span><br><span class="line">					//rs == SHUTDOWN &amp;&amp; firstTask == null </span><br><span class="line">                    if (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                        //如果线程已经启动，抛出异常</span><br><span class="line">                        if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                            throw new IllegalThreadStateException();</span><br><span class="line">                        //workers是一个HashSet，必须在锁住的情况下，操作</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        int s = workers.size();</span><br><span class="line">                        //设置largestPoolSize ，标记workerAdded </span><br><span class="line">                        if (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                //如果添加成功，启动线程</span><br><span class="line">                if (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        	//启动线程失败,回滚</span><br><span class="line">            if (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        return workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  第一个参数firstTask不为null，则创建的线程就会先执行firstTask对象，然后去阻塞队列中取任务，否直接到阻塞队列中获取任务来执行。第二个参数，core参数为真，则用corePoolSize作为池中线程数量的最大值；为假，则以maximumPoolSize作为池中线程数量的最大值。</p>
<h2 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h2><p>runWorker源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread的run方法实际上调用了Worker类的runWorker方法，而Worker类继承了AQS类，并实现了lock、unlock、trylock方法。但是这些方法不是真正意义上的锁，所以在代码中加锁操作和解锁操作没有成对出现。runWorker方法中获取到任务就“加锁”，完成任务后就“解锁”。也就是说在“加锁”到“解锁”的这段时间内，线程处于忙碌状态，而其它时间段，处于空闲状态。线程池就可以通过trylock方法来确定这个线程是否空闲。</p>
<hr>
<p>getTask方法的主要作用是从阻塞队列中获取任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   beforeExecute(wt, task)和afterExecute(task, thrown)是个钩子函数，如果我们需要在任务执行之前和任务执行以后进行一些操作，那么我们可以自定义一个继承ThreadPoolExecutor类，并覆盖这两个方法。</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"> </span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"> </span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"> </span><br><span class="line">        // Are workers subject to culling?</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"> </span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>shutdown源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>advanceRunState(SHUTDOWN)的作用是通过CAS操作将线程池的状态更改为SHUTDOWN状态。<br>interruptIdleWorkers是对空闲的线程进行中断，它实际上调用了重载带参数的函数interruptIdleWorkers(false)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过workers容器，遍历池中的线程，对每个线程进行tryLock()操作，如果成功说明线程空闲，则设置其中断标志位。而线程是否响应中断则由任务的编写者决定。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/12/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/code-review1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/12/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/code-review1/" class="post-title-link" itemprop="url">如何有效地做 Code Review？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-07-12 22:30:00" itemprop="dateCreated datePublished" datetime="2020-07-12T22:30:00+00:00">2020-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/" itemprop="url" rel="index"><span itemprop="name">研发规范</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上次说了code review 在开发中的重要性。这次说一说怎么才能让 code review 有效发挥它的作用。</p>
<p>使用方便的工具。要在团队中成功推行 code review，有好的工具是很重要的。谁都不愿意在工作中加入繁琐的过程，所以如果要让人接受一个新的步骤，最好让它有尽可能好的体验。在我用过的开源 code review 工具中，Phabricator 是最完善的。Review Board 应该也是不错的选择，只是我很久没实际用了，不知道最新状态。GitHub 在支持 side-by-side diff 后，它的 pull request 也提供了很好的 code review 体验，唯一不足的是无法从机制上强制所有 commit 都经过 pull request 的过程。</p>
<p>把简单的检查自动化。有很多检查是可以自动化的，比如一些风格规范（缩进、空行、行尾空格、命名等），这类问题应该尽可能写脚本检查。一方面可以让负责 review 的工程师把更多注意力放在更高层面的问题上；另一方面，从接受 review 的人心理上说，由程序提出这些细节问题比让另一个人来挑刺要更容易接受些。当然，这并不是说人工 review 的时候应该忽略细节问题。</p>
<p>控制每次 review 的代码量。每次 review 包含 200 行左右代码是比较理想的，最多不要超过 400 行。因为如果代码太多，review 的人容易因为注意力分散而忽略一些问题，另外也可能让时间拖得过长。因此，开发的时候需要把大的改动分解成多个小的步骤，每完成一个步骤就提交一次 review。</p>
<p>使用异步的工作流。这和上一点是相关的，当你需要把一个改动分为相互依赖的多步时，不应该因为等待 review 而 block 住自己的工作。在当前分支等待 review 时，可以从这个点开一个新的分支继续开发，之后再把 review 完的分支 merge 进来。</p>
<p>作者应该提供清晰的 commit note。Code review 的重要作用之一是同事间的交流，每个 commit 的 commit note 很重要也很影响 review 的效率，应该包含这个改动的目的，以及实现方式的概述。如果使用的 review 系统支持对 review 本身的描述（如 GitHub 的 pull request），那么应该写清楚作者希望 reviewer 重点关注的问题。</p>
<p>在合并到主干之前进行 review。有的人主张小团队应该做事后的 review，因为这样效率更高、更「轻量」。事实上，这样并不会减少工作量，并且如果工作流安排合理，事前 review 并不会导致效率降低。从心理上说，代码并合并到主干之后往往就意味着「完事了」，在时间比较紧张的时候很难坚持 review 所有代码。所以应该把 code review 作为代码合并到主干前必过的一道关口。</p>
<p>所有人的代码都要经过 review。Code review 并不是资深工程师对初级工程师做的事情，而应该全员平等参与，每个人都会有所收获。关于这方面在上一篇「为什么每个团队都需要 Code Review」里也有提及。</p>
<p>关注设计方面的问题和客观的规范，避免在主观意见上争执。Code review 的讨论应该专注于设计层面的问题以及在团队中有明确共识的规范（代码风格，测试覆盖等），而要避免在一些主观意见的分歧上浪费时间。这也意味着应该在一些本身不重要，但很影响一致性的细节上尽早达成有共识的规范，如缩进方式，括号的位置等等，避免在 review 中去争论这些问题。</p>
<p>从正面看待在 review 中发现的问题。当发现一个错误时，并不应该看作是一个人犯了错被另一个人发现了，而是两个人配合改进了代码、避免了错误。</p>
<p>Review 所有的代码，包括很简单的改动。每一个 commit，无论多小都应该经过 review。一方面，很难界定什么算简单的改动，如果一行的 commit 不用 review，那两行是不是差不多同样简单，三行呢？另一方面，我已经不记得自己曾有多少次觉得「这个改动太简单，不用跑测试就可以提交了」，然后很快因为测试通不过而很尴尬地被别人 rollback。所以无论多小的改动都应该有测试、都应该通过 review。</p>
<p>循序渐进。如果现在完全没有做 code review，那么到整个团队都能严格有效地进行 code review 是一个循序渐进的过程。如果你所处的角色无法很快改变团队的工作方式，那么可以从把自己的代码发给别人 review 开始，实际可见的价值是最有说服力的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/10/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/code-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/10/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/code-review/" class="post-title-link" itemprop="url">是否要进行Code Review？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-07-10 09:53:23" itemprop="dateCreated datePublished" datetime="2020-07-10T09:53:23+00:00">2020-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A0%94%E5%8F%91%E8%A7%84%E8%8C%83/" itemprop="url" rel="index"><span itemprop="name">研发规范</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不少开发团队和创业公司都在纠结是否要执行 code review，既希望改进代码质量，又担心带来的负担会拖慢项目进度。实时上，在软件开发中质量和效率往往并不是二选其一的关系。能产出高质量代码的团队通常效率也非常高。</p>
<p>在我作为工程师的职业经历中，自动化测试和 code review 可说是能同时提高代码质量和开发效率的两个最有效的手段。所谓 code review，和学术界的 peer review 类似。Peer review 是由同事或同行对一位作者的作品进行查阅并提出建议和问题，只有当所有提出的问题都得到满意的答案后，作品才能发表。对于 code review 来说，作品就是代码，发表就是把代码 commit 到官方代码库。</p>
<p>在 Code Complete 这本书中讲述了两个很有说服力的案例。在一项对同一个团队开发的很多个程序进行对比的研究中，没有经过 review 的程序平均每 100 行有 4.5 个错误，而经过 review 的程序平均每 100 行只有 0.82 个错误，也就是说 80% 的错误在 review 中被修正了。AT &amp; T 的一个 200 多人的部门在开始执行 code review 后，开发效率提高了 14%，而错误减少了 90% 左右。</p>
<p>除了减少缺陷，避免在诊断错误上浪费时间，review 的过程还可以通过相互的督促保证代码有好的可读性、文档、风格，并同时检查测试覆盖率等开发过程中的规范，从而提高团队的协作效率。对于所有复杂的事情来说，总是越早发现问题，解决问题的成本越低。</p>
<p>对于经验不足或者刚开始一份新工作的人来说，通过 code review 可以得到更资深的人帮助，更快熟悉现有的规范和架构，在新的环境和团队中快速提升。</p>
<p>对于资深的工程师来说，让其他同事 review 代码，有利于在团队中传播经验、知识和好的实践。身边的同事水平提高会让自己的工作也更高效。并且谁都有需要休假的时候，无论是公司还是个人都不希望有太多工作因此而停滞，如果有平时就熟悉自己工作的同事，这个问题就很好解决。</p>
<p>像很多其他事情一样，code review 最难的就是迈出第一步。一旦开始，花在 review 过程的每一分钟都会很快被成倍地赚回来。如果你不在一个可以一下改变团队流程的位置上，那么至少可以和认同这件事的少数同事先开始实践，当价值开始体现的时候，相信其他人会乐于效仿。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/23/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/23/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Git学习总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-23 22:30:00" itemprop="dateCreated datePublished" datetime="2020-06-23T22:30:00+00:00">2020-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">研发工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h1><p>Git是免费、开源的 <strong>分布式版本控制</strong> 系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。那些年，我们的毕业论文,其实就是版本变更的真实写照…脑洞一下，版本控制就是这些论文变更的管理</p>
<p><img src="/images/%E8%AE%BA%E6%96%87%E7%89%88%E6%9C%AC.png" alt="论文版本"></p>
<h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>那么，集中化的版本控制系统又是什么呢，说白了，就是有一个集中管理的中央服务器，保存着所有文件的修改历史版本，而协同开发者通过客户端连接到这台服务器，从服务器上同步更新或上传自己的修改。</p>
<p><img src="/images/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png" alt="集中化的版本控制"></p>
<h3 id="分布式的版本控制系统"><a href="#分布式的版本控制系统" class="headerlink" title="分布式的版本控制系统"></a>分布式的版本控制系统</h3><p>分布式版本控制系统，就是远程仓库同步所有版本信息到本地的每个用户。这里分三点阐述：</p>
<ul>
<li>用户在本地就可以查看所有的历史版本信息，但是偶尔要从远程更新一下，因为可能别的用户有文件修改提交到远程。</li>
<li>用户即使离线也可以本地提交，push推送到远程服务器才需要联网。</li>
<li>每个用户都保存了历史版本，所以只要有一个用户设备没问题，就可以恢复数据了</li>
</ul>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png" alt="分布式的版本控制"></p>
<h1 id="Git的相关理论基础"><a href="#Git的相关理论基础" class="headerlink" title="Git的相关理论基础"></a><strong>Git的相关理论基础</strong></h1><h2 id="Git的四大工作区域"><a href="#Git的四大工作区域" class="headerlink" title="Git的四大工作区域"></a>Git的四大工作区域</h2><p>先复习Git的几个工作区域：</p>
<p><img src="/images/git%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F.png" alt="git的四大工作区域"></p>
<ul>
<li><strong>Workspace</strong> ：你电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。</li>
<li><strong>Index&#x2F;Stage</strong> ：暂存区，一般存放在 .git目录下，即.git&#x2F;index,它又叫待提交更新区，用于临时存放你未提交的改动。比如，你执行git add，这些改动就添加到这个区域啦。</li>
<li><strong>Repository</strong> ：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中 <strong>HEAD指向最新放入仓库的版本</strong> 。当你执行git commit，文件改动就到本地仓库来了~</li>
<li><strong>Remote</strong> ：远程仓库，就是类似github，码云等网站所提供的仓库，可以理解为远程数据交换的仓库</li>
</ul>
<h2 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h2><p>上一小节介绍完Git的四大工作区域，把git的操作命令和几个工作区域结合起来，个人觉得更容易理解一些，看图：</p>
<p><img src="/images/git%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="git的工作流程"></p>
<p>git 的正向工作流程一般就这样：</p>
<ul>
<li>从远程仓库拉取文件代码回来；</li>
<li>在工作目录，增删改查文件；</li>
<li>把改动的文件放入暂存区；</li>
<li>将暂存区的文件提交本地仓库；</li>
<li>将本地仓库的文件推送到远程仓库；</li>
</ul>
<h2 id="Git文件的四种状态"><a href="#Git文件的四种状态" class="headerlink" title="Git文件的四种状态"></a>Git文件的四种状态</h2><p>根据一个文件是否已加入版本控制，可以把文件状态分为：Tracked(已跟踪)和Untracked(未跟踪)，而tracked(已跟踪)又包括三种工作状态：Unmodified，Modified，Staged</p>
<p><img src="/images/git%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="git文件的四种状态"></p>
<ul>
<li><strong>Untracked</strong> : 文件还没有加入到git库，还没参与版本控制，即未跟踪状态。这时候的文件，通过git add 状态，可以变为Staged状态</li>
<li><strong>Unmodified</strong> ：文件已经加入git库, 但是呢，还没修改, 就是说版本库中的文件快照内容与文件夹中还完全一致。Unmodified的文件如果被修改, 就会变为Modified. 如果使用git remove移出版本库, 则成为Untracked文件。</li>
<li><strong>Modified</strong> ：文件被修改了，就进入modified状态啦，文件这个状态通过stage命令可以进入staged状态</li>
<li><strong>staged</strong> ：暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodified状态.</li>
</ul>
<h1 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h1><h2 id="日常开发中，Git的基本常用命令"><a href="#日常开发中，Git的基本常用命令" class="headerlink" title="日常开发中，Git的基本常用命令"></a><strong>日常开发中，Git的基本常用命令</strong></h2><ul>
<li>git clone</li>
<li>git checkout -b dev</li>
<li>git add</li>
<li>git commit</li>
<li>git log</li>
<li>git diff</li>
<li>git status</li>
<li>git pull&#x2F;git fetch</li>
<li>git push</li>
</ul>
<p>这个图只是模拟一下git基本命令使用的大概流程</p>
<p><img src="/images/git%E7%9A%84%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B.png" alt="git的大概流程"></p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>当我们要进行开发，第一步就是克隆远程版本库到本地</p>
<pre><code>git clone url  克隆远程版本库  
  
</code></pre>
<h3 id="git-checkout-b-dev"><a href="#git-checkout-b-dev" class="headerlink" title="git checkout -b dev"></a>git checkout -b dev</h3><p>克隆完之后呢，开发新需求的话，我们需要新建一个开发分支，比如新建开发分支dev</p>
<p>创建分支：</p>
<pre><code>git checkout -b dev   创建开发分支dev，并切换到该分支下  
</code></pre>
<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add的使用格式：</p>
<pre><code>git add .	添加当前目录的所有文件到暂存区  
git add [dir]	添加指定目录到暂存区，包括子目录  
git add [file1]	添加指定文件到暂存区  
</code></pre>
<p>有了开发分支dev之后，我们就可以开始开发啦，假设我们开发完HelloWorld.java，可以把它加到暂存区，命令如下</p>
<pre><code>git add Hello.java  把HelloWorld.java文件添加到暂存区去  
</code></pre>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit的使用格式：</p>
<pre><code>git commit -m [message] 提交暂存区到仓库区,message为说明信息  
git commit [file1] -m [message] 提交暂存区的指定文件到本地仓库  
git commit --amend -m [message] 使用一次新的commit，替代上一次提交  
  
</code></pre>
<p>把HelloWorld.java文件加到暂存区后，我们接着可以提交到本地仓库</p>
<pre><code>git commit -m &#39;helloworld开发&#39;  
  
</code></pre>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status,表示查看工作区状态，使用命令格式：</p>
<pre><code>git status  查看当前工作区暂存区变动  
git status -s  查看当前工作区暂存区变动，概要信息  
git status  --show-stash 查询工作区中是否有stash（暂存的文件）  
</code></pre>
<p>当你忘记是否已把代码文件添加到暂存区或者是否提交到本地仓库，都可以用git status看看</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>git log，这个命令用得应该比较多，表示查看提交历史&#x2F;提交日志，要回滚代码就经常用它看看提交历史。</p>
<pre><code>git log  查看提交历史  
git log --oneline 以精简模式显示查看提交历史  
git log -p &lt;file&gt; 查看指定文件的提交历史  
git blame &lt;file&gt; 一列表方式查看指定文件的提交历史  
</code></pre>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><pre><code>git diff 显示暂存区和工作区的差异  
git diff filepath   filepath路径文件中，工作区与暂存区的比较差异  
git diff HEAD filepath 工作区与HEAD ( 当前工作分支)的比较差异  
git diff branchName filepath 当前分支的文件与branchName分支的文件的比较差异  
git diff commitId filepath 与某一次提交的比较差异  
</code></pre>
<p>如果你想对比一下你改了哪些内容，可以用git diff对比一下文件修改差异</p>
<h3 id="git-pull-git-fetch"><a href="#git-pull-git-fetch" class="headerlink" title="git pull&#x2F;git fetch"></a>git pull&#x2F;git fetch</h3><pre><code>git pull  拉取远程仓库所有分支更新并合并到本地分支。  
git pull origin master 将远程master分支合并到当前本地分支  
git pull origin master:master 将远程master分支合并到当前本地master分支，冒号后面表示本地分支  
git fetch --all  拉取所有远端的最新代码  
git fetch origin master 拉取远程最新master分支代码  
</code></pre>
<p>我们一般都会用git pull拉取最新代码看看的，解决一下冲突，再推送代码到远程仓库的。</p>
<blockquote>
<p>有些伙伴可能对使用git pull还是git fetch有点疑惑，其实 git pull &#x3D; git fetch+ git<br>merge。pull的话，拉取远程分支并与本地分支合并，fetch只是拉远程分支，怎么合并，可以自己再做选择。</p>
</blockquote>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>git push 可以推送本地分支、标签到远程仓库，也可以删除远程分支。</p>
<pre><code>git push origin master 将本地分支的更新全部推送到远程仓库master分支。  
git push origin -d &lt;branchname&gt;   删除远程branchname分支  
git push --tags 推送所有标签  
</code></pre>
<p>如果我们在dev开发完，或者就想把文件推送到远程仓库，给别的伙伴看看，就可以使用git push origin dev</p>
<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>git branch用处多多呢，比如新建分支、查看分支、删除分支等等</p>
<p><strong>新建分支：</strong></p>
<pre><code>git checkout -b dev2  新建一个分支，并且切换到新的分支dev2  
git branch dev2 新建一个分支，但是仍停留在原来分支  
</code></pre>
<p><strong>查看分支：</strong></p>
<pre><code>git branch    查看本地所有的分支  
git branch -r  查看所有远程的分支  
git branch -a  查看所有远程分支和本地分支  
</code></pre>
<p><strong>删除分支：</strong></p>
<pre><code>git branch -D &lt;branchname&gt;  删除本地branchname分支  
</code></pre>
<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p> <strong>切换分支：</strong></p>
<pre><code>git checkout master 切换到master分支  
</code></pre>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>我们在开发分支dev开发、测试完成在发布之前，我们一般需要把开发分支dev代码合并到master，所以git merge也是程序员必备的一个命令。</p>
<pre><code>git merge master  在当前分支上合并master分支过来  
git merge --no-ff origin/dev  在当前分支上合并远程分支dev  
git merge --abort 终止本次merge，并回到merge前的状态  
</code></pre>
<p>比如，你开发完需求后，发版需要把代码合到主干master分支</p>
<h2 id="Git进阶之撤销与回退"><a href="#Git进阶之撤销与回退" class="headerlink" title="Git进阶之撤销与回退"></a><strong>Git进阶之撤销与回退</strong></h2><p>Git的撤销与回退，在日常工作中使用的比较频繁。比如我们想将某个修改后的文件撤销到上一个版本，或者想撤销某次多余的提交，都要用到git的撤销和回退操作。</p>
<p>代码在Git的每个工作区域都是用哪些命令撤销或者回退的呢，如下图所示：</p>
<p><img src="/images/git%E7%9A%84%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E9%80%80.jpg" alt="git的撤销与回退"></p>
<p>有关于Git的撤销与回退，一般就以下几个核心命令</p>
<ul>
<li>git checkout</li>
<li>git reset</li>
<li>git revert</li>
</ul>
<h3 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h3><p>如果文件还在 <strong>工作区</strong> ，还没添加到暂存区，可以使用git checkout撤销</p>
<pre><code>git checkout [file]  丢弃某个文件file  
git checkout .  丢弃所有文件  
</code></pre>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><h4 id="git-reset的理解"><a href="#git-reset的理解" class="headerlink" title="git reset的理解"></a>git reset的理解</h4><blockquote>
<p>git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本.</p>
</blockquote>
<p>为了更好地理解git reset，我们来回顾一下,Git的版本管理及HEAD的理解</p>
<blockquote>
<p>Git的所有提交，会连成一条时间轴线，这就是分支。如果当前分支是master，HEAD指针一般指向当前分支，如下：</p>
</blockquote>
<p><img src="/images/reset1.png" alt="reset1"></p>
<p>假设执行git reset，回退到版本二之后，版本三不见了,如下：</p>
<p><img src="/images/reset2.png" alt="reset2"></p>
<h4 id="git-reset的使用"><a href="#git-reset的使用" class="headerlink" title="git reset的使用"></a>git reset的使用</h4><p>Git Reset的几种使用模式</p>
<p><img src="/images/reset%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F.png" alt="reset的几种使用模式"></p>
<pre><code>git reset HEAD --file回退暂存区里的某个文件，回退到当前版本工作区状态  
git reset –-soft 目标版本号 可以把版本库上的提交回退到暂存区，修改记录保留  
git reset –-mixed 目标版本号 可以把版本库上的提交回退到工作区，修改记录保留  
git reset –-hard  可以把版本库上的提交彻底回退，修改的记录全部revert。  
</code></pre>
<p>先看一个栗子demo吧，代码 <strong>git add到暂存区，并未commit提交</strong> ,可以酱紫回退，如下：</p>
<pre><code>git reset HEAD file 取消暂存  
git checkout file 撤销修改  
</code></pre>
<p>再看另外一个栗子吧，代码已经git commit了，但是还没有push：</p>
<pre><code>git log  获取到想要回退的commit_id  
git reset --hard commit_id  想回到过去，回到过去的commit_id  
</code></pre>
<p>如果代码已经push到远程仓库了呢，也可以使用reset回滚</p>
<pre><code>git log  
git reset --hard commit_id  
git push origin HEAD --force  
</code></pre>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><blockquote>
<p>与git reset不同的是，revert复制了那个想要回退到的历史版本，将它加在当前分支的最前端。</p>
</blockquote>
<p><strong>revert之前：</strong></p>
<p><img src="/images/revert%E4%B9%8B%E5%89%8D.png" alt="revert之前"></p>
<p><strong>revert 之后：</strong></p>
<p><img src="/images/revert%E4%B9%8B%E5%90%8E.png" alt="revert之后"></p>
<p>当然，如果代码已经推送到远程的话，还可以考虑revert回滚</p>
<pre><code>git log  得到你需要回退一次提交的commit id  
git revert -n &lt;commit_id&gt;  撤销指定的版本，撤销也会作为一次提交进行保存  
</code></pre>
<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>rebase又称为衍合，是合并的另外一种选择。</p>
<p>假设有两个分支master和test</p>
<pre><code>     D---E test        
    /  
A---B---C---F--- master  
  
</code></pre>
<p>执行 git merge test得到的结果</p>
<pre><code>      D--------E      
     /          \  
A---B---C---F----G---   test, master  
  
</code></pre>
<p>执行git rebase test，得到的结果</p>
<pre><code>A---B---D---E---C‘---F‘---   test, master  
  
</code></pre>
<p><strong>rebase好处是：</strong> 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：git<br>pull –rebase，就是因为想更优雅，哈哈</p>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>stash命令可用于临时保存和恢复修改</p>
<pre><code>git stash  把当前的工作隐藏起来 等以后恢复现场后继续工作  
git stash list 显示保存的工作进度列表  
git stash pop stash@&#123;num&#125; 恢复工作进度到工作区  
git stash show ：显示做了哪些改动  
git stash drop stash@&#123;num&#125; ：删除一条保存的工作进度  
git stash clear 删除所有缓存的stash。  
  
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS/" class="post-title-link" itemprop="url">Http和Https</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-23 22:30:00" itemprop="dateCreated datePublished" datetime="2020-05-23T22:30:00+00:00">2020-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h1><p>HTTP协议（HyperText Transfer<br>Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网&#x2F;内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource<br>Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<h2 id="HTTP工作过程"><a href="#HTTP工作过程" class="headerlink" title="HTTP工作过程"></a>HTTP工作过程</h2><p><img src="/images/HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B.jpg" alt="HTTP请求响应模型"></p>
<p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p>
<ol>
<li><p><strong>建立 TCP 连接</strong><br>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的<br>TCP&#x2F;IP 协议族，因此 Internet 又被称作是 TCP&#x2F;IP 网络。HTTP 是比 TCP<br>更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p>
</li>
<li><p><strong>客户端向服务器发送请求命令</strong><br>一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：<code>GET/sample/hello.jsp HTTP/1.1</code></p>
</li>
<li><p><strong>客户端发送请求头信息</strong><br>客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p>
</li>
<li><p><strong>服务器应答</strong><br>客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： <code>HTTP/1.1 200 OK</code><br>响应的第一部分是协议的版本号和响应状态码</p>
</li>
<li><p><strong>服务器返回响应头信息</strong><br>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p>
</li>
<li><p><strong>服务器向客户端发送数据</strong><br>服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type<br>响应头信息所描述的格式发送用户所请求的实际数据；</p>
</li>
<li><p><strong>服务器关闭 TCP 连接</strong><br>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 <code>Connection:keep- alive</code> ，TCP<br>连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
</li>
</ol>
<h2 id="HTTP协议基础"><a href="#HTTP协议基础" class="headerlink" title="HTTP协议基础"></a>HTTP协议基础</h2><h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP<br>协议规定，请求从客户端发出，最后服务器端响应该请求并返回。 <strong>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</strong></p>
<h3 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h3><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP<br>这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP<br>协议通信，就可以管理状态了。</p>
<h3 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h3><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-<br>Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie<br>值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问<br>HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br>为了解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和部分 HTTP&#x2F;1.0 想出了持久连接的方法。 <strong>其特点是，只要任意一端没有明确提出断开连接，则保持<br>TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。</strong> 在 HTTP&#x2F;1.1 中，所有的连接默认都是持久连接。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br>比如，当请求一个包含多张图片的 HTML<br>页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>
<h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP<br>报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>
<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：</p>
<p><img src="/images/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="HTTP报文结构"></p>
<h4 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h4><p><img src="/images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="请求报文结构"></p>
<p>请求报文的首部内容由以下数据组成：</p>
<ul>
<li><strong>请求行</strong> —— 包含用于请求的方法、请求 URI 和 HTTP 版本。</li>
<li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li>
</ul>
<p>请求报文的示例，如：</p>
<p><img src="/images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%A4%BA%E4%BE%8B.jpg" alt="请求报文示例"></p>
<h4 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h4><p><img src="/images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="响应报文结构"></p>
<p>响应报文的首部内容由以下数据组成：</p>
<ul>
<li><strong>状态行</strong> —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。</li>
<li><strong>首部字段</strong> —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）</li>
</ul>
<p>响应报文的示例，如下：</p>
<p><img src="/images/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%A4%BA%E4%BE%8B.jpg" alt="响应报文示例"></p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTP的弊端"><a href="#HTTP的弊端" class="headerlink" title="HTTP的弊端"></a>HTTP的弊端</h2><p>HTTP 之所以被 HTTPS 取代，最大的原因就是不安全，至于为什么不安全，看了下面这张图就一目了然了。</p>
<p><img src="/images/HTTP%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="HTTP传输过程"></p>
<p>由图可见，HTTP<br>在传输数据的过程中，所有的数据都是明文传输，自然没有安全性可言，特别是一些敏感数据，比如用户密码和信用卡信息等，一旦被第三方获取，后果不堪设想。</p>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>HTTPS<br>解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也就是对称加密和非对称加密的混合使用，这里有必要先了解一下这两种加密算法的区别和优缺点。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密，顾名思义就是加密和解密都是使用同一个密钥，常见的对称加密算法有 DES、3DES 和 AES 等，其优缺点如下：</p>
<ul>
<li><p>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。</p>
</li>
<li><p>缺点：</p>
</li>
<li><ol>
<li>交易双方需要使用相同的密钥，也就无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。</li>
</ol>
</li>
<li><ol start="2">
<li>每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，密钥管理成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</li>
</ol>
</li>
</ul>
<p>如果直接将对称加密算法用在 HTTP 中，会是下面的效果：</p>
<p><img src="/images/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="对称加密传输过程"></p>
<p>从图中可以看出，被加密的数据在传输过程中是无规则的乱码，即便被第三方截获，在没有密钥的情况下也无法解密数据，也就保证了数据的安全。但是有一个致命的问题，那就是既然双方要使用相同的密钥，那就必然要在传输数据之前先由一方把密钥传给另一方，那么在此过程中密钥就很有可能被截获，这样一来加密的数据也会被轻松解密。那如何确保密钥在传输过程中的安全呢？这就要用到非对称加密了。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，顾名思义，就是加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private<br>key）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥对外公开；得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的私钥对加密后的信息进行解密。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。常用的非对称加密算法是<br>RSA 算法，其优缺点如下：</p>
<ul>
<li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li>
<li>缺点：计算量比较大，加密和解密速度相比对称加密慢很多。</li>
</ul>
<p>由于非对称加密的强安全性，可以用它完美解决对称加密的密钥泄露问题，效果图如下：</p>
<p><img src="/images/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8F%91%E9%80%81KEY%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="非对称加密发送 KEY
的过程"></p>
<p>在上述过程中，客户端在拿到服务器的公钥后，会生成一个随机码 (用 KEY 表示，这个 KEY 就是后续双方用于对称加密的密钥)，然后客户端使用公钥把 KEY<br>加密后再发送给服务器，服务器使用私钥将其解密，这样双方就有了同一个密钥 KEY，然后双方再使用 KEY 进行对称加密交互数据。在非对称加密传输 KEY<br>的过程中，即便第三方获取了公钥和加密后的 KEY，在没有私钥的情况下也无法破解 KEY<br>(私钥存在服务器，泄露风险极小)，也就保证了接下来对称加密的数据安全。而上面这个流程图正是 HTTPS 的雏形，HTTPS<br>正好综合了这两种加密算法的优点，不仅保证了通信安全，还保证了数据传输效率。</p>
<h2 id="HTTPS原理详解"><a href="#HTTPS原理详解" class="headerlink" title="HTTPS原理详解"></a>HTTPS原理详解</h2><p>HTTPS 并非独立的通信协议，而是对 HTTP 的扩展，保证了通信安全，二者关系如下：</p>
<p><img src="/images/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HTTP和HTTPS的关系"></p>
<p>也就是说 HTTPS &#x3D; HTTP + SSL &#x2F; TLS。</p>
<p>接下来就是最重要的 HTTPS 原理解析了，老规矩先上图</p>
<p><img src="/images/HTTPS%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86%E3%80%81%E9%AA%8C%E8%AF%81%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="HTTPS
加密、解密、验证及数据传输过程"></p>
<p>HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段。具体流程按图中的序号讲解。</p>
<ol>
<li><p>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。</p>
</li>
<li><p>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书 (当然了是要钱的，安全级别越高价格越贵)。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p>
</li>
<li><p>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。</p>
</li>
</ol>
<p>![CA 证书](&#x2F;images&#x2F;CA 证书.png)</p>
<ol start="4">
<li>客户端解析证书并对其进行验证。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。就像下面这样：</li>
</ol>
<p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E8%AD%A6%E5%91%8A.png" alt="浏览器安全警告"></p>
<ol start="5">
<li><p>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。</p>
</li>
<li><p>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</p>
</li>
<li><p>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p>
</li>
<li><p>双方使用对称加密愉快地传输所有数据。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> <strong>HTTPS 和 HTTP 的区别：</strong></p>
<ul>
<li>最最重要的区别就是安全性，HTTP 明文传输，不对数据进行加密安全性较差。HTTPS (HTTP + SSL &#x2F; TLS)的数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。</li>
<li>由于 HTTPS 是建构在 SSL &#x2F; TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。</li>
<li>HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。</li>
</ul>
<p><strong>HTTPS 的缺点：</strong></p>
<ul>
<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/12/jvm/Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/12/jvm/Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">Jvav线程间通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-12 22:30:00" itemprop="dateCreated datePublished" datetime="2020-04-12T22:30:00+00:00">2020-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="保证内存可见性"><a href="#保证内存可见性" class="headerlink" title="保证内存可见性"></a>保证内存可见性</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU<br>cache中。<br>volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU<br>cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。</p>
<p><img src="/images/volatile.png" alt="内存可见性问题"></p>
<h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。<br>在JDK1.5之后，可以使用volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，指令重排序时不能把后面的指令重排序到内存屏</p>
<pre><code>示例说明：  
double r = 2.1; //(1)   
double pi = 3.14;//(2)   
double area = pi*r*r;//(3)1234  
</code></pre>
<p>虽然代码语句的定义顺序为1-&gt;2-&gt;3，但是计算顺序1-&gt;2-&gt;3与2-&gt;1-&gt;3对结果并无影响，所以编译时和运行时可以根据需要对1、2语句进行重排序。后面写文章分析一下JIT的问题，工作中同事提出了一个有意思的问题。。</p>
<h4 id="指令重排序带来的问题"><a href="#指令重排序带来的问题" class="headerlink" title="指令重排序带来的问题"></a>指令重排序带来的问题</h4><p>基于双重检验的单例模式(懒汉型)</p>
<pre><code>public class Singleton3 &#123;  
    private static Singleton3 instance = null;  
  
    private Singleton3() &#123;&#125;  
  
    public static Singleton3 getInstance() &#123;  
        if (instance == null) &#123;  
            synchronized(Singleton3.class) &#123;  
                if (instance == null)  
                    instance = new Singleton3();// 非原子操作  
            &#125;  
        &#125;  
  
        return instance;  
    &#125;  
&#125;12345678910111213141516  
  
</code></pre>
<p>instance&#x3D; new Singleton()并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p>
<pre><code>memory =allocate();    //1：分配对象的内存空间   
ctorInstance(memory);  //2：初始化对象   
instance =memory;     //3：设置instance指向刚分配的内存地址123  
  
</code></pre>
<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2。所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p>
<pre><code>memory =allocate();    //1：分配对象的内存空间   
instance =memory;     //3：instance指向刚分配的内存地址，此时对象还未初始化  
ctorInstance(memory);  //2：初始化对象123  
  
</code></pre>
<p>指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</p>
<p><strong>解决办法</strong><br>用volatile关键字修饰instance变量，使得instance在读、写操作前后都会插入内存屏障，避免重排序。</p>
<pre><code>public class Singleton3 &#123;  
    private static volatile Singleton3 instance = null;  
  
    private Singleton3() &#123;&#125;  
  
    public static Singleton3 getInstance() &#123;  
        if (instance == null) &#123;  
            synchronized(Singleton3.class) &#123;  
                if (instance == null)  
                    instance = new Singleton3();  
            &#125;  
        &#125;  
        return instance;  
    &#125;  
  
</code></pre>
<p>volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>JVM内存屏障插入策略：</p>
<ol>
<li>每个volatile写操作的前面插入一个StoreStore屏障；</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障；</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障；</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>volatile是 <strong>轻量级同步机制</strong> 。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，是一种比synchronized关键字更轻量级的同步机制。</li>
<li>volatile <strong>无法同时保证内存可见性和原子性</strong> 。加锁机制既可以确保可见性又可以确保原子性，而volatile变量 <strong>只能确保可见性</strong> 。</li>
<li>volatile不能修饰写入操作依赖当前值的变量。声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count &#x3D; count+1”。</li>
<li>当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile；</li>
<li>volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</li>
</ul>
<p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p>
<p>所以从Oracle Java Spec里面可以看到：</p>
<ul>
<li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li>
<li>如果使用volatile修饰long和double，那么其读写都是原子操作</li>
<li>对于64位的引用地址的读写，都是原子操作</li>
<li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li>
<li>推荐JVM实现为原子操作</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>众所周知 <code>synchronized</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>
<ul>
<li>同步普通方法，锁的是当前对象。</li>
<li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li>
<li>同步块，锁的是 <code>()</code> 中的对象。</li>
</ul>
<h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>
<p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p>
<p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><code>synchronized</code> 很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronized</code><br>进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</p>
<p>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是： <strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong><br>，这几个状态会随着竞争情况逐渐升级。 <strong>锁可以升级但不能降级</strong><br>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：</p>
<p><img src="/images/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4MarkWord.png" alt="Java对象头MarkWord"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>当一个线程访问同步块并获取锁时，会在 <strong>对象头</strong> 和 <strong>栈帧中的锁记录</strong><br>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark<br>Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark<br>Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>偏向锁使用了一种 <strong>等到竞争出现才释放锁</strong> 的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
<p><img src="/images/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="偏向锁的撤销"></p>
<p>如图，偏向锁的撤销，需要等待 <strong>全局安全点</strong><br>（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark<br>Word <strong>要么</strong> 重新偏向于其他线程， <strong>要么</strong> 恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p>如果配置中关闭偏向锁，则直接进入轻量级锁</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当偏向锁出现锁竞争时，就会升级为轻量级锁。</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中 <strong>创建用于存储锁记录的空间</strong> ，并将对象头中的Mark Word复制到锁记录中，官方称为<br><strong>Displaced Mark Word</strong> 。然后线程尝试使用CAS <strong>将对象头中的Mark Word替换为指向锁记录的指针</strong><br>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark<br>Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h4><p>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了<br><code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:</p>
<blockquote>
<p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p>
</blockquote>
<p>这里还需要提一下，重量级锁是可以降级的，在GC中STW时，<br><strong>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被VMThread访问而没有其他JavaThread访问的对象。</strong></p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p><img src="/images/AQS%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="AQS架构图"></p>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and<br>Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
<p><img src="/images/CLH%E9%98%9F%E5%88%97.png" alt="CLH队列"></p>
<h3 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h3><pre><code>// 队列的数据结构如下  
// 结点的数据结构  
static final class Node &#123;  
    // 表示该节点等待模式为共享式，通常记录于nextWaiter，  
    // 通过判断nextWaiter的值可以判断当前结点是否处于共享模式  
    static final Node SHARED = new Node();  
    // 表示节点处于独占式模式，与SHARED相对  
    static final Node EXCLUSIVE = null;  
    // waitStatus的不同状态，具体内容见下文的表格  
    static final int CANCELLED =  1;  
    static final int SIGNAL    = -1;  
    static final int CONDITION = -2;  
    static final int PROPAGATE = -3;  
    volatile int waitStatus;  
    // 记录前置结点  
    volatile Node prev;  
    // 记录后置结点  
    volatile Node next;  
    // 记录当前的线程  
    volatile Thread thread;  
    // 用于记录共享模式(SHARED), 也可以用来记录CONDITION队列(见扩展分析)  
    Node nextWaiter;  
    // 通过nextWaiter的记录值判断当前结点的模式是否为共享模式  
    final boolean isShared() &#123;	return nextWaiter == SHARED;&#125;  
    // 获取当前结点的前置结点  
    final Node predecessor() throws NullPointerException &#123; ... &#125;  
    // 用于初始化时创建head结点或者创建SHARED结点  
    Node() &#123;&#125;  
    // 在addWaiter方法中使用，用于创建一个新的结点  
    Node(Thread thread, Node mode) &#123;       
        this.nextWaiter = mode;  
        this.thread = thread;  
    &#125;  
    // 在CONDITION队列中使用该构造函数新建结点  
    Node(Thread thread, int waitStatus) &#123;   
        this.waitStatus = waitStatus;  
        this.thread = thread;  
    &#125;  
&#125;  
// 记录头结点  
private transient volatile Node head;  
// 记录尾结点  
private transient volatile Node tail;  
  
</code></pre>
<p>Node状态表(waitStatus，初始化时默认为0)</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>状态值</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>1</td>
<td>说明当前结点(即相应的线程)是因为超时或者中断取消的，进入该状态后将无法恢复</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>说明当前结点的后继结点是(或者将要)由park导致阻塞的，当结点被释放或者取消时，需要通过unpark唤醒后继结点(表现为unparkSuccessor()方法)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CONDITION</td>
<td>-2</td>
<td></td>
</tr>
<tr>
<td>该状态是用于condition队列结点的，表明结点在等待队列中，结点线程等待在Condition上，当其他线程对Condition调用了signal()方法时，会将其加入到同步队列中去</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>-3</td>
<td>说明下一次共享式同步状态的获取将会无条件地向后继结点传播</td>
</tr>
</tbody></table>
<h3 id="AQS的重要方法"><a href="#AQS的重要方法" class="headerlink" title="AQS的重要方法"></a>AQS的重要方法</h3><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（并不是全部）：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>protected boolean isHeldExclusively()</td>
<td>该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
</tr>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td></td>
</tr>
<tr>
<td>独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
<td></td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td></td>
</tr>
<tr>
<td>独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
<td></td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td></td>
</tr>
<tr>
<td>共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
<td></td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td></td>
</tr>
<tr>
<td>共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
<td></td>
</tr>
</tbody></table>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-<br>tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-<br>tryRelease。</p>
<p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p>
<p><img src="/images/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="公平锁和非公平锁加锁流程"></p>
<p>以非公平锁ReentrantLock为例，加锁和解锁的流程如下：</p>
<p><img src="/images/ReentrantLock%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="ReentrantLock加锁和解锁流程"></p>
<p>加锁：</p>
<ul>
<li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li>
<li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li>
<li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li>
<li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li>
</ul>
<p>解锁：</p>
<ul>
<li>通过ReentrantLock的解锁方法Unlock进行解锁。</li>
<li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li>
<li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li>
</ul>
<h4 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h4><pre><code>// 这里不去看tryAcquire、tryRelease方法的具体实现，只知道它们的作用分别为尝试获取同步状态、尝试释放同步状态  
  
public final void acquire(int arg) &#123;  
    // 如果线程直接获取成功，或者再尝试获取成功后都是直接工作，  
    // 如果是从阻塞状态中唤醒开始工作的线程，将当前的线程中断  
    if (!tryAcquire(arg) &amp;&amp;  
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  
        selfInterrupt();  
&#125;  
// 包装线程，新建结点并加入到同步队列中  
private Node addWaiter(Node mode) &#123;  
    Node node = new Node(Thread.currentThread(), mode);  
    Node pred = tail;  
    // 尝试入队， 成功返回  
    if (pred != null) &#123;  
        node.prev = pred;  
        // CAS操作设置队尾  
        if (compareAndSetTail(pred, node)) &#123;  
            pred.next = node;  
            return node;  
        &#125;  
    &#125;  
    // 通过CAS操作自旋完成node入队操作  
    enq(node);  
    return node;  
&#125;  
&#125;  
  
</code></pre>
<p>addWaiter主要的流程如下：</p>
<ul>
<li><p>通过当前的线程和锁模式新建一个节点。</p>
</li>
<li><p>Pred指针指向尾节点Tail。</p>
</li>
<li><p>将New中Node的Prev指针指向Pred。</p>
</li>
<li><p>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</p>
<p>static {<br>try {<br>    stateOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(“state”));<br>    headOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(“head”));<br>    tailOffset &#x3D; unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(“tail”));<br>    waitStatusOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(“waitStatus”));<br>    nextOffset &#x3D; unsafe.objectFieldOffset(Node.class.getDeclaredField(“next”));<br>} catch (Exception ex) {<br>throw new Error(ex);<br>  }<br>}</p>
</li>
</ul>
<p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p>
<ul>
<li><p>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</p>
<p>&#x2F;&#x2F; java.util.concurrent.locks.AbstractQueuedSynchronizer  </p>
<p>private Node enq(final Node node) {<br>for (;;) {<br>    Node t &#x3D; tail;<br>    if (t &#x3D;&#x3D; null) { &#x2F;&#x2F; Must initialize<br>        if (compareAndSetHead(new Node()))<br>            tail &#x3D; head;<br>    } else {<br>        node.prev &#x3D; t;<br>        if (compareAndSetTail(t, node)) {<br>            t.next &#x3D; node;<br>            return t;<br>        }<br>    }<br>}<br>}</p>
</li>
</ul>
<p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p>
<pre><code>// 在同步队列中等待获取同步状态  
final boolean acquireQueued(final Node node, int arg) &#123;  
    boolean failed = true;  
    try &#123;  
        boolean interrupted = false;  
        // 自旋  
        for (;;) &#123;  
            final Node p = node.predecessor();  
            // 检查是否符合开始工作的条件  
            if (p == head &amp;&amp; tryAcquire(arg)) &#123;  
                setHead(node);  
                p.next = null;  
                failed = false;  
                return interrupted;  
            &#125;  
            // 获取不到同步状态，将前置结点标为SIGNAL状态并且通过park操作将node包装的线程阻塞  
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  
                parkAndCheckInterrupt())  
                interrupted = true;  
        &#125;  
    &#125; finally &#123;  
        // 如果获取失败，将node标记为CANCELLED  
        if (failed)  
            cancelAcquire(node);  
    &#125;  

//setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。  
private void setHead(Node node) &#123;  
    head = node;  
    node.thread = null;  
    node.prev = null;  
&#125;  
  
// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
// 靠前驱节点判断当前线程是否应该被阻塞  
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;  
    // 获取头结点的节点状态  
    int ws = pred.waitStatus;  
    // 说明头结点处于唤醒状态  
    if (ws == Node.SIGNAL)  
        return true;   
    // 通过枚举值我们知道waitStatus&gt;0是取消状态  
    if (ws &gt; 0) &#123;  
        do &#123;  
            // 循环向前查找取消节点，把取消节点从队列中剔除  
            node.prev = pred = pred.prev;  
        &#125; while (pred.waitStatus &gt; 0);  
        pred.next = node;  
    &#125; else &#123;  
        // 设置前任节点等待状态为SIGNAL  
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  
    &#125;  
    return false;  
&#125;  
  
</code></pre>
<p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
private final boolean parkAndCheckInterrupt() &#123;  
    LockSupport.park(this);  
    return Thread.interrupted();  
&#125;  
</code></pre>
<h4 id="cancelAcquire方法"><a href="#cancelAcquire方法" class="headerlink" title="cancelAcquire方法"></a>cancelAcquire方法</h4><pre><code>private void cancelAcquire(Node node) &#123;  
  // 将无效节点过滤  
    if (node == null)  
        return;  
  // 设置该节点不关联任何线程，也就是虚节点  
    node.thread = null;  
    Node pred = node.prev;  
  // 通过前驱节点，跳过取消状态的node  
    while (pred.waitStatus &gt; 0)  
        node.prev = pred = pred.prev;  
  // 获取过滤后的前驱节点的后继节点  
    Node predNext = pred.next;  
  // 把当前node的状态设置为CANCELLED  
    node.waitStatus = Node.CANCELLED;  
  // 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点  
  // 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null  
    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  
        compareAndSetNext(pred, predNext, null);  
    &#125; else &#123;  
        int ws;  
    // 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功  
    // 如果1和2中有一个为true，再判断当前节点的线程是否为null  
    // 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点  
        if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123;  
            Node next = node.next;  
            if (next != null &amp;&amp; next.waitStatus &lt;= 0)  
                compareAndSetNext(pred, predNext, next);  
        &#125; else &#123;  
      // 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点  
            unparkSuccessor(node);  
        &#125;  
        node.next = node; // help GC  
    &#125;  
&#125;  
  
</code></pre>
<p>当前的流程：</p>
<ul>
<li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;&#x3D; 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li>
<li>根据当前节点的位置，考虑以下三种情况：</li>
</ul>
<p>(1) 当前节点是尾节点。</p>
<p>(2) 当前节点是Head的后继节点。</p>
<p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p>
<p><strong>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。<br>shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</strong></p>
<pre><code>do &#123;  
    node.prev = pred = pred.prev;  
&#125; while (pred.waitStatus &gt; 0);  
  
</code></pre>
<h4 id="unlock方法"><a href="#unlock方法" class="headerlink" title="unlock方法"></a><strong>unlock方法</strong></h4><pre><code>public void unlock() &#123;  
    sync.release(1);  
&#125;  
  
</code></pre>
<p>可以看到，本质释放锁的地方，是通过框架来完成的。</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
public final boolean release(int arg) &#123;  
    if (tryRelease(arg)) &#123;  
        Node h = head;  
        if (h != null &amp;&amp; h.waitStatus != 0)  
            unparkSuccessor(h);  
        return true;  
    &#125;  
    return false;  
&#125;  
  
</code></pre>
<p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p>
<pre><code>// java.util.concurrent.locks.ReentrantLock.Sync  
  
// 方法返回当前锁是不是没有被线程持有  
protected final boolean tryRelease(int releases) &#123;  
    // 减少可重入次数  
    int c = getState() - releases;  
    // 当前线程不是持有锁的线程，抛出异常  
    if (Thread.currentThread() != getExclusiveOwnerThread())  
        throw new IllegalMonitorStateException();  
    boolean free = false;  
    // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state  
    if (c == 0) &#123;  
        free = true;  
        setExclusiveOwnerThread(null);  
    &#125;  
    setState(c);  
    return free;  
&#125;  
  
</code></pre>
<p>我们来解释下述源码：</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
public final boolean release(int arg) &#123;  
    // 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有  
    if (tryRelease(arg)) &#123;  
        // 获取头结点  
        Node h = head;  
        // 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态  
        if (h != null &amp;&amp; h.waitStatus != 0)  
            unparkSuccessor(h);  
        return true;  
    &#125;  
    return false;  
&#125;  
  
</code></pre>
<p>这里的判断条件为什么是h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0？</p>
<blockquote>
<p>h &#x3D;&#x3D; null Head还没初始化。初始情况下，head &#x3D;&#x3D;<br>null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head &#x3D;&#x3D; null 的情况。</p>
<p>h !&#x3D; null &amp;&amp; waitStatus &#x3D;&#x3D; 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p>
<p>h !&#x3D; null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p>
</blockquote>
<p>再看一下unparkSuccessor方法：</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
private void unparkSuccessor(Node node) &#123;  
    // 获取头结点waitStatus  
    int ws = node.waitStatus;  
    if (ws &lt; 0)  
        compareAndSetWaitStatus(node, ws, 0);  
    // 获取当前节点的下一个节点  
    Node s = node.next;  
    // 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点  
    if (s == null || s.waitStatus &gt; 0) &#123;  
        s = null;  
        // 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。  
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)  
            if (t.waitStatus &lt;= 0)  
                s = t;  
    &#125;  
    // 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark  
    if (s != null)  
        LockSupport.unpark(s.thread);  
&#125;  
  
</code></pre>
<p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p>
<p>之前的addWaiter方法：</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
private Node addWaiter(Node mode) &#123;  
    Node node = new Node(Thread.currentThread(), mode);  
    // Try the fast path of enq; backup to full enq on failure  
    Node pred = tail;  
    if (pred != null) &#123;  
        node.prev = pred;  
        if (compareAndSetTail(pred, node)) &#123;  
            pred.next = node;  
            return node;  
        &#125;  
    &#125;  
    enq(node);  
    return node;  
&#125;  
  
</code></pre>
<p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev &#x3D; pred; compareAndSetTail(pred, node)<br>这两个地方可以看作Tail入队的原子操作，但是此时pred.next &#x3D;<br>node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>
<p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p>
<h3 id="中断恢复后的执行流程"><a href="#中断恢复后的执行流程" class="headerlink" title="中断恢复后的执行流程"></a>中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
private final boolean parkAndCheckInterrupt() &#123;  
    LockSupport.park(this);  
    return Thread.interrupted();  
&#125;  
</code></pre>
<p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
final boolean acquireQueued(final Node node, int arg) &#123;  
    boolean failed = true;  
    try &#123;  
        boolean interrupted = false;  
        for (;;) &#123;  
            final Node p = node.predecessor();  
            if (p == head &amp;&amp; tryAcquire(arg)) &#123;  
                setHead(node);  
                p.next = null; // help GC  
                failed = false;  
                return interrupted;  
            &#125;  
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())  
                interrupted = true;  
            &#125;  
    &#125; finally &#123;  
        if (failed)  
            cancelAcquire(node);  
    &#125;  
&#125;  
  
</code></pre>
<p>如果acquireQueued为True，就会执行selfInterrupt方法。</p>
<pre><code>// java.util.concurrent.locks.AbstractQueuedSynchronizer  
  
static void selfInterrupt() &#123;  
    Thread.currentThread().interrupt();  
&#125;  
  
</code></pre>
<p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p>
<ol>
<li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li>
<li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li>
</ol>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到<br>JDK1.5，java.util.concurrent.atomic 包提供了 int 和long<br>类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p>
<p>java.util.concurrent<br>这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由<br>JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。</p>
<p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</p>
<p>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p>
<p>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p>
<p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个<br>boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）</p>
<h2 id="AtomicInteger举例"><a href="#AtomicInteger举例" class="headerlink" title="AtomicInteger举例"></a>AtomicInteger举例</h2><pre><code>public class AtomicInteger extends Number implements java.io.Serializable &#123;  
    
    private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();  
    private static final long VALUE;  
  
    private volatile int value;//注意该值用volatile修饰  
  
    public AtomicInteger(int initialValue) &#123;  
        value = initialValue;  
    &#125;  
    //以原子的方式将输入的值与ActomicInteger中的值进行相加，  
    //注意：返回相加前ActomicInteger中的值  
    public final int getAndAdd(int delta) &#123;  
        return U.getAndAddInt(this, VALUE, delta);  
    &#125;  
    //以原子的方式将输入的值与ActomicInteger中的值进行相加，  
    //注意：返回相加后的结果  
    public final int addAndGet(int delta) &#123;  
        return U.getAndAddInt(this, VALUE, delta) + delta;  
    &#125;  
    //以原子方式将当前ActomicInteger中的值加1,  
    //注意：返回相加前ActomicInteger中的值  
    public final int getAndIncrement() &#123;  
        return U.getAndAddInt(this, VALUE, 1);  
    &#125;  
    //以原子方式将当前ActomicInteger中的值加1,  
    //注意：返回相加后的结果  
    public final int incrementAndGet() &#123;  
        return U.getAndAddInt(this, VALUE, 1) + 1;  
    &#125;  
  
    //省略部分代码...  
  &#125;  
  
</code></pre>
<p>AtomicInteger内部会调用其中sun.misc.Unsafe方法中getAndAddInt的方法。具体代码如下：</p>
<pre><code>public final int getAndAdd(int delta) &#123;  
       return U.getAndAddInt(this, VALUE, delta);  
   &#125;  
  
</code></pre>
<p>而sun.misc.Unsafe方法中getAndAddInt方法又会调用jdk.internal.misc.Unsafe的getAndAddInt，具体代码如下：</p>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) &#123;  
       return theInternalUnsafe.getAndAddInt(o, offset, delta);  
   &#125;  
</code></pre>
<p>jdk.internal.misc.Unsafe的getAndAddInt（）方法的声明如下：</p>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) &#123;  
        int v;  
        do &#123;  
            v = getIntVolatile(o, offset);//先获取内存中存储的值  
        &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));//如果不是期望的结果值，就一直循环  
        return v;  
    &#125;  
      
//该函数返回值代表CAS操作是否成功      
public final boolean weakCompareAndSetInt(Object o, long offset,  
                                          int expected,  
                                          int x) &#123;  
     return compareAndSetInt(o, offset, expected, x);//执行CAS操作  
    &#125;  
  
</code></pre>
<p>从上述代码中我们可以得出，会先获取内存中存储的值，最终会调用compareAndSetInt（）方法来完成最终的原子操作。其中compareAndSetInt（）方法的返回值代表着该次CAS操作是否成功。如果不成功。那么会一直循环。直到成功为止（也就是循环CAS操作）。</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch顾名思义，count + down + latch ＝ 计数 ＋ 减 ＋ 门闩。<br>可以理解这个东西就是个计数器，只能减不能加，同时它还有个门闩的作用，当计数器不为0时，门闩是锁着的；当计数器减到0时，门闩就打开了。</p>
<h2 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>下面是实现的源码，非常简短，主要是创建了一个Sync对象。</p>
<pre><code>public CountDownLatch(int count) &#123;  
        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);  
        this.sync = new Sync(count);  
&#125;  
</code></pre>
<h3 id="Sync对象"><a href="#Sync对象" class="headerlink" title="Sync对象"></a>Sync对象</h3><pre><code>private static final class Sync extends AbstractQueuedSynchronizer &#123;  
        private static final long serialVersionUID = 4982264981922014374L;  
   
        Sync(int count) &#123;  
            setState(count);  
        &#125;  
   
        int getCount() &#123;  
            return getState();  
        &#125;  
   
        protected int tryAcquireShared(int acquires) &#123;  
            return (getState() == 0) ? 1 : -1;  
        &#125;  
   
        protected boolean tryReleaseShared(int releases) &#123;  
            // Decrement count; signal when transition to zero  
            for (;;) &#123;  
                int c = getState();  
                if (c == 0)  
                    return false;  
                int nextc = c-1;  
                if (compareAndSetState(c, nextc))  
                    return nextc == 0;  
            &#125;  
        &#125;  
    &#125;  
</code></pre>
<p>假设我们是这样创建的：new CountDownLatch(5)。其实也就相当于new<br>Sync(5)，相当于setState(5)。setState其实就是共享锁资源总数,我们可以暂时理解为设置一个计数器，当前计数器初始值为5。</p>
<p>tryAcquireShared方法其实就是判断一下当前计数器的值，是否为0了，如果为0的话返回1（<br><strong>返回1的时候，就表示获取锁成功,awit()方法就不再阻塞</strong> ）。</p>
<p>tryReleaseShared方法就是利用CAS的方式，对计数器进行减一的操作，而我们实际上每次调用countDownLatch.countDown()方法的时候，最终都会调到这个方法，对计数器进行减一操作，一直减到0为止。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><pre><code>public void await() throws InterruptedException &#123;      
    sync.acquireSharedInterruptibly(1);      
&#125;  
</code></pre>
<p>代码很简单，就一句话（注意acquireSharedInterruptibly（）方法是抽象类：AbstractQueuedSynchronizer的一个方法，我们上面提到的Sync继承了它），我们跟踪源码，继续往下看：</p>
<h3 id="acquireSharedInterruptibly-int-arg"><a href="#acquireSharedInterruptibly-int-arg" class="headerlink" title="acquireSharedInterruptibly(int arg)"></a>acquireSharedInterruptibly(int arg)</h3><pre><code>public final void acquireSharedInterruptibly(int arg)  
           throws InterruptedException &#123;  
       if (Thread.interrupted())  
           throw new InterruptedException();  
       if (tryAcquireShared(arg) &lt; 0)  
           doAcquireSharedInterruptibly(arg);  
   &#125;  
  
</code></pre>
<p>源码也是非常简单的，首先判断了一下，当前线程是否有被中断，如果没有的话，就调用tryAcquireShared(int<br>acquires)方法，判断一下当前线程是否还需要“阻塞”。其实这里调用的tryAcquireShared方法，就是我们上面提到的java.util.concurrent.CountDownLatch.Sync.tryAcquireShared(int)这个方法。<br>当然，在一开始我们没有调用过countDownLatch.countDown()方法时，这里tryAcquireShared方法肯定是会返回-1的，因为会进入到doAcquireSharedInterruptibly方法。</p>
<pre><code>private void doAcquireSharedInterruptibly(int arg)  
    throws InterruptedException &#123;  
    final Node node = addWaiter(Node.SHARED);  
    boolean failed = true;  
    try &#123;  
        for (;;) &#123;  
            final Node p = node.predecessor();  
            if (p == head) &#123;  
                int r = tryAcquireShared(arg);  
                if (r &gt;= 0) &#123;  
                    setHeadAndPropagate(node, r);  
                    p.next = null; // help GC  
                    failed = false;  
                    return;  
                &#125;  
            &#125;  
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  
                parkAndCheckInterrupt())  
                throw new InterruptedException();  
        &#125;  
    &#125; finally &#123;  
        if (failed)  
            cancelAcquire(node);  
    &#125;  
&#125;  
  
</code></pre>
<h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown()方法"></a>countDown()方法</h3><pre><code>// 计数器减1  
public void countDown() &#123;  
    sync.releaseShared(1);   
&#125;  
  
//调用AQS的releaseShared方法  
public final boolean releaseShared(int arg) &#123;  
    if (tryReleaseShared(arg)) &#123;//计数器减一  
        doReleaseShared();//唤醒后继结点,这个时候队列中可能只有调用过await()的线程节点,也可能队列为空,一般为主线程  
        return true;  
    &#125;  
    return false;  
&#125;  
  
//自定义同步器实现的方法  
protected boolean tryReleaseShared(int releases) &#123;  
    // Decrement count; signal when transition to zero  
    for (;;) &#123;  
        int c = getState();  
        if (c == 0)  
            return false;  //重复调用的时候返回false结束上层方法  
        int nextc = c-1;  
        if (compareAndSetState(c, nextc))  
            return nextc == 0;  //调用countDown的线程不把资源释放到0,改方法一直返回 false   
    &#125;  
&#125;  
  
</code></pre>
<p>这个时候，我们应该对于countDownLatch.await()方法是怎么“阻塞”当前线程的，已经非常明白了。其实说白了，就是当你调用了countDownLatch.await()方法后，你当前线程就会进入了一个死循环当中，在这个死循环里面，会不断的进行判断，通过调用tryAcquireShared方法，不断判断我们上面说的那个计数器，看看它的值是否为0了（为0的时候，其实就是我们调用了足够多<br>countDownLatch.countDown()方法的时候），如果是为0的话，tryAcquireShared就会返回1，代码也会进入到if (r &gt;&#x3D;<br>0)部分，然后跳出了循环，也就不再“阻塞”当前线程了。需要注意的是，说是在不停的循环，其实也并非在不停的执行for循环里面的内容，因为在后面调用parkAndCheckInterrupt（）方法时，在这个方法里面是会调用<br>LockSupport.park(this);来挂起当前线程。</p>
<h3 id="CountDownLatch-使用的注意点："><a href="#CountDownLatch-使用的注意点：" class="headerlink" title="CountDownLatch 使用的注意点："></a>CountDownLatch 使用的注意点：</h3><ol>
<li>只有当count为0时， <strong>await之后的程序才够执行</strong> 。</li>
<li><strong>countDown必须写在finally中，防止发生异程常时，导致程序死锁。</strong></li>
</ol>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><pre><code>public class Test &#123;  
    public static void main(String[] args) &#123;  
        final CountDownLatch latch = new CountDownLatch(2);  
        new Thread() &#123;  
            public void run() &#123;  
                try &#123;  
                    System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行&quot;);  
                    Thread.sleep(3000);  
                    System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);  
                &#125; catch (InterruptedException e) &#123;  
                    e.printStackTrace();  
                &#125; finally &#123;  
                    latch.countDown();  
                &#125;  
            &#125;;  
        &#125;.start();  
  
        new Thread() &#123;  
            public void run() &#123;  
                try &#123;  
                    System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行&quot;);  
                    Thread.sleep(3000);  
                    System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);  
                    latch.countDown();  
                &#125; catch (InterruptedException e) &#123;  
                    e.printStackTrace();  
                &#125; finally &#123;  
                    latch.countDown();  
                &#125;  
            &#125;;  
        &#125;.start();  
        try &#123;  
            System.out.println(&quot;等待2个子线程执行完毕...&quot;);  
            latch.await();  
            System.out.println(&quot;2个子线程已经执行完毕&quot;);  
            System.out.println(&quot;继续执行主线程&quot;);  
        &#125; catch (InterruptedException e) &#123;              
            e.printStackTrace();          
            &#125;     
    &#125;  
&#125;  
  
</code></pre>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该<br>barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
<p>注意比较CountDownLatch和CyclicBarrier：</p>
<ol>
<li><p>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。</p>
</li>
<li><p>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p>
</li>
</ol>
<h2 id="CyclicBarrier函数列表"><a href="#CyclicBarrier函数列表" class="headerlink" title="CyclicBarrier函数列表"></a><strong>CyclicBarrier函数列表</strong></h2><pre><code>CyclicBarrier(int parties)  
创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。  
CyclicBarrier(int parties, Runnable barrierAction)  
创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。  
  
int await()  
在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。  
int await(long timeout, TimeUnit unit)  
在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。  
int getNumberWaiting()  
返回当前在屏障处等待参与者数目。  
int getParties()  
返回要求启动此 barrier 的参与者数目。  
boolean isBroken()  
查询此屏障是否处于损坏状态。  
void reset()  
将屏障重置为其初始状态。  
</code></pre>
<h2 id="CyclicBarrier数据结构"><a href="#CyclicBarrier数据结构" class="headerlink" title="CyclicBarrier数据结构"></a>CyclicBarrier数据结构</h2><p>CyclicBarrier的UML类图如下：</p>
<p><img src="/images/CyclicBarrier%E7%9A%84UML%E7%B1%BB%E5%9B%BE.jpg" alt="CyclicBarrier的UML类图"></p>
<p>CyclicBarrier是包含了”<a target="_blank" rel="noopener" href="http://www.cnblogs.com/skywang12345/p/3496147.html">ReentrantLock</a>对象lock”和”<a target="_blank" rel="noopener" href="http://www.cnblogs.com/skywang12345/p/3496716.html">Condition</a>对象trip”，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。</p>
<h2 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>CyclicBarrier的构造函数共2个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable<br>barrierAction)。第1个构造函数是调用第2个构造函数来实现的，下面第2个构造函数的源码。</p>
<pre><code>public CyclicBarrier(int parties, Runnable barrierAction) &#123;  
    if (parties &lt;= 0) throw new IllegalArgumentException();  
    // parties表示“必须同时到达barrier的线程个数”。  
    this.parties = parties;  
    // count表示“处在等待状态的线程个数”。  
    this.count = parties;  
    // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。  
    this.barrierCommand = barrierAction;  
&#125;  
  
</code></pre>
<h3 id="await-1"><a href="#await-1" class="headerlink" title="await()"></a>await()</h3><pre><code>public int await() throws InterruptedException, BrokenBarrierException &#123;  
    try &#123;  
        return dowait(false, 0L);  
    &#125; catch (TimeoutException toe) &#123;  
        throw new Error(toe); // cannot happen;  
    &#125;  
&#125;  
</code></pre>
<p><strong>说明</strong> ：await()是通过dowait()实现的。</p>
<pre><code>private int dowait(boolean timed, long nanos)  
    throws InterruptedException, BrokenBarrierException,  
           TimeoutException &#123;  
    final ReentrantLock lock = this.lock;  
    // 获取“独占锁(lock)”  
    lock.lock();  
    try &#123;  
        // 保存“当前的generation”  
        final Generation g = generation;  
  
        // 若“当前generation已损坏”，则抛出异常。  
        if (g.broken)  
            throw new BrokenBarrierException();  
  
        // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。  
        if (Thread.interrupted()) &#123;  
            breakBarrier();  
            throw new InterruptedException();  
        &#125;  
  
       // 将“count计数器”-1  
       int index = --count;  
       // 如果index=0，则意味着“有parties个线程到达barrier”。  
       if (index == 0) &#123;  // tripped  
           boolean ranAction = false;  
           try &#123;  
               // 如果barrierCommand不为null，则执行该动作。  
               final Runnable command = barrierCommand;  
               if (command != null)  
                   command.run();  
               ranAction = true;  
               // 唤醒所有等待线程，并更新generation。  
               nextGeneration();  
               return 0;    //这里等价于return index;  
           &#125; finally &#123;  
               if (!ranAction)  
                   breakBarrier();  
           &#125;  
       &#125;  
  
        // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，  
        // 当前线程才继续执行。  
        for (;;) &#123;  
            try &#123;  
                // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。  
                if (!timed)  
                    trip.await();  
                else if (nanos &gt; 0L)  
                    nanos = trip.awaitNanos(nanos);  
            &#125; catch (InterruptedException ie) &#123;  
                // 如果等待过程中，线程被中断，则执行下面的函数。  
                if (g == generation &amp;&amp; ! g.broken) &#123;  
                    breakBarrier();  
                    throw ie;  
                &#125; else &#123;  
                    Thread.currentThread().interrupt();  
                &#125;  
            &#125;  
  
            // 如果“当前generation已经损坏”，则抛出异常。  
            if (g.broken)  
                throw new BrokenBarrierException();  
  
            // 如果“generation已经换代”，则返回index。  
            if (g != generation)  
                return index;  
  
            // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。  
            if (timed &amp;&amp; nanos &lt;= 0L) &#123;  
                breakBarrier();  
                throw new TimeoutException();  
            &#125;  
        &#125;  
    &#125; finally &#123;  
        // 释放“独占锁(lock)”  
        lock.unlock();  
    &#125;  
&#125;  
</code></pre>
<p><strong>说明</strong> ：dowait()的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或<br>“超时”这3者之一发生，当前线程才继续执行。<br>(01) generation是CyclicBarrier的一个成员变量，它的定义如下：</p>
<pre><code>private Generation generation = new Generation();  
  
private static class Generation &#123;  
    boolean broken = false;  
&#125;  
</code></pre>
<p>在CyclicBarrier中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier中通过generation对象，记录属于哪一代。<br>当有parties个线程到达barrier，generation就会被更新换代。</p>
<p>(02)<br>如果当前线程被中断，即Thread.interrupted()为true；则通过breakBarrier()终止CyclicBarrier。breakBarrier()的源码如下：</p>
<pre><code>private void breakBarrier() &#123;  
    generation.broken = true;  
    count = parties;  
    trip.signalAll();  
&#125;  
  
</code></pre>
<p>breakBarrier()会设置当前中断标记broken为true，意味着“将该Generation中断”；同时，设置count&#x3D;parties，即重新初始化count；最后，通过signalAll()唤醒CyclicBarrier上所有的等待线程。</p>
<p>(03) 将“count计数器”-1，即–count；然后判断是不是“有parties个线程到达barrier”，即index是不是为0。<br>当index&#x3D;0时，如果barrierCommand不为null，则执行该barrierCommand，barrierCommand就是我们创建CyclicBarrier时，传入的Runnable对象。然后，调用nextGeneration()进行换代工作，nextGeneration()的源码如下：</p>
<pre><code>private void nextGeneration() &#123;  
    trip.signalAll();  
    count = parties;  
    generation = new Generation();  
&#125;  
</code></pre>
<p>首先，它会调用signalAll()唤醒CyclicBarrier上所有的等待线程；接着，重新初始化count；最后，更新generation的值。</p>
<p>(04)<br>在for(;;)循环中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。</p>
<h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><pre><code>import java.util.concurrent.CyclicBarrier;  
import java.util.concurrent.BrokenBarrierException;  
  
public class CyclicBarrierTest1 &#123;  
  
    private static int SIZE = 5;  
    private static CyclicBarrier cb;  
    public static void main(String[] args) &#123;  
  
        cb = new CyclicBarrier(SIZE);  
  
        // 新建5个任务  
        for(int i=0; i&lt;SIZE; i++)  
            new InnerThread().start();  
    &#125;  
  
    static class InnerThread extends Thread&#123;  
        public void run() &#123;  
            try &#123;  
                System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;);  
  
                // 将cb的参与者数量加1  
                cb.await();  
  
                // cb的参与者数量等于5时，才继续往后执行  
                System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;);  
            &#125; catch (BrokenBarrierException e) &#123;  
                e.printStackTrace();  
            &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
            &#125;  
        &#125;  
    &#125;  
&#125;  
运行结果：  
Thread-1 wait for CyclicBarrier.  
Thread-2 wait for CyclicBarrier.  
Thread-3 wait for CyclicBarrier.  
Thread-4 wait for CyclicBarrier.  
Thread-0 wait for CyclicBarrier.  
Thread-0 continued.  
Thread-4 continued.  
Thread-2 continued.  
Thread-3 continued.  
Thread-1 continued.  
  

import java.util.concurrent.CyclicBarrier;  
import java.util.concurrent.BrokenBarrierException;  
  
public class CyclicBarrierTest2 &#123;  
  
    private static int SIZE = 5;  
    private static CyclicBarrier cb;  
    public static void main(String[] args) &#123;  
  
        cb = new CyclicBarrier(SIZE, new Runnable () &#123;  
            public void run() &#123;  
                System.out.println(&quot;CyclicBarrier&#39;s parties is: &quot;+ cb.getParties());  
            &#125;  
        &#125;);  
  
        // 新建5个任务  
        for(int i=0; i&lt;SIZE; i++)  
            new InnerThread().start();  
    &#125;  
  
    static class InnerThread extends Thread&#123;  
        public void run() &#123;  
            try &#123;  
                System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;);  
  
                // 将cb的参与者数量加1  
                cb.await();  
  
                // cb的参与者数量等于5时，才继续往后执行  
                System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;);  
            &#125; catch (BrokenBarrierException e) &#123;  
                e.printStackTrace();  
            &#125; catch (InterruptedException e) &#123;  
                e.printStackTrace();  
            &#125;  
        &#125;  
    &#125;  
&#125;  
运行结果：  
  
Thread-1 wait for CyclicBarrier.  
Thread-2 wait for CyclicBarrier.  
Thread-3 wait for CyclicBarrier.  
Thread-4 wait for CyclicBarrier.  
Thread-0 wait for CyclicBarrier.  
CyclicBarrier&#39;s parties is: 5  
Thread-0 continued.  
Thread-4 continued.  
Thread-2 continued.  
Thread-3 continued.  
Thread-1 continued.  
</code></pre>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>我们以一个停车场运作为例来说明信号量的作用。假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了三辆车，看门人允许其中它们进入，然后放下车拦。以后来的车必须在入口等待，直到停车场中有车辆离开。这时，如果有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开一辆，则又可以放入一辆，如此往复。</p>
<p>在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。信号量是一个非负整数，表示了当前公共资源的可用数目（在上面的例子中可以用空闲的停车位类比信号量），当一个线程要使用公共资源时（在上面的例子中可以用车辆类比线程），首先要查看信号量，如果信号量的值大于1，则将其减1，然后去占有公共资源。如果信号量的值为0，则线程会将自己阻塞，直到有其它线程释放公共资源</p>
<p>在信号量上我们定义两种操作： acquire（获取） 和<br>release（释放）。当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</p>
<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>在Java的并发包中，Semaphore类表示信号量。Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。Semaphore有两个构造函数，<br><strong>参数permits表示许可数</strong> ，它最后传递给了AQS的state值。线程在运行时首先获取许可， <strong>如果成功，许可数就减1</strong><br>，线程运行，当线程运行结束就释放许可， <strong>许可数就加1</strong><br>。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>//非公平的构造函数  
public Semaphore(int permits) &#123;  
    sync = new NonfairSync(permits);  
&#125;  
  
//通过fair参数决定公平性  
public Semaphore(int permits, boolean fair) &#123;  
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);  
&#125;   
  
</code></pre>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h3><pre><code>public void acquire() throws InterruptedException &#123;  
    sync.acquireSharedInterruptibly(1);  
&#125;  
  
public final void acquireSharedInterruptibly(int arg)  
        throws InterruptedException &#123;  
    if (Thread.interrupted())  
        throw new InterruptedException();  
    if (tryAcquireShared(arg) &lt; 0)  
        doAcquireSharedInterruptibly(arg);  
&#125;  
</code></pre>
<ul>
<li>调用tryAcquireShared()方法尝试获取信号。</li>
<li>如果没有可用信号，将当前线程加入等待队列并挂起</li>
</ul>
<p>tryAcquireShared<br>会调用对应公平或者非公平同步器的方法,xxTAcquireShared下面是非公平的,公平的方法就多了一个hasQueuedPredecessors方法的逻辑</p>
<h3 id="NonfairSync-tryAcquireShared"><a href="#NonfairSync-tryAcquireShared" class="headerlink" title="NonfairSync.tryAcquireShared()"></a>NonfairSync.tryAcquireShared()</h3><pre><code>final int nonfairTryAcquireShared(int acquires) &#123;  
    for (;;) &#123;  
        int available = getState();  
        int remaining = available - acquires; //剩余许可数  
        if (remaining &lt; 0 ||  
            compareAndSetState(available, remaining))   
            return remaining;  
    &#125;  
&#125;  
</code></pre>
<p>可以看出，如果remaining &lt;0<br>即获取许可后，许可数小于0，则获取失败，在doAcquireSharedInterruptibly方法中线程会将自身阻塞，然后入列。可以看到，非公平锁对于信号的获取是直接使用CAS进行尝试的。</p>
<h3 id="FairSync-tryAcquireShared"><a href="#FairSync-tryAcquireShared" class="headerlink" title="FairSync.tryAcquireShared()"></a>FairSync.tryAcquireShared()</h3><pre><code>protected int tryAcquireShared(int acquires) &#123;  
            for (;;) &#123;  
                if (hasQueuedPredecessors())  
                    return -1;  
                int available = getState();  
                int remaining = available - acquires;  
                if (remaining &lt; 0 ||  
                    compareAndSetState(available, remaining))  
                    return remaining;  
            &#125;  
        &#125;  
  
</code></pre>
<ul>
<li><p>先调用hasQueuedPredecessors()方法，判断队列中是否有等待线程。如果有，直接返回-1，表示没有可用信号</p>
</li>
<li><p>队列中没有等待线程，再使用CAS尝试更新state，获取信号</p>
</li>
</ul>
<h3 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly()"></a>doAcquireSharedInterruptibly()</h3><pre><code>private void doAcquireSharedInterruptibly(int arg)  
        throws InterruptedException &#123;  
        final Node node = addWaiter(Node.SHARED);   // 1  
        boolean failed = true;  
        try &#123;  
            for (;;) &#123;  
                final Node p = node.predecessor();     
                if (p == head) &#123;      // 2  
                    int r = tryAcquireShared(arg);  
                    if (r &gt;= 0) &#123;  
                        setHeadAndPropagate(node, r);  
                        p.next = null; // help GC  
                        failed = false;  
                        return;  
                    &#125;  
                &#125;  
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;     // 3  
                    parkAndCheckInterrupt())  
                    throw new InterruptedException();  
            &#125;  
        &#125; finally &#123;  
            if (failed)  
                cancelAcquire(node);     
        &#125;  
    &#125;  
  
</code></pre>
<ol>
<li>封装一个Node节点，加入队列尾部</li>
<li>在无限循环中，如果当前节点是头节点，就尝试获取信号</li>
<li>不是头节点，在经过节点状态判断后，挂起当前线程</li>
</ol>
<h3 id="release-释放信号"><a href="#release-释放信号" class="headerlink" title="release()释放信号"></a><strong>release()释放信号</strong></h3><pre><code>public final boolean releaseShared(int arg) &#123;  
        if (tryReleaseShared(arg)) &#123;    // 1  
            doReleaseShared();  // 2  
            return true;  
        &#125;  
        return false;  
    &#125;  
</code></pre>
<ol>
<li>cas更新state加一</li>
<li>唤醒等待队列头节点线程</li>
</ol>
<h2 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre><code>public static void main(String[] args) &#123;  
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10,  
                0L, TimeUnit.MILLISECONDS,  
                new LinkedBlockingQueue&lt;Runnable&gt;(10));  
        //信号总数为5  
        Semaphore semaphore = new Semaphore(5);  
        //运行10个线程  
        for (int i = 0; i &lt; 10; i++) &#123;  
            threadPool.execute(new Runnable() &#123;  
                  
                @Override  
                public void run() &#123;  
                    try &#123;  
                        //获取信号  
                        semaphore.acquire();     
                        System.out.println(Thread.currentThread().getName() + &quot;获得了信号量,时间为&quot; + System.currentTimeMillis());  
                        //阻塞2秒，测试效果  
                        Thread.sleep(2000);  
                        System.out.println(Thread.currentThread().getName() + &quot;释放了信号量,时间为&quot; + System.currentTimeMillis());  
                    &#125; catch (InterruptedException e) &#123;  
                        e.printStackTrace();  
                    &#125; finally &#123;  
                        //释放信号  
                        semaphore.release();  
                    &#125;  
                  
                &#125;  
            &#125;);  
        &#125;  
        threadPool.shutdown();  
    &#125;  
  
pool-1-thread-2获得了信号量,时间为1550584196125  
pool-1-thread-1获得了信号量,时间为1550584196125  
pool-1-thread-3获得了信号量,时间为1550584196125  
pool-1-thread-4获得了信号量,时间为1550584196126  
pool-1-thread-5获得了信号量,时间为1550584196127  
pool-1-thread-2释放了信号量,时间为1550584198126  
pool-1-thread-3释放了信号量,时间为1550584198126  
pool-1-thread-4释放了信号量,时间为1550584198126  
pool-1-thread-6获得了信号量,时间为1550584198126  
pool-1-thread-9获得了信号量,时间为1550584198126  
pool-1-thread-8获得了信号量,时间为1550584198126  
pool-1-thread-1释放了信号量,时间为1550584198126  
pool-1-thread-10获得了信号量,时间为1550584198126  
pool-1-thread-5释放了信号量,时间为1550584198127  
pool-1-thread-7获得了信号量,时间为1550584198127  
pool-1-thread-6释放了信号量,时间为1550584200126  
pool-1-thread-8释放了信号量,时间为1550584200126  
pool-1-thread-10释放了信号量,时间为1550584200126  
pool-1-thread-9释放了信号量,时间为1550584200126  
pool-1-thread-7释放了信号量,时间为1550584200127  
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/21/jvm/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/21/jvm/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程与多进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-03-21 22:30:00" itemprop="dateCreated datePublished" datetime="2020-03-21T22:30:00+00:00">2020-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p>
<p>在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br><strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
<ol>
<li><strong>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</strong></li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。 <strong>但是线程不能够独立执行，</strong> 必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。 <strong>这就是进程和线程的重要区别。</strong></li>
</ol>
<h1 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h1><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>多进程</strong></th>
<th><strong>多线程</strong></th>
<th><strong>总结</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<p>使用进程和线程一般根据以上的不同情况进行不同的选择，一般以业务逻辑划分进程，内部再细分线程</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="进程间通信的目的"><a href="#进程间通信的目的" class="headerlink" title="进程间通信的目的"></a>进程间通信的目的</h2><ul>
<li><p><strong>数据传输</strong><br>一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M字节之间</p>
</li>
<li><p><strong>共享数据</strong><br>多个进程想要操作共享数据，一个进程对共享数据</p>
</li>
<li><p><strong>通知事</strong><br>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p>
</li>
<li><p><strong>资源共享</strong><br>多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p>
</li>
<li><p><strong>进程控制</strong><br>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</li>
</ul>
<h2 id="linux进程间通信的方式"><a href="#linux进程间通信的方式" class="headerlink" title="linux进程间通信的方式"></a>linux进程间通信的方式</h2><h3 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h3><ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li>
<li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li>
<li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>
</ul>
<p><img src="/images/%E7%AE%A1%E9%81%93.png" alt="管道"></p>
<p>常见的Linux命令 “|” 其实就是匿名管道，表示把一个进程的输出传输到另外一个进程，如：</p>
<pre><code>echo &quot;Happyjava&quot; | awk -F &#39;j&#39; &#39;&#123;print $2&#125;&#39;  
# 输出 ava  
  
</code></pre>
<p>—|—  </p>
<p><strong>管道的实质：</strong></p>
<ul>
<li>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</li>
<li>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</li>
<li>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
</ul>
<p><strong>管道的局限：</strong><br>管道的主要局限性正体现在它的特点上：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h3 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联， <strong>以有名管道的文件形式存在于文件系统中</strong> ，这样，<br><strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong><br>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循 <strong>先进先出(first in first out)</strong><br>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<br><strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p>
<p><strong>匿名管道和有名管道总结：</strong><br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br>（3） <strong>无名管道阻塞问题：</strong><br>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br>（4） <strong>有名管道阻塞问题：</strong><br>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p>
<h3 id="信号（-Signal-）"><a href="#信号（-Signal-）" class="headerlink" title="信号（ Signal ）"></a>信号（ <strong>Signal</strong> ）</h3><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<p><strong>信号来源</strong></p>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li>
<li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li>
</ul>
<p><strong>信号生命周期和处理流程</strong></p>
<ol>
<li><p>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</p>
</li>
<li><p>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</p>
</li>
<li><p>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
</li>
</ol>
<h3 id="消息队列（-Message-）"><a href="#消息队列（-Message-）" class="headerlink" title="消息队列（ Message ）"></a>消息队列（ <strong>Message</strong> ）</h3><p>注意，此消息队列不是我们常用的MQ，如kafka，rabbitmq，rocketmq等。</p>
<ul>
<li>消息队列是存放在内存中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</li>
</ul>
<p><strong>消息队列特点总结：</strong></p>
<ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息.</li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
<h3 id="共享内存-（share-memory）"><a href="#共享内存-（share-memory）" class="headerlink" title="共享内存 （share memory）"></a>共享内存 <strong>（share memory）</strong></h3><ul>
<li>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<p><img src="/images/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" alt="共享内存"></p>
<h3 id="信号量（-semaphore-）"><a href="#信号量（-semaphore-）" class="headerlink" title="信号量（ semaphore ）"></a>信号量（ <strong>semaphore</strong> ）</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br>为了获得共享资源，进程需要执行下列操作：<br>（1） <strong>创建一个信号量</strong> ：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br>（2） <strong>等待一个信号量</strong> ：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br>（3） <strong>挂出一个信号量</strong> ：该操作将信号量的值加1，也称为V操作。</p>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<br><strong>Posix（<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa">可移植性操作系统接口</a>）有名信号量（使用Posix<br>IPC名字标识）</strong>、 <strong>Posix基于内存的信号量（存放在共享内存区中）</strong> 、 <strong>System V信号量（在内核中维护）</strong><br>。这三种信号量都可用于进程间或线程间的同步。</p>
<p><img src="/images/%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="两个进程使用一个二值信号量"></p>
<p><img src="/images/%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E4%BB%A5%E7%94%A8%E4%B8%80%E4%B8%AAPosix%E6%9C%89%E5%90%8D%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="两个进程所以用一个Posix有名二值信号量"></p>
<p><img src="/images/%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt="一个进程两个线程共享基于内存的信号量"></p>
<p><strong>信号量与普通整型变量的区别：</strong></p>
<ol>
<li>信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；</li>
<li>操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</li>
</ol>
<p><strong>信号量与互斥量之间的区别：</strong></p>
<ol>
<li>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li>
</ol>
<p><strong>互斥：</strong> 是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br><strong>同步：</strong> 是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<ol start="2">
<li><p>互斥量值只能为0&#x2F;1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</p>
</li>
<li><p>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
</li>
</ol>
<h3 id="套接字（-socket-）"><a href="#套接字（-socket-）" class="headerlink" title="套接字（ socket ）"></a>套接字（ <strong>socket</strong> ）</h3><p>套接字是一种通信机制，凭借这种机制，客户&#x2F;服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p>套接字是支持TCP&#x2F;IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<p><strong>套接字特性</strong><br>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<ol>
<li><p>套接字的域**<br>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br><strong>一是AF_INET，它指的是Internet网络。</strong><br>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br><strong>另一个域AF_UNIX，表示UNIX文件系统，</strong> 它就是文件输入&#x2F;输出，而它的地址就是文件名。</p>
</li>
<li><p>套接字的端口号<br>每一个基于TCP&#x2F;IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入&#x2F;输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。</p>
</li>
<li><p>套接字协议类型<br>因特网提供三种通信机制，<br><strong>一是流套接字，</strong><br>流套接字在域中通过TCP&#x2F;IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br><strong>二个是数据报套接字，</strong><br>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP&#x2F;IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br><strong>三是原始套接字，</strong> 原始套接字允许对较低层次的协议直接访问，比如IP、<br>ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW<br>SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW<br>SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP&#x2F;IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p>
</li>
</ol>
<blockquote>
<p><strong>原始套接字与标准套接字的区别在于：</strong>  </p>
<p>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
</blockquote>
<p><strong>服务器端</strong></p>
<ol>
<li><p>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</p>
</li>
<li><p>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</p>
</li>
<li><p>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</p>
</li>
<li><p>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p>
</li>
</ol>
<p><strong>客户端</strong></p>
<ol>
<li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li>
<li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>各种通信方式的比较和优缺点</p>
<ol>
<li>管道：速度慢，容量有限，只有父子进程能通讯</li>
<li>FIFO：任何进程间都能通讯，但速度慢</li>
<li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</li>
<li>信号量：不能传递复杂消息，只能用来同步</li>
<li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。</p>
<h2 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h2><p>如果在计算机系统中同时具备下面四个必要条件时，那麽会发生死锁。换句话说，只要下面四个条件有一个不具备，系统就不会出现死锁。</p>
<ol>
<li><p>互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p>
</li>
<li><p>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p>
</li>
<li><p>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p>
</li>
<li><p>循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p>
</li>
</ol>
<p>上面我们提到的这四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。</p>
<h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><p>前面介绍了死锁发生时的四个必要条件，只要破坏这四个必要条件中的任意一个条件，死锁就不会发生。这就为我们解决死锁问题提供了可能。一般地，解决死锁的方法分为死锁的预防，避免，检测与恢复三种（注意：死锁的检测与恢复是一个方法）。我们将在下面分别加以介绍。</p>
<p>死锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</p>
<ol>
<li>打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</li>
<li>打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。 </li>
<li>打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。但是，这种策略也有如下缺点：</li>
</ol>
<ul>
<li>在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源。这是由于进程在执行时是动态的，不可预测的；</li>
<li>资源利用率低。无论所分资源何时用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被该进程用到一次，但该进程在生存期间却一直占有它们，造成长期占着不用的状况。这显然是一种极大的资源浪费；</li>
<li>降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数就必然少了。</li>
</ul>
<ol start="4">
<li>打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高，但是也存在以下缺点：</li>
</ol>
<ul>
<li>限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销；</li>
<li>为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。</li>
</ul>
<h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>上面我们讲到的死锁预防是排除死锁的静态策略，它使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。下面我们介绍排除死锁的动态策略–死锁的避免，它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性。</p>
<ol>
<li>安全序列</li>
</ol>
<p>我们首先引入安全序列的定义：所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1，P2，…，Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。</p>
<p>安全序列{P1，P2，…，Pn}是这样组成的：若对于每一个进程Pi，它需要的附加资源可以被系统中当前可用资源加上所有进程Pj当前占有资源之和所满足，则{P1，P2，…，Pn}为一个安全序列，这时系统处于安全状态，不会进入死锁状态。</p>
<p>虽然存在安全序列时一定不会有死锁发生，但是系统进入不安全状态（四个死锁的必要条件同时发生）也未必会产生死锁。当然，产生死锁后，系统一定处于不安全状态。</p>
<ol start="2">
<li>银行家算法</li>
</ol>
<p>这是一个著名的避免死锁的算法，是由Dijstra首先提出来并加以解决的。</p>
<p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong><br>分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p>
<p><img src="/images/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.jpeg" alt="银行家算法"></p>
<h2 id="死锁的检查与恢复"><a href="#死锁的检查与恢复" class="headerlink" title="死锁的检查与恢复"></a>死锁的检查与恢复</h2><h3 id="死锁的检查"><a href="#死锁的检查" class="headerlink" title="死锁的检查"></a>死锁的检查</h3><p>检查死锁的办法就是检查系统中由进程和资源构成的有向图是否构成一个或多个环路，若是，则存在死锁，否则不存在。<br>由于死锁是系统中的恶性小概率事件，死锁检测程序的多次执行往往都不会调用一次死锁解除程序，而这却增加了系统开销，因此在设计操作系统时需要权衡检测精度与时间开销。</p>
<h3 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h3><p>一旦在死锁检测时发现了死锁，就要消除死锁，使系统从死锁状态中恢复过来。</p>
<ol>
<li>最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。</li>
<li>撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素。</li>
</ol>
<p>此外，还有进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Https中数字证书的原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-03-16 22:30:00" itemprop="dateCreated datePublished" datetime="2020-03-16T22:30:00+00:00">2020-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>网络请求方式通常分为两种，分别是HTTP请求和HTTPS请求，其中HTTP的传输属于明文传输，在传输的过程中容易被人截取并且偷窥其中的内容，而HTTPS是一种在HTTP的基础上加了SSL&#x2F;TLS层（安全套接层）的安全的超文本传输协议，其传输的内容是通过加密得到的，所以说是一种安全的传输。</p>
<p>说到加密算法，先来了解一下两种常用的加密方式，分别是对称加密和非对称加密：</p>
<p>1.对称加密：加密使用的秘钥和解密使用的秘钥是相同的，也就是说加密和解密都使用同一个秘钥，加密算法是公开的，秘钥是加密者和解密者绝对保密的。</p>
<p>2.非对称加密：加密使用的秘钥和解密使用的秘钥是不相同的，HTTPS在数字证书验证的时候，采用的RSA密码体制就是一种非对称加密。</p>
<p>RSA是一种公钥秘钥密码体制，现在使用非常广泛，这个密码体制分为三部分，公钥、私钥、加密算法，其中公钥和加密算法是公布的，私钥是自己保密的。这种机制最大的特点是，通过公钥加密的密文只有对应的私钥才能解密，同样通过私钥加密的密文也只有对应的公钥才能解密。下面我们将会讲到HTTPS是如何通过RSA这种密码体制去验证身份的。</p>
<p>首先了解一下数字证书，它有点像身份证，是由权威的CA机构颁发的，证书的主要内容有：公钥（Public Key）、ISSUER（证书的发布机构）、Subject（证书持有者）、证书有效期、签名算法、指纹及指纹算法。</p>
<p>下面csdn博客的CA证书内容：</p>
<p><img src="/images/csdnCA%E8%AF%81%E4%B9%A6%E5%86%85%E5%AE%B9.png" alt="图片" title="csdnCA证书内容"></p>
<p>可以看到公钥是一串很长的2048 Bits的字符串，同时也可以看到&lt;使用者&gt;的内容包含了csdn.net网址，这个网址是CSDN唯一拥有的，后面验证链接url是否正确的时候用到，还有颁发者、有效期、签名哈希算法等等。当然还有指纹及指纹算法等其他内容，我们滚动到下面看看另外一个截图</p>
<p><img src="/images/%E8%AF%81%E4%B9%A6%E8%AF%A6%E6%83%85.png" alt="图片" title="证书详情"></p>
<p>上面是CSDN网站CA证书，颁发者是GeoTrust，它就是权威的CA机构之一。到这里特别说明一下，CA机构除了给别人颁发证书以外，它也有自己的证书，为了区分我们称它为根证书，根证书也有自己的公钥和私钥，我们称之为根公钥和根私钥。然后根公钥和加密算法是向外公布的，而根私钥是机构自己绝对保密的。这个根证书在验证证书的过程中起着核心的作用。</p>
<p>指纹是什么？指纹是一个证书的签名，是通过指纹算法sha1计算出来的一个hash值，是用来验证证书内容有没有被篡改的。证书在发布之前，CA机构会把所颁发证书的内容用自己的根私钥通过指纹算法计算得到一个hash值，这个hash值只有对应的根公钥才能解密，所以在验证证书的时候，我们通过同样的指纹算法将证书内容通过计算得到另一个hash值，如果这个hash值跟证书上的签名解析出来的hash值相同，就代表证书没有被篡改过。</p>
<p>下面基于一个简单的图例，去分析整个HTTPS的数字证书验证过程：</p>
<p>图示如下：</p>
<p><img src="/images/HTTPS%E7%9A%84%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E8%BF%87%E7%A8%8B.png" alt="图片" title="HTTPS的数字证书验证过程"></p>
<p>假设这是一个浏览器的HTTPS请求</p>
<p>一：首先浏览器通过URL网址去请求某个后台服务器，后台接收到请求后，就会给浏览器发送一个自己的CA数字证书。</p>
<p>二：浏览器接收到数字证书以后，就要开始进行验证工作了。首先从证书的内容中获取证书的颁发机构，然后从浏览器系统中去寻找此颁发机构是否为浏览器的信任机构。这里解析一下，世界上就几个权威的CA机构，这几个机构的信息都是预先嵌入到我们的浏览器系统中的。如果收到的一个数字证书但其颁发机构没有在我们浏览器系统中的，那么就会有警告提示无法确认证书的真假。如果是受信任的机构，那么就到下一步。</p>
<p>此时我们就可以从浏览器中找到CA机构的根公钥，用这个公钥去解析证书的签名得到一个hash值H1，上面提到过，这个签名是证书发布之前CA机构用自己的根私钥加密而成的，所以这里只能由根证书的根公钥去解密。然后用证书的指纹算法对证书的内容再进行hash计算得到另一个hash值H2，如果此时H1和H2是相等的，就代表证书没有被修改过。在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器连接的网址也是正确的，而不是一些钓鱼网之类的。</p>
<p>这里我们假设，如果浏览器的连接被某个钓鱼网截取了，钓鱼网也可以发一个自己的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的情况下，通过对比证书上的URL和我们请求的URL，就可以发现这个证书的URL不是我们所要连接的网址，所以说钓鱼网也骗不了我们。</p>
<p>看到这里如果还不是很明白证书验证过程的话，我特别解析一下，我们知道CA机构有自己的根公钥和根私钥。在证书颁发之前，机构会用根私钥将这个证书内容加密得到一个签名，这个签名只能用对应的根公钥去解密。在客户端（浏览器）收到服务端发过来的证书以后，我们首先从浏览器中拿到机构的根公钥，用这个根公钥去解析证书的签名得到一个哈希值H1，这个H1代表证书的原始内容，假设这个证书上的签名是不法分子伪造的，但是伪造的签名不可能是根私钥加密生成的（因为根私钥是CA机构私有），所以根公钥也不可能去解密任何第三方生成的签名（加密内容只能由对应的公钥私钥解析）。然后我们再用同样的哈希算法对收证书内容进行计算得到哈希值H2，通过对比H1和H2是否相等就知道证书有没有被褚篡改过了。讲到这里，我们应该明白证书是否被篡改的验证机制了吧。</p>
<p>三：到这里，已经验证了证书是没有被篡改的并且确认连接的URL也是正确的，然后我们获取到了证书上的公钥。下一步有一个很重要的任务就是，如何将一个对称加密算法的秘钥安全地发给服务器。</p>
<p>首先随机生成一个字符串S作为我们的秘钥，然后通过证书公钥加密成密文，将密文发送给服务器。因为此密文是用公钥加密的，这是一个非对称加密，我们知道，这个密文只有私钥的持有者才能进行解密，所以说任何第三方截取到密文也是没用的，因为没有对应的私钥所以解析不出来。</p>
<p>一个关键步骤，发送密文的时候也会对消息内容进行签名操作。签名上面讲解过，就是对密文内容进行hash计算得到的一个hash值，将这个签名加密以后和消息内容一起发送出去。接收方收到消息以后，通过私钥解析出密文和签名的hash值，同时也会对接收的消息内容进行同样的计算得到另一个hash值，通过比对两个hash值是否相同来判断密文是否有修改过。</p>
<p>四：通过了上面的步骤以后，此时客户端和服务端都持有了对称加密算法的秘钥，然后兄弟两就可以愉快地安全通信了。</p>
<p>总结：数字证书的验证有两个重要的步骤，第一是验证数字证书没有被篡改以及连接的URL是否正确，第二是通过RSA机制的原理安全地将对称加密算法的秘钥发送给对方。这两步都完成以后，整个HTTPS的数字证书的验证就算是成功了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">merric</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
