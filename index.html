<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Myoboku">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Myoboku">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="merric">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Myoboku</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Myoboku</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">merric</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/ES%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">ES索引生命周期管理(ILM)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-17 22:30:00" itemprop="dateCreated datePublished" datetime="2023-05-17T22:30:00+00:00">2023-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="ES的最佳实践"><a href="#ES的最佳实践" class="headerlink" title="ES的最佳实践"></a>ES的最佳实践</h3><p>首先我们先来看下ES的最佳实践，这里列出了最核心的两点，分片大小的控制和分片数的设定</p>
<h5 id="1-单分片控制在50G以内（推荐日志场景在30G以内，搜索场景在10G以内）"><a href="#1-单分片控制在50G以内（推荐日志场景在30G以内，搜索场景在10G以内）" class="headerlink" title="1. 单分片控制在50G以内（推荐日志场景在30G以内，搜索场景在10G以内）"></a>1. 单分片控制在50G以内（推荐日志场景在30G以内，搜索场景在10G以内）</h5><p>分片大小为什么要控制呢？如果分片太大，我们在做数据迁移，reblance或者recovery的时候效率会特别低，影响集群的稳定性，同时分片太小了也不行，分片太小会导致同样数据量的情况下，集群的分片数会更多，ES的分片数越多，其实分片管理的效率会越低也会影响ES整体性能。 </p>
<h5 id="2-索引的分片数位数据节点的倍数"><a href="#2-索引的分片数位数据节点的倍数" class="headerlink" title="2. 索引的分片数位数据节点的倍数"></a>2. 索引的分片数位数据节点的倍数</h5><p>比如有3个数据节点，那最好的分片数应该是3、6、9等等</p>
<p>如果能做到以上两点，整个集群的稳定性还是有一定保障的。但其实以上这两点是很难同时做到的，这中间有个矛盾就是索引分片数没办法修改，但是一般情况下数据量都是不断增长的，最总就会导致单个分片的大小超过最佳实践的推荐值。</p>
<p> 那要如何解决索引分片数无法修改和数据持续增长的矛盾？</p>
<h3 id="理想实现"><a href="#理想实现" class="headerlink" title="理想实现"></a>理想实现</h3><p>那我们看下分布式系统中有没有这种比较理想的实现方式。</p>
<p>这边先举个例子，这里给出了一个有三个节点的数据集群，其中包含了3个shard</p>
<p><img src="/images/es_ilm/1691810296023.png" alt="1691810296023"></p>
<p>数据持续增长…</p>
<p><img src="/images/es_ilm/1691810457654.png" alt="1691810457654"></p>
<p>每个分片中的数据在不断增加，即将超过30G，这时候要怎么办呢？</p>
<h5 id="方式一-分裂"><a href="#方式一-分裂" class="headerlink" title="方式一 分裂"></a>方式一 分裂</h5><p><img src="/images/es_ilm/1691810614196.png" alt="1691810614196"></p>
<p>先把分片一分为二，再把数据平分，这样每个分片中就只存了一半的数据。如果数据不断增长，又满了，那就再次分裂。</p>
<h5 id="方式二-新增"><a href="#方式二-新增" class="headerlink" title="方式二 新增"></a>方式二 新增</h5><p><img src="/images/es_ilm/1691810780548.png" alt="1691810780548"></p>
<p>当数据满的时候，通过新增分片的方式来存储新的数据。ES中使用的方式就是这种新增的方式。</p>
<p>为什么ES没有使用方式一种的分裂方式呢？主要是因为数据的路由规则问题，ES用的是hash路由的方式来确定数据在哪个分片上，如果使用分裂的方式，每次分裂就需要重新对一半数据做reindex。（当然目前的es版本支持了split这种api，但实际上使用的并不多，因为性能较差）</p>
<h5 id="理想实现-rollover"><a href="#理想实现-rollover" class="headerlink" title="理想实现 rollover"></a>理想实现 rollover</h5><p><img src="/images/es_ilm/1691811190314.png" alt="1691811190314"></p>
<p>ES种新增的过程叫rollover，就是旧的索引（index-00001）满了之后会创建一个新的索引（index-00002）,但从整体上来讲，他们对于用户来讲属于同一个索引，index-00001和index-00002被同一个逻辑索引或者叫别名（alias）纳管。程序使用的时候是通过别名来进行读写，rollover和alias是同时使用的。如果index-00002也满了，就会继续滚动，创建index-00003，同时被别名纳管。</p>
<p>这样就实现了shard随着数据的不断增长，自身也在不断增加，同时确保每个分片的数据量保持在推荐的范围内。</p>
<h5 id="理想实现-migration"><a href="#理想实现-migration" class="headerlink" title="理想实现 migration"></a>理想实现 migration</h5><p>那实际生产中可能还有一中场景，就是随着时间的一部分数据查询频率会降低，数据价值也会降低，这时候如果如果可以把数据迁移到低配的机器上可以大大节省成本。</p>
<p><img src="/images/es_ilm/1691811697352.png" alt="1691811697352"></p>
<p>迁移</p>
<p><img src="/images/es_ilm/1691816974098.png" alt="1691816974098"></p>
<p>这样就可以更合理使用硬件资源，提升硬件使用效率。</p>
<p>再回头看最佳实践，单分片大小限制和分片数不可修改的问题就完美解决了。我们只需要根据业务情况来确定滚动周期以及数据每日增量即可确定分片数以及单分片大小，系统会根据配置自动滚动，生成新的索引。</p>
<h3 id="ES的索引生命周期"><a href="#ES的索引生命周期" class="headerlink" title="ES的索引生命周期"></a>ES的索引生命周期</h3><p>索引的生命周期可以归纳为下面四个阶段</p>
<p>Hot阶段读写频繁，使用高配服务器，Warm、Cold使用低配机器即可满足</p>
<p><img src="/images/es_ilm/1691817840919.png" alt="1691817840919"> </p>
<p>我们只需要搞清楚每个阶段做了生命操作即可</p>
<p><img src="/images/es_ilm/1691817954788.png" alt="1691817954788"></p>
<p>索引一单创建肯定是进入到Hot阶段，我们可以指定一个min_age，那两天之后就会进入到Warm阶段，然后再设置4天之后进入Cold阶段，以及23天后删除。</p>
<h5 id="Hot-Phase"><a href="#Hot-Phase" class="headerlink" title="Hot Phase"></a>Hot Phase</h5><p>Create</p>
<p>​	Index Template</p>
<p>Rollover</p>
<p>​	Index Alias</p>
<p>​	在索引文档数、大小、时间打到一定条件后，创建索引</p>
<p>​	控制Shard大小</p>
<h5 id="Warm-Phase"><a href="#Warm-Phase" class="headerlink" title="Warm Phase"></a>Warm Phase</h5><p>Allocate</p>
<p>​	Node Attribute</p>
<p>​	Index Shard Allocation</p>
<p>​		index.routing.allocation.require.*</p>
<p>Read-Only</p>
<p>​	index.blocks.read_only:true</p>
<p>Fource Merge</p>
<p>Shrink</p>
<h5 id="Cold-Phase"><a href="#Cold-Phase" class="headerlink" title="Cold Phase"></a>Cold Phase</h5><p>Allocate</p>
<p>​	Node Attribute</p>
<p>​	Index Shard Allocation</p>
<p>​		index.routing.allocation.require.*</p>
<h5 id="Delete-Phase"><a href="#Delete-Phase" class="headerlink" title="Delete Phase"></a>Delete Phase</h5><p>Delete</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h5 id="创建rollover策略"><a href="#创建rollover策略" class="headerlink" title="创建rollover策略"></a>创建rollover策略</h5><p>如下策略的含义为：当索引的大小达到1000GB，索引创建超过1天时，自动进行滚 动；索引创建7天后，关闭数据副本；索引创建30天后，删除该索引。</p>
<p>策略可以根据具体业务场景进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PUT _opendistro/_ism/policies/rollover_workflow</span><br><span class="line">&#123;</span><br><span class="line">    &quot;policy&quot;:&#123;</span><br><span class="line">        &quot;description&quot;:&quot;rollover test&quot;,</span><br><span class="line">        &quot;default_state&quot;:&quot;hot&quot;,</span><br><span class="line">        &quot;states&quot;:[</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;:&quot;hot&quot;,</span><br><span class="line">                &quot;actions&quot;:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;rollover&quot;:&#123;</span><br><span class="line">                            &quot;min_size&quot;:&quot;1000gb&quot;,</span><br><span class="line">                            &quot;min_index_age&quot;:&quot;1d&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;transitions&quot;:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;state_name&quot;:&quot;warm&quot;,</span><br><span class="line">                        &quot;conditions&quot;:&#123;</span><br><span class="line">                            &quot;min_index_age&quot;:&quot;7d&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;:&quot;warm&quot;,</span><br><span class="line">                &quot;actions&quot;:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;replica_count&quot;:&#123;</span><br><span class="line">                            &quot;number_of_replicas&quot;:0</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;transitions&quot;:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;state_name&quot;:&quot;delete&quot;,</span><br><span class="line">                        &quot;conditions&quot;:&#123;</span><br><span class="line">                            &quot;min_index_age&quot;:&quot;30d&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;:&quot;delete&quot;,</span><br><span class="line">                &quot;actions&quot;:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;delete&quot;:&#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好Rollover策略之后，可以通过如下命令查询策略详情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _opendistro/_ism/policies/rollover_workflow</span><br></pre></td></tr></table></figure>

<h5 id="新建索引模板"><a href="#新建索引模板" class="headerlink" title="新建索引模板"></a>新建索引模板</h5><p>如下模板的含义为：对于所有test开头的索引，其自动关联上面创建的rollover策略， 并且rollover时使用log_alias作为别名。 模板可以结合具体业务场景进行调整，比如：number_of_shards、refresh_interval， 以及mapping里面的参数等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT _template/template_test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index_patterns&quot;:&quot;test*&quot;,</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;number_of_replicas&quot;:1,</span><br><span class="line">        &quot;number_of_shards&quot;:1,</span><br><span class="line">        &quot;opendistro.index_state_management.policy_id&quot;:&quot;rollover_workflow&quot;,</span><br><span class="line">        &quot;index.opendistro.index_state_management.rollover_alias&quot;:&quot;log_alias&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建好索引模板之后，可以通过如下命令查询模板详情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _template/template_test</span><br></pre></td></tr></table></figure>

<h5 id="创建第一个索引"><a href="#创建第一个索引" class="headerlink" title="创建第一个索引"></a>创建第一个索引</h5><p>第一个索引要指定aliases，并且需要配置is_write_index为true。</p>
<p>如下索引是&lt;test-{now&#x2F;d}-000001&gt;的URL编码，其创建时默认会带上当天的时间，比<br>如假设今天为2022.6.22，那么创建出来的索引名称为：test-2022.06.02-000001。</p>
<p>这里必须用urlencode，不然报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT %3Ctest-%7Bnow%2Fd%7D-000001%3E</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aliases&quot;:&#123;</span><br><span class="line">        &quot;log_alias&quot;:&#123;</span><br><span class="line">            &quot;is_write_index&quot;:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写入或查询数据"><a href="#写入或查询数据" class="headerlink" title="写入或查询数据"></a>写入或查询数据</h5><p>写入数据或查询数据时均使用别名log_alias，其中写入时log_alias始终指向最后一个 索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST log_alias/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name1&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name2&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name3&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name4&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name5&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;name6&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>写入数据或查询数据时均使用别名log_alias，其中查询时log_alias指向所有的历史索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET log_alias/_search</span><br></pre></td></tr></table></figure>

<p>查询别名关联的索引情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/aliases?v</span><br></pre></td></tr></table></figure>

<p>假设某个索引，其每天约产生2.4TB的数据，那么其数据在ES中的组织形态如下，其中索引别名 log-alias。 查询时指向所有test开头的索引，写入时指向最新的索引。</p>
<p><img src="/images/es_ilm/1691818897925.jpg" alt="1691818897925"></p>
<h5 id="数据更新的问题"><a href="#数据更新的问题" class="headerlink" title="数据更新的问题"></a>数据更新的问题</h5><p>在实际开发测试中发现，历史数据使用索引别名更新的时候会存在问题。</p>
<p>假设历史A索引中存在一条x数据，当前索引为B索引</p>
<p>当再次更新这个x数据的时候，不会更新A索引中的这条数据，而是会插入到B索引中，此时再去查询x数据就会查询到两条。</p>
<p>原因：Rollover策略实现自动滚动索引后，历史索引的is_write_index属性会被设置为false，当通过索引别名来PUT数据时，只会从当前索引中判断是同存在相同数据。由于数据存在历史索引中，所以会在新索引中创建记录</p>
<p>![d1aca159ba370fc83db4043922a2521](C:\Users\Ryan\AppData\Local\Temp\WeChat Files\d1aca159ba370fc83db4043922a2521.png)</p>
<p>解决方法：更新数据时先查询当前数据所在的索引，更新时带上索引</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过ES的索引生命周期管理，我们可以根据业务需求，设置分片数与滚动策略，不用担心索引分片数不够，或者分片容量太大的问题。合理使用分片策略可以满足大部分订单类系统查询需求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Elasticsearch原理详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-09 22:30:00" itemprop="dateCreated datePublished" datetime="2023-04-09T22:30:00+00:00">2023-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ES</code>是使用 <code>Java</code> 编写的一种开源搜索引擎，它在内部使用 <code>Lucene</code>做索引与搜索，通过对<br><code>Lucene</code>的封装，隐藏了<code>Lucene</code>的复杂性，取而代之的提供一套简单一致的 <code>RESTful API</code><br>然而，<code>Elasticsearch</code> 不仅仅是 <code>Lucene</code>，并且也不仅仅只是一个全文搜索引擎。</p>
<p>它可以被下面这样准确的形容：</p>
<ul>
<li>一个分布式的<code>实时</code>文档存储，每个字段可以被索引与搜索。</li>
<li>一个分布式实时分析搜索引擎。</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li>
</ul>
<p>官网对 <code>Elasticsearch</code> 的介绍是 <code>Elasticsearch</code> 是一个分布式、可扩展、近实时的搜索与数据分析引擎。</p>
<p>其中主要有如下几个核心术语需要理解：</p>
<ul>
<li>词条（<code>Term</code>）： 索引里面最小的存储和查询单元，对于英文来说是一个单词，对于中文来说一般指分词后的一个词。</li>
<li>词典（<code>Term Dictionary</code>）： 或字典，是词条 <code>Term</code> 的集合。搜索引擎的通常索引单位是<code>单词</code>，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向<code>倒排列表</code>的指针。</li>
<li>倒排表（<code>Post list</code>）：一个文档通常由多个词组成，倒排表记录的是某个词在哪些文档里出现过以及出现的位置。每条记录称为一个倒排项（<code>Posting</code>）。倒排表记录的不仅是文档编号，还存储了词频等信息。</li>
<li>倒排文件（<code>Inverted File</code>）： 所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为<code>倒排文件</code>，倒排文件是存储倒排索引的物理文件<br>**<code>由属性值来确定记录的位置的结构就是倒排索引</code>**。带有倒排索引的文件称为<code>倒排文件</code></li>
</ul>
<p><code>词典</code>和<code>倒排表</code>是 <code>Lucene</code><br>中很重要的两种数据结构，是实现快速检索的重要基石。<code>词典</code>和<code>倒排文件</code>是分两部分存储的，<code>词典在内存中</code>而<code>倒排文件存储在磁盘</code>上</p>
<h2 id="分片，副本，映射"><a href="#分片，副本，映射" class="headerlink" title="分片，副本，映射"></a>分片，副本，映射</h2><h3 id="分片（Shards）"><a href="#分片（Shards）" class="headerlink" title="分片（Shards）"></a>分片（Shards）</h3><p><code>ES</code> 支持 <code>PB</code> 级全文搜索，当索引上的数据量太大的时候，<code>ES</code><br>通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片。<br>这类似于 <code>MySQL</code> 的分库分表，只不过 <code>MySQL</code> 分库分表需要借助第三方组件而 <code>ES</code> 内部自身实现了此功能。</p>
<p>在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中，所以在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。<br>分片的数量和下面介绍的副本数量都是可以通过创建索引时的 <code>Settings</code> 来配置，<code>ES</code> 默认为一个索引创建 5 个主分片,<br>并分别为每个分片创建一个副本。</p>
<pre><code>PUT /myIndex    
&#123;    
   &quot;settings&quot; : &#123;    
      &quot;number_of_shards&quot; : 5,    
      &quot;number_of_replicas&quot; : 1    
   &#125;    
&#125;    
  
</code></pre>
<p><code>ES</code> 通过分片的功能使得索引在规模上和性能上都得到提升，每个分片都是 <code>Lucene</code><br>中的一个索引文件，每个分片必须有一个<code>主分片</code>和<code>零到多个副本</code>。</p>
<h3 id="副本（Replicas）"><a href="#副本（Replicas）" class="headerlink" title="副本（Replicas）"></a>副本（Replicas）</h3><p><code>副本</code>就是对分片的 <code>Copy</code>，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。<br>主分片和对应的副本分片是不会在同一个节点上的，所以副本分片数的最大值是 N-1（其中 N 为节点数）。<br>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<p><code>ES</code> 为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，<code>ES</code> 通过乐观锁的方式控制，每个文档都有一个<br><code>_version （版本）</code>号，当文档被修改时版本号递增。<br>一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功</p>
<p><img src="/images/ES%E9%9B%86%E7%BE%A4.png" alt="ES集群"></p>
<p>从上图可以看出为了达到高可用，<code>Master</code> 节点会避免将主分片和副本分片放在同一个节点上。</p>
<p>假设这时节点 <code>Node1</code> 服务宕机了或者网络不可用了，那么主节点上主分片 S0 也就不可用了。幸运的是还存在另外两个节点能正常工作，这时 <code>ES</code><br>会重新选举新的主节点，而且这两个节点上存在我们所需要的 <code>S0</code> 的所有数据。我们会将 <code>S0</code><br>的副本分片提升为主分片，这个提升主分片的过程是瞬间发生的。此时集群的状态将会为 <code>Yellow</code>。</p>
<p>为什么我们集群状态是 <code>Yellow</code> 而不是 <code>Green</code> 呢？虽然我们拥有所有的 2<br>个主分片，但是同时设置了每个主分片需要对应两份副本分片，而此时只存在一份副本分片。所以集群不能为 <code>Green</code> 的状态。<br>如果我们同样关闭了 <code>Node2</code> ，我们的程序依然可以保持在不丢失任何数据的情况下运行，因为 <code>Node3</code> 为每一个分片都保留着一份副本。<br>如果我们重新启动 <code>Node1</code> ，集群可以将缺失的副本分片再次进行分配，那么集群的状态又将恢复到原来的正常状态。<br>如果 <code>Node1</code> 依然拥有着之前的分片，它将尝试去重用它们，只不过这时 <code>Node1</code><br>节点上的分片不再是主分片而是副本分片了，如果期间有更改的数据只需要从主分片上复制修改的数据文件即可。</p>
<p>小结：</p>
<ul>
<li>将数据分片是为了提高可处理数据的容量和易于进行水平扩展，为分片做副本是为了提高集群的稳定性和提高并发量。</li>
<li>副本是乘法，越多消耗越大，但也越保险。分片是除法，分片越多，单分片数据就越少也越分散。</li>
<li>副本越多，集群的可用性就越高，但是由于每个分片都相当于一个 Lucene 的索引文件，会占用一定的文件句柄、内存及 CPU。并且分片间的数据同步也会占用一定的网络带宽，所以索引的分片数和副本数也不是越多越好。</li>
</ul>
<h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p><code>映射</code>是用于定义 <code>ES</code> 对索引中字段的存储类型、分词方式和是否存储等信息，就像数据库中的<code>Schema</code><br>，描述了文档可能具有的字段或属性、每个字段的数据类型。<br>只不过关系型数据库建表时必须指定字段类型，而 <code>ES</code> 对于字段类型可以不指定然后动态对字段类型猜测，也可以在创建索引时具体指定字段的类型。<br>对字段类型根据数据格式自动识别的映射称之为动态映射（<code>Dynamic Mapping</code>），我们创建索引时具体定义字段类型的映射称之为静态映射或显示映射（<code>Explicit Mapping</code>）。</p>
<p>在讲解动态映射和静态映射的使用前，我们先来了解下 ES 中的数据有哪些字段类型？之后我们再讲解为什么我们创建索引时需要建立静态映射而不使用动态映射。</p>
<p><code>ES（v6.8）</code>中字段数据类型主要有以下几类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>核心类型</td>
<td>text，keywords，long，integer，short，double，data，boolean</td>
</tr>
<tr>
<td>复杂类型</td>
<td>Object，Nested</td>
</tr>
<tr>
<td>地理类型</td>
<td>geo_point，geo_shape</td>
</tr>
<tr>
<td>特殊类型</td>
<td>ip，completion，token_count，join</td>
</tr>
</tbody></table>
<p><code>Text</code> 用于索引全文值的字段，例如电子邮件正文或产品说明。这些字段是被分词的，它们通过分词器传递<br>，以在被索引之前将字符串转换为单个术语的列表。分析过程允许 <code>Elasticsearch</code><br>搜索单个单词中每个完整的文本字段。文本字段不用于排序，很少用于聚合。<br><code>Keyword</code> 用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常用于过滤，排序，和聚合。Keyword<br>字段只能按其确切值进行搜索。</p>
<p>通过对字段类型的了解我们知道有些字段需要明确定义的，例如某个字段是 Text 类型还是 Keyword<br>类型差别是很大的，时间字段也许我们需要指定它的时间格式，还有一些字段我们需要指定特定的分词器等等。</p>
<p>如果采用动态映射是不能精确做到这些的，自动识别常常会与我们期望的有些差异。所以创建索引的时候一个完整的格式应该是指定<code>分片和副本数以及 Mapping</code>的定义，如下：</p>
<pre><code>PUT my_index     
&#123;    
   &quot;settings&quot; : &#123;    
      &quot;number_of_shards&quot; : 5,    
      &quot;number_of_replicas&quot; : 1    
   &#125;    
  &quot;mappings&quot;: &#123;    
    &quot;_doc&quot;: &#123;     
      &quot;properties&quot;: &#123;     
        &quot;title&quot;:    &#123; &quot;type&quot;: &quot;text&quot;  &#125;,     
        &quot;name&quot;:     &#123; &quot;type&quot;: &quot;text&quot;  &#125;,     
        &quot;age&quot;:      &#123; &quot;type&quot;: &quot;integer&quot; &#125;,      
        &quot;created&quot;:  &#123;    
          &quot;type&quot;:   &quot;date&quot;,     
          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;    
        &#125;    
      &#125;    
    &#125;    
  &#125;    
&#125;    
  
</code></pre>
<h2 id="ES机制原理"><a href="#ES机制原理" class="headerlink" title="ES机制原理"></a>ES机制原理</h2><h3 id="写索引原理"><a href="#写索引原理" class="headerlink" title="写索引原理"></a>写索引原理</h3><p>下图描述了 3 个节点的集群，共拥有 12 个分片，其中有 4 个主分片（S0、S1、S2、S3）和 8<br>个副本分片（R0、R1、R2、R3），每个主分片对应两个副本分片，节点 1 是主节点（Master 节点）负责整个集群的状态。</p>
<p><img src="/images/3%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84ES%E9%9B%86%E7%BE%A4.png" alt="3个节点的ES集群"></p>
<p><code>写索引</code>是<code>只能写在主分片</code>上，然后同步到副本分片。这里有四个主分片，一条数据 <code>ES</code> 是根据什么规则写到特定分片上的呢？<br>这条索引数据为什么被写到 S0 上而不写到 S1 或 S2 上？那条数据为什么又被写到 S3 上而不写到 S0 上了？</p>
<p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
<pre><code>shard = hash(routing) % number_of_primary_shards    
  
</code></pre>
<p><code>Routing</code> 是一个可变值，默认是文档的 <code>_id</code> ，也可以设置成一个自定义的值。<br><code>Routing</code> 通过 <code>Hash</code> 函数生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code><br>（主分片的数量）后得到余数。这个在 <code>0</code> 到 <code>number_of_primary_shards-1</code> 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量：**<code>因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了</code>**</p>
<p>由于在 <code>ES</code> 集群中每个节点通过上面的计算公式都知道集群中的文档的存放位置，所以每个节点都有处理读写请求的能力。<br>在一个写请求被发送到某个节点后，该节点即为前面说过的<code>协调节点</code>，<code>协调节点</code>会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上</p>
<p><img src="/images/%E5%86%99%E8%AF%B7%E6%B1%82.png" alt="写请求"></p>
<p>假如此时数据通过路由计算公式取余后得到的值是</p>
<pre><code>shard=hash(routing)%4=0  
  
</code></pre>
<p>则具体流程如下：</p>
<ul>
<li>客户端向 <code>ES1</code> 节点（协调节点）发送写请求，通过路由计算公式得到值为 0，则当前数据应被写到主分片 S0 上。</li>
<li><code>ES1</code> 节点将请求转发到 <code>S0</code> 主分片所在的节点 ES3，ES3 接受请求并写入到磁盘。</li>
<li>并发将数据复制到两个副本分片 <code>R0</code> 上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点 <code>ES3</code> 将向协调节点报告成功，协调节点向客户端报告成功。</li>
</ul>
<h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>上面介绍了在 <code>ES</code> 内部索引的写处理流程，这个流程是在 <code>ES</code><br>的<code>内存</code>中执行的，数据被分配到特定的<code>分片</code>和<code>副本</code>上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。<br>具体的存储路径可在配置文件 <code>../config/elasticsearch.yml</code> 中进行设置，默认存储在安装目录的 <code>Data</code> 文件夹下。<br>建议不要使用默认值，因为若 <code>ES</code> 进行了升级，则有可能导致数据全部丢失：</p>
<pre><code>path.data: /path/to/data  //索引数据    
path.logs: /path/to/logs  //日志记录    
  
</code></pre>
<h4 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h4><p>索引文档以<code>段</code>的形式存储在磁盘上，索引文件被拆分为多个<code>子文件</code>，则每个<code>子文件</code>叫作<code>段</code>，每一个段本身都是一个<code>倒排索引</code>，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改。</p>
<p>在底层采用了<code>分段存储模式</code>，使它在读写时几乎完全避免了锁的出现，大大提升了读写性能。<br>段被写入到磁盘后会生成一个<code>提交点</code>，<code>提交点</code>是一个用来记录所有提交后段信息的文件。</p>
<p><strong><code>一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限</code></strong> 。相反，<br>**<code>当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索</code>**。</p>
<p>段的概念提出主要是因为：在早期全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中。如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。</p>
<p>索引文件分段存储并且不可修改，那么新增、更新和删除如何处理呢？</p>
<ul>
<li><code>新增</code>，新增很好处理，由于数据是新的，所以只需要对当前文档新增一个段就可以了。</li>
<li><code>删除</code>，由于不可修改，所以对于删除操作，不会把文档从旧的段中移除而是通过新增一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。这个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</li>
<li><code>更新</code>，不能修改旧的段来进行反映文档的更新，其实更新相当于是<code>删除</code>和<code>新增</code>这两个动作组成。会将旧的文档在 <code>.del</code> 文件中标记删除，然后文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就会被移除。</li>
</ul>
<p>段被设定为不可修改具有一定的优势也有一定的缺点，优势主要表现在：</p>
<ul>
<li>不需要锁，如果从来不更新索引，那就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像 <code>Filter</code> 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 <code>I/O</code> 和需要被缓存到内存的索引的使用量。</li>
</ul>
<p>段的不变性的缺点如下：</p>
<ul>
<li>当对旧数据进行删除时，旧数据不会马上被删除，而是在 <code>.del</code> 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。</li>
<li>若有一条数据频繁的更新，每次更新都是新增新的标记旧的，则会有大量的空间浪费。</li>
<li>每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。</li>
<li>在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。</li>
</ul>
<h4 id="延迟写策略"><a href="#延迟写策略" class="headerlink" title="延迟写策略"></a>延迟写策略</h4><p>介绍完了存储的形式，那么索引写入到磁盘的过程是怎样的？是否是直接调 <code>Fsync</code>物理性地写入磁盘？<br>答案是显而易见的，如果是直接写入到磁盘上，磁盘的 <code>I/O</code> 消耗上会严重影响性能。那么当写数据量大的时候会造成 <code>ES</code><br>停顿卡死，查询也无法做到快速响应。如果真是这样 <code>ES</code> 也就不会称之为近实时全文搜索引擎了。</p>
<p>为了提升写的性能，<code>ES</code><br>并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。每当有新增的数据时，就将其先写入到内存中，在<code>内存</code>和<code>磁盘</code>之间是<code>文件系统缓存</code>。<br>当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（<code>Refresh</code>），将内存中的数据生成到一个新的段上并缓存到文件缓存系统<br>上，稍后再被刷新到磁盘中并生成提交点。<br>这里的<code>内存</code>使用的是 <code>ES</code> 的 <code>JVM</code> 内存，而文件缓存系统使用的是操作系统的内存。</p>
<p>新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。由<code>内存</code>刷新到文件缓存系统的时候会生成新的段，并<code>将段打开</code>以供<code>搜索使用</code>，而不需要等到被刷新到磁盘。</p>
<p>在 <code>Elasticsearch</code> 中，写入和打开一个新段的轻量的过程叫做 <code>Refresh</code><br>（即内存刷新到文件缓存系统）。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 <code>Elasticsearch</code><br>是<code>近实时搜索</code>，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。<br>我们也可以手动触发 <code>Refresh</code>，<code>POST /_refresh</code> 刷新所有索引，<code>POST /nba/_refresh</code> 刷新指定的索引。</p>
<p><code>注意</code>：尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，<br>手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。而且并不是所有的情况都需要每秒刷新。</p>
<p>假如正在使用 <code>Elasticsearch</code> 索引大量的日志文件， 想优化索引速度而不是近实时搜索。这时可以在创建索引时在 <code>Settings</code> 中通过调大<br><code>refresh_interval = &quot;30s&quot;</code> 的值 ， 降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒。当<br><code>refresh_interval=-1</code> 时表示关闭索引的自动刷新。</p>
<p>虽然通过延时写的策略可以减少数据往磁盘上写的次数并提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。<br>为了避免丢失数据，<code>Elasticsearch</code> 添加了事务日志（<code>Translog</code>），事务日志记录了所有还没有持久化到磁盘的数据</p>
<p><img src="/images/%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E5%90%8E%E5%86%99%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="事务日志后写索引的流程"></p>
<p>添加了事务日志后整个写索引的流程如上图所示：</p>
<ul>
<li>一个新文档被索引之后，先被写入到内存中，但是为了防止数据的丢失，会追加一份数据到事务日志中。</li>
<li>不断有新的文档被写入到内存，同时也都会记录到事务日志中。这时新数据还不能被检索和查询。</li>
<li>当达到默认的刷新时间或内存中的数据达到一定量后，会触发一次 <code>Refresh</code>，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。</li>
<li>随着新文档索引不断被写入，当日志数据大小超过 <code>512M</code> 或者时间超过 30 分钟时，会触发一次 <code>Flush</code></li>
<li>内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 <code>Fsync</code> 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。</li>
</ul>
<p>通过这种方式当断电或需要重启时，<code>ES</code> 不仅要根据提交点去加载已经持久化过的段，还需要工具 <code>Translog</code><br>里的记录，把未持久化的数据重新持久化到磁盘上，避免了数据丢失的可能。</p>
<h4 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h4><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 CPU<br>运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。</p>
<p><code>Elasticsearch</code> 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大段中。合并的过程中不会中断索引和搜索。</p>
<p><img src="/images/%E6%AE%B5%E5%90%88%E5%B9%B6.png" alt="段合并"></p>
<p>段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，**<code>这些段既可以是未提交的也可以是已提交的</code>**<br>合并结束后老的段会被删除，新的段被 <code>Flush</code> 到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开可以用来搜索。</p>
<p>段合并的计算量庞大， 而且还要吃掉大量磁盘 I&#x2F;O，段合并会拖累写入速率，如果任其发展会影响搜索性能。<br><code>Elasticsearch</code> 在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>磁盘在现代服务器上通常都是瓶颈。<code>Elasticsearch</code> 重度使用磁盘，磁盘能处理的吞吐量越大，节点就越稳定。</p>
<p>这里有一些优化磁盘 I&#x2F;O 的技巧：</p>
<ul>
<li>使用 SSD。比机械磁盘优秀多了。</li>
<li>使用 RAID 0。条带化 RAID 会提高磁盘 I&#x2F;O，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验 RAID 因为副本已经提供了这个功能。</li>
<li>使用多块硬盘，并允许 <code>Elasticsearch</code> 通过多个 <code>path.data</code> 目录配置把数据条带化分配到它们上面。</li>
<li>不要使用远程挂载的存储，比如 NFS 或者 SMB&#x2F;CIFS。这个引入的延迟对性能来说完全是背道而驰的。</li>
</ul>
<h3 id="内部索引优化"><a href="#内部索引优化" class="headerlink" title="内部索引优化"></a>内部索引优化</h3><p><code>Elasticsearch</code> 为了能快速找到某个 <code>Term</code>，先将所有的 <code>Term</code> 排个序，然后根据二分法查找 <code>Term</code>，时间复杂度为<br><code>logN</code>，就像通过字典查找一样，这就是 <code>Term Dictionary</code>。<br>现在再看起来，似乎和传统数据库通过 <code>B-Tree</code> 的方式类似。但是如果 Term 太多，<code>Term Dictionary</code><br>也会很大，放内存不现实，于是有了 <code>Term Index</code>。<br>就像字典里的索引页一样，A 开头的有哪些 Term，分别在哪页，可以理解 <code>Term Index</code>是一棵树。这棵树不会包含所有的 <code>Term</code>，它包含的是<br><code>Term</code> 的一些前缀。通过 <code>Term Index</code> 可以快速地定位到 <code>Term Dictionary</code> 的某个<br><code>Offset</code>，然后从这个位置再往后顺序查找。</p>
<p>在内存中用 <code>FST</code> 方式压缩 <code>Term Index</code>，<code>FST</code> 以字节的方式存储所有的 <code>Term</code>，这种压缩方式可以有效的缩减存储空间，使得<br><code>Term Index</code> 足以放进内存，但这种方式也会导致查找时需要更多的 CPU 资源。</p>
<p>对于存储在磁盘上的倒排表同样也采用了压缩技术减少存储所占用的空间。</p>
<p><img src="/images/FST.jpeg" alt="FST"></p>
<h3 id="调整配置参数"><a href="#调整配置参数" class="headerlink" title="调整配置参数"></a>调整配置参数</h3><p>调整配置参数建议如下：</p>
<ul>
<li>给每个文档指定有序的具有压缩良好的序列模式 ID，避免随机的 <code>UUID-4</code>这样的 ID，这样的 ID 压缩比很低，会明显拖慢 Lucene。</li>
<li>对于那些不需要聚合和排序的索引字段禁用 <code>Doc values</code>。<code>Doc Values</code> 是有序的基于 <code>document=&gt;field value</code> 的映射列表。</li>
<li>不需要做模糊检索的字段使用 <code>Keyword</code> 类型代替 Text 类型，这样可以避免在建立索引前对这些文本进行分词。</li>
<li>如果搜索结果不需要近实时的准确度，考虑把每个索引的 <code>index.refresh_interval</code> 改到 <code>30s</code></li>
<li>如果在做大批量导入，导入期间可以通过设置这个值为 <code>-1</code> 关掉刷新，还可以通过设置 <code>index.number_of_replicas: 0</code> 关闭副本。别忘记在完工的时候重新开启它。</li>
<li>避免深度分页查询建议使用 <code>Scroll</code> 进行分页查询。普通分页查询时，会创建一个 <code>from+size</code> 的空优先队列，每个分片会返回 <code>from+size</code> 条数据，默认只包含文档 ID 和得分 Score 给协调节点。</li>
<li>如果有 N 个分片，则协调节点再对<code>（from+size）×n</code>条数据进行二次排序，然后选择需要被取回的文档。当 <code>from</code> 很大时，排序过程会变得很沉重，占用 CPU 资源严重。</li>
<li>减少映射字段，只提供需要检索，聚合或排序的字段。其他字段可存在其他存储设备上，例如 Hbase，在 ES 中得到结果后再去 Hbase 查询这些字段。</li>
<li>创建索引和查询时指定路由 <code>Routing</code> 值，这样可以精确到具体的分片查询，提升查询效率。路由的选择需要注意数据的分布均衡。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%9D%E8%A7%81TiDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%9D%E8%A7%81TiDB/" class="post-title-link" itemprop="url">初见TiDB</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-09 22:30:00" itemprop="dateCreated datePublished" datetime="2023-03-09T22:30:00+00:00">2023-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先放TiDB的gitbook，里面对于tidb的大部分内容都有详细的介绍：<a target="_blank" rel="noopener" href="https://book.tidb.io/">https://book.tidb.io/</a></p>
<p>其次实际的应用当然需要PingCAP的官方文档：<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/overview%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8F%AA%E6%98%AF%E6%83%B3%E4%BA%86%E8%A7%A3%E4%B8%8BTiDB%EF%BC%8C%E6%84%9F%E8%A7%89%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E7%82%B9%E7%81%AB%EF%BC%8C%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%9C%A8%E4%B8%8A%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E6%9C%89%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E6%8E%A5%E8%A7%A6%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%BD%93%E6%97%B6%E8%87%AA%E5%B7%B1%E7%BB%8F%E9%AA%8C%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%8D%E8%A7%89%E5%BE%97%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB%E6%88%96%E8%80%85%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%B0%B1%E6%B2%A1%E6%9C%89%E8%BF%87%E5%A4%9A%E4%BA%86%E8%A7%A3%E3%80%82%E7%8E%B0%E5%9C%A8%E5%9C%A8%E7%BE%8E%E5%9B%A2%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E8%B4%9F%E8%B4%A3%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%AE%9E%E9%99%85%E7%94%A8%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BB%A5Mysql%E4%B8%BA%E4%B8%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E8%BF%99%E9%87%8C%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E8%BF%99%E4%BA%9B%E8%B5%84%E6%96%99%EF%BC%8C%E5%AF%B9TiDB%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%82">https://docs.pingcap.com/zh/tidb/stable/overview，因为自己只是想了解下TiDB，感觉这个数据库有点火，大致了解一下工作原理，自己在上一家公司有实际使用接触过，但是因为当时自己经验不足，不觉得他有什么特别或者不同，就没有过多了解。现在在美团公司内部有自己的分布式数据库，但是我负责的业务场景实际用不到，还是以Mysql为主，所以在这里根据网络上的这些资料，对TiDB做一个简单的学习和总结。</a></p>
<h2 id="TiDB简介"><a href="#TiDB简介" class="headerlink" title="TiDB简介"></a>TiDB简介</h2><p><a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb">TiDB</a> 是 [PingCAP](<a target="_blank" rel="noopener" href="https://pingcap.com/about-">https://pingcap.com/about-</a><br>cn&#x2F;) 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and<br>Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时<br>HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online<br>Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。TiDB<br>适合高可用、强一致要求较高、数据规模较大等各种应用场景。</p>
<h3 id="五大核心特性"><a href="#五大核心特性" class="headerlink" title="五大核心特性"></a>五大核心特性</h3><ul>
<li>一键水平扩容或者缩容</li>
</ul>
<p>得益于 TiDB 存储计算分离的架构的设计，可按需对计算、存储分别进行在线扩容或者缩容，扩容或者缩容过程中对应用运维人员透明。</p>
<ul>
<li>金融级高可用</li>
</ul>
<p>数据采用多副本存储，数据副本通过 Multi-Raft<br>协议同步事务日志，多数派写入成功事务才能提交，确保数据强一致性且少数副本发生故障时不影响数据的可用性。可按需配置副本地理位置、副本数量等策略满足不同容灾级别的要求。</p>
<ul>
<li>实时 HTAP</li>
</ul>
<p>提供行存储引擎 <a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tikv-overview">TiKV</a>、列存储引擎<br><a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tiflash-overview">TiFlash</a><br>两款存储引擎，TiFlash 通过 Multi-Raft Learner 协议实时从 TiKV 复制数据，确保行存储引擎 TiKV 和列存储引擎<br>TiFlash 之间的数据强一致。TiKV、TiFlash 可按需部署在不同的机器，解决 HTAP 资源隔离的问题。</p>
<ul>
<li>云原生的分布式数据库</li>
</ul>
<p>专为云而设计的分布式数据库，通过 [TiDB Operator](<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb-in-">https://docs.pingcap.com/zh/tidb-in-</a><br>kubernetes&#x2F;stable&#x2F;tidb-operator-overview) 可在公有云、私有云、混合云中实现部署工具化、自动化。</p>
<ul>
<li>兼容 MySQL 5.7 协议和 MySQL 生态</li>
</ul>
<p>兼容 MySQL 5.7 协议、MySQL 常用的功能、MySQL 生态，应用无需或者修改少量代码即可从 MySQL 迁移到<br>TiDB。提供丰富的[数据迁移工具](<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/ecosystem-tool-">https://docs.pingcap.com/zh/tidb/stable/ecosystem-tool-</a><br>user-guide)帮助应用便捷完成数据迁移。</p>
<h3 id="四大核心应用场景"><a href="#四大核心应用场景" class="headerlink" title="四大核心应用场景"></a>四大核心应用场景</h3><ul>
<li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</li>
</ul>
<p>众所周知，金融行业对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高。传统的解决方案是同城两个机房提供服务、异地一个机房提供数据容灾能力但不提供服务，此解决方案存在以下缺点：资源利用率低、维护成本高、RTO<br>(Recovery Time Objective) 及 RPO (Recovery Point Objective) 无法真实达到企业所期望的值。TiDB<br>采用多副本 + Multi-Raft 协议的方式将数据调度到不同的机房、机架、机器，当部分机器出现故障时系统可自动进行切换，确保系统的 RTO &lt;&#x3D; 30s<br>及 RPO &#x3D; 0。</p>
<ul>
<li>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</li>
</ul>
<p>随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL<br>数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB<br>采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p>
<ul>
<li>Real-time HTAP 场景</li>
</ul>
<p>随着 5G、物联网、人工智能的高速发展，企业所生产的数据会越来越多，其规模可能达到数百 TB 甚至 PB 级别，传统的解决方案是通过 OLTP<br>型数据库处理在线联机交易业务，通过 ETL 工具将数据同步到 OLAP 型数据库进行数据分析，这种处理方案存在存储成本高、实时性差等多方面的问题。TiDB<br>在 4.0 版本中引入列存储引擎 TiFlash 结合行存储引擎 TiKV 构建真正的 HTAP<br>数据库，在增加少量存储成本的情况下，可以在同一个系统中做联机交易处理、实时数据分析，极大地节省企业的成本。</p>
<ul>
<li>数据汇聚、二次加工处理的场景</li>
</ul>
<p>当前绝大部分企业的业务数据都分散在不同的系统中，没有一个统一的汇总，随着业务的发展，企业的决策层需要了解整个公司的业务状况以便及时做出决策，故需要将分散在各个系统的数据汇聚在同一个系统并进行二次加工处理生成<br>T+0 或 T+1 的报表。传统常见的解决方案是采用 ETL + Hadoop 来完成，但 Hadoop<br>体系太复杂，运维、存储成本太高无法满足用户的需求。与 Hadoop 相比，TiDB 就简单得多，业务通过 ETL 工具或者 TiDB 的同步工具将数据同步到<br>TiDB，在 TiDB 中可通过 SQL 直接生成报表。</p>
<h2 id="TiDB整体架构"><a href="#TiDB整体架构" class="headerlink" title="TiDB整体架构"></a>TiDB整体架构</h2><p>在内核设计上，TiDB 分布式数据库将整体架构拆分成了多个模块，各模块之间互相通信，组成完整的 TiDB 系统。对应的架构图如下：</p>
<p>![architecture](<a target="_blank" rel="noopener" href="https://download.pingcap.com/images/docs-cn/tidb-">https://download.pingcap.com/images/docs-cn/tidb-</a><br>architecture-v6.png)</p>
<ul>
<li>TiDB Server：SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。TiDB 层本身是无状态的，实践中可以启动多个 TiDB 实例，通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址，客户端的连接可以均匀地分摊在多个 TiDB 实例上以达到负载均衡的效果。TiDB Server 本身并不存储数据，只是解析 SQL，将实际的数据读取请求转发给底层的存储节点 TiKV（或 TiFlash）。</li>
<li>PD (Placement Driver) Server：整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</li>
<li>存储节点<ul>
<li>TiKV Server：负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别，这也是 TiDB 在 SQL 层面支持分布式事务的核心。TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。另外，TiKV 中的数据都会自动维护多副本（默认为三副本），天然支持高可用和自动故障转移。</li>
<li>TiFlash：TiFlash 是一类特殊的存储节点。和普通 TiKV 节点不一样的是，在 TiFlash 内部，数据是以列式的形式进行存储，主要的功能是为分析型的场景加速。</li>
</ul>
</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="Key-Value-Pairs-键值对"><a href="#Key-Value-Pairs-键值对" class="headerlink" title="Key-Value Pairs (键值对)"></a>Key-Value Pairs (键值对)</h4><p>作为保存数据的系统，首先要决定的是数据的存储模型，也就是数据以什么样的形式保存下来。TiKV 的选择是 Key-Value 模型，并且提供有序遍历方法。<br>TiKV 数据存储的两个关键点：</p>
<ol>
<li>这是一个巨大的 Map（可以类比一下 C++ 的 std::map），也就是存储的是 Key-Value Pairs（键值对）</li>
<li>这个 Map 中的 Key-Value pair 按照 Key 的二进制顺序有序，也就是可以 Seek 到某一个 Key 的位置，然后不断地调用 Next 方法以递增的顺序获取比这个 Key 大的 Key-Value。</li>
</ol>
<p>有人可能会问，这里讲的存储模型和 SQL 中表是什么关系？在这里有一件重要的事情需要强调：</p>
<p><strong>TiKV 的 KV 存储模型和 SQL 中的 Table 无关！</strong></p>
<p>现在让我们忘记 SQL 中的任何概念，专注于讨论如何实现 TiKV 这样一个高性能、高可靠性、分布式的 Key-Value 存储。</p>
<h4 id="本地存储（RocksDB）"><a href="#本地存储（RocksDB）" class="headerlink" title="本地存储（RocksDB）"></a>本地存储（RocksDB）</h4><p>任何持久化的存储引擎，数据终归要保存在磁盘上，TiKV 也不例外。但是 TiKV 没有选择直接向磁盘上写数据，而是把数据保存在 RocksDB<br>中，具体的数据落地由 RocksDB 负责。这个选择的原因是开发一个单机存储引擎工作量很大，特别是要做一个高性能的单机引擎，需要做各种细致的优化，而<br>RocksDB 是由 Facebook 开源的一个非常优秀的单机 KV 存储引擎，可以满足 TiKV 对单机引擎的各种要求。这里可以简单的认为<br>RocksDB 是一个单机的持久化 Key-Value Map。</p>
<h4 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h4><p>接下来 TiKV 的实现面临一件更难的事情：如何保证单机失效的情况下，数据不丢失，不出错？</p>
<p>简单来说，需要想办法把数据复制到多台机器上，这样一台机器挂了，其他的机器上的副本还能提供服务；<br>复杂来说，还需要这个数据复制方案是可靠和高效的，并且能处理副本失效的情况。TiKV 选择了 Raft 算法。Raft 是一个一致性协议，它和 Multi<br>Paxos 实现一样的功能，但是更加易于理解。<a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">这里</a> 是 Raft<br>的论文，感兴趣的可以看一下。下面对 Raft 做一个简要的介绍，细节问题可以参考论文。 Raft 提供几个重要的功能：</p>
<ol>
<li>Leader（主副本）选举</li>
<li>成员变更（如添加副本、删除副本、转移 Leader 等操作）</li>
<li>日志复制</li>
</ol>
<p>TiKV 利用 Raft 来做数据复制，每个数据变更都会落地为一条 Raft 日志，通过 Raft<br>的日志复制功能，将数据安全可靠地同步到复制组的每一个节点中。不过在实际写入中，根据 Raft 的协议，只需要同步复制到多数节点，即可安全地认为数据写入成功。</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/1.png" alt="1.png"></p>
<p>总结一下，通过单机的 RocksDB，TiKV 可以将数据快速地存储在磁盘上；通过 Raft，将数据复制到多台机器上，以防单机失效。数据的写入是通过<br>Raft 这一层的接口写入，而不是直接写 RocksDB。通过实现 Raft，TiKV 变成了一个分布式的 Key-Value<br>存储，少数几台机器宕机也能通过原生的 Raft 协议自动把副本补全，可以做到对业务无感知。</p>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>讲到这里，我们需要提到一个非常重要的概念：Region。这个概念是理解后续一系列机制的基础，请仔细阅读这一小节。 前面提到，我们将 TiKV<br>看做一个巨大的有序的 KV Map，那么为了实现存储的水平扩展，我们需要将数据分散在多台机器上。这里提到的数据分散在多台机器上和 Raft<br>的数据复制不是一个概念，在这一节我们先忘记 Raft，假设所有的数据都只有一个副本，这样更容易理解。 对于一个 KV<br>系统，将数据分散在多台机器上有两种比较典型的方案：</p>
<ul>
<li>Hash：按照 Key 做 Hash，根据 Hash 值选择对应的存储节点</li>
<li>Range：按照 Key 分 Range，某一段连续的 Key 都保存在一个存储节点上</li>
</ul>
<p>TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，将每一段叫做一个 Region，并且会尽量保持每个<br>Region 中保存的数据不超过一定的大小，目前在 TiKV 中默认是 96MB。每一个 Region 都可以用 [StartKey，EndKey)<br>这样一个左闭右开区间来描述。</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/2.png" alt="2.png"></p>
<p>注意，这里的 Region 还是和 SQL 中的表没什么关系！ 请各位继续忘记 SQL，只谈 KV。 将数据划分成 Region 后，TiKV<br>将会做两件重要的事情：</p>
<ul>
<li>以 Region 为单位，将数据分散在集群中所有的节点上，并且尽量保证每个节点上服务的 Region 数量差不多</li>
<li>以 Region 为单位做 Raft 的复制和成员管理</li>
</ul>
<p>这两点非常重要，我们一点一点来说。 先看第一点，数据按照 Key 切分成很多 Region，每个 Region<br>的数据只会保存在一个节点上面（暂不考虑多副本）。TiDB 系统会有一个组件（PD）来负责将 Region<br>尽可能均匀的散布在集群中所有的节点上，这样一方面实现了存储容量的水平扩展（增加新的节点后，会自动将其他节点上的 Region<br>调度过来），另一方面也实现了负载均衡（不会出现某个节点有很多数据，其他节点上没什么数据的情况）。同时为了保证上层客户端能够访问所需要的数据，系统中也会有一个组件（PD）记录<br>Region 在节点上面的分布情况，也就是通过任意一个 Key 就能查询到这个 Key 在哪个 Region 中，以及这个 Region<br>目前在哪个节点上（即 Key 的位置路由信息）。至于负责这两项重要工作的组件（PD），会在后续介绍。</p>
<p>对于第二点，TiKV 是以 Region 为单位做数据的复制，也就是一个 Region 的数据会保存多个副本，TiKV 将每一个副本叫做一个<br>Replica。Replica 之间是通过 Raft 来保持数据的一致，一个 Region 的多个 Replica 会保存在不同的节点上，构成一个 Raft<br>Group。其中一个 Replica 会作为这个 Group 的 Leader，其他的 Replica 作为 Follower。所有的读和写都是通过<br>Leader 进行，读操作在 Leader 上即可完成，而写操作再由 Leader 复制给 Follower。 大家理解了 Region<br>之后，应该可以理解下面这张图：</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/3.png" alt="3.png"></p>
<p>以 Region 为单位做数据的分散和复制，就有了一个分布式的具备一定容灾能力的 KeyValue<br>系统，不用再担心数据存不下，或者是磁盘故障丢失数据的问题。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>很多数据库都会实现多版本并发控制（MVCC），TiKV 也不例外。设想这样的场景，两个客户端同时去修改一个 Key 的<br>Value，如果没有数据的多版本控制，就需要对数据上锁，在分布式场景下，可能会带来性能以及死锁问题。 TiKV 的 MVCC 实现是通过在 Key<br>后面添加版本号来实现，简单来说，没有 MVCC 之前，可以把 TiKV 看做这样的：</p>
<pre><code>Key1 -&gt; Value  
Key2 -&gt; Value  
……  
KeyN -&gt; Value  
  
</code></pre>
<p>有了 MVCC 之后，TiKV 的 Key 排列是这样的：</p>
<pre><code>Key1_Version3 -&gt; Value  
Key1_Version2 -&gt; Value  
Key1_Version1 -&gt; Value  
……  
Key2_Version4 -&gt; Value  
Key2_Version3 -&gt; Value  
Key2_Version2 -&gt; Value  
Key2_Version1 -&gt; Value  
……  
KeyN_Version2 -&gt; Value  
KeyN_Version1 -&gt; Value  
……  
  
</code></pre>
<p>注意，对于同一个 Key 的多个版本，我们把版本号较大的放在前面，版本号小的放在后面（回忆一下 Key-Value 一节我们介绍过的 Key<br>是有序的排列），这样当用户通过一个 Key + Version 来获取 Value 的时候，可以通过 Key 和 Version 构造出 MVCC 的<br>Key，也就是 Key_Version。然后可以直接通过 RocksDB 的 SeekPrefix(Key_Version)<br>API，定位到第一个大于等于这个 Key_Version 的位置。</p>
<h4 id="分布式-ACID-事务"><a href="#分布式-ACID-事务" class="headerlink" title="分布式 ACID 事务"></a>分布式 ACID 事务</h4><p>TiKV 的事务采用的是 Google 在 BigTable<br>中使用的事务模型：<a target="_blank" rel="noopener" href="https://research.google.com/pubs/pub36726.html">Percolator</a>，TiKV<br>根据这篇论文实现，并做了大量的优化。这个在后续的章节中会有详细的介绍。</p>
<p>在 TiKV 层的事务 API 的语义类似下面的伪代码：</p>
<pre><code>tx = tikv.Begin()  
    tx.Set(Key1, Value1)  
    tx.Set(Key2, Value2)  
    tx.Set(Key3, Value3)  
tx.Commit()  
  
</code></pre>
<p>这个事务中包含3条 Set 操作，TiKV 能保证这些操作要么全部成功，要么全部失败，不会出现中间状态或脏数据。 就如前面提到的，TiDB 的 SQL<br>层会将 SQL 的执行计划转换成多个 KV 操作，对于上层的同一个业务层的 SQL 事务，在底层也是对应一个 KV 层的事务，这是 TiDB 实现<br>MySQL 的事务语义的关键。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="表数据与-Key-Value-的映射关系"><a href="#表数据与-Key-Value-的映射关系" class="headerlink" title="表数据与 Key-Value 的映射关系"></a>表数据与 Key-Value 的映射关系</h4><p>本小节介绍 TiDB 中数据到 (Key, Value) 键值对的映射方案。这里的数据主要包括以下两个方面：</p>
<ul>
<li>表中每一行的数据，以下简称表数据</li>
<li>表中所有索引的数据，以下简称索引数据</li>
</ul>
<h4 id="表数据与-Key-Value-的映射关系-1"><a href="#表数据与-Key-Value-的映射关系-1" class="headerlink" title="表数据与 Key-Value 的映射关系"></a>表数据与 Key-Value 的映射关系</h4><p>在关系型数据库中，一个表可能有很多列。要将一行中各列数据映射成一个 (Key, Value) 键值对，需要考虑如何构造 Key。首先，OLTP<br>场景下有大量针对单行或者多行的增、删、改、查等操作，要求数据库具备快速读取一行数据的能力。因此，对应的 Key 最好有一个唯一 ID（显示或隐式的<br>ID），以方便快速定位。其次，很多 OLAP 型查询需要进行全表扫描。如果能够将一个表中所有行的 Key<br>编码到一个区间内，就可以通过范围查询高效完成全表扫描的任务。</p>
<p>基于上述考虑，TiDB 中的表数据与 Key-Value 的映射关系作了如下设计：</p>
<ul>
<li>为了保证同一个表的数据放在一起，方便查找，TiDB 会为每个表分配一个表 ID，用 <code>TableID</code> 表示。表 ID 是一个整数，在整个集群内唯一。</li>
<li>TiDB 会为表中每行数据分配一个行 ID，用 <code>RowID</code> 表示。行 ID 也是一个整数，在表内唯一。对于行 ID，TiDB 做了一个小优化，如果某个表有整数型的主键，TiDB 会使用主键的值当做这一行数据的行 ID。</li>
</ul>
<p>每行数据按照如下规则编码成 (Key, Value) 键值对：</p>
<pre><code>Key:   tablePrefix&#123;TableID&#125;_recordPrefixSep&#123;RowID&#125;  
Value: [col1, col2, col3, col4]  
  
</code></pre>
<p>其中 <code>tablePrefix</code> 和 <code>recordPrefixSep</code> 都是特定的字符串常量，用于在 Key<br>空间内区分其他数据。其具体值在后面的小结中给出。</p>
<h4 id="索引数据和-Key-Value-的映射关系"><a href="#索引数据和-Key-Value-的映射关系" class="headerlink" title="索引数据和 Key-Value 的映射关系"></a>索引数据和 Key-Value 的映射关系</h4><p>TiDB 同时支持主键和二级索引（包括唯一索引和非唯一索引）。与表数据映射方案类似，TiDB 为表中每个索引分配了一个索引 ID，用 <code>IndexID</code><br>表示。</p>
<p>对于主键和唯一索引，需要根据键值快速定位到对应的 RowID，因此，按照如下规则编码成 (Key, Value) 键值对：</p>
<pre><code>Key:   tablePrefix&#123;tableID&#125;_indexPrefixSep&#123;indexID&#125;_indexedColumnsValue  
Value: RowID  
  
</code></pre>
<p>对于不需要满足唯一性约束的普通二级索引，一个键值可能对应多行，需要根据键值范围查询对应的 RowID。因此，按照如下规则编码成 (Key, Value)<br>键值对：</p>
<pre><code>Key:   tablePrefix&#123;TableID&#125;_indexPrefixSep&#123;IndexID&#125;_indexedColumnsValue_&#123;RowID&#125;  
Value: null  
  
</code></pre>
<h4 id="映射关系小结"><a href="#映射关系小结" class="headerlink" title="映射关系小结"></a>映射关系小结</h4><p>上述所有编码规则中的 <code>tablePrefix</code>、<code>recordPrefixSep</code> 和 <code>indexPrefixSep</code> 都是字符串常量，用于在 Key<br>空间内区分其他数据，定义如下：</p>
<pre><code>tablePrefix     = []byte&#123;&#39;t&#39;&#125;  
recordPrefixSep = []byte&#123;&#39;r&#39;&#125;  
indexPrefixSep  = []byte&#123;&#39;i&#39;&#125;  
  
</code></pre>
<p>另外请注意，上述方案中，无论是表数据还是索引数据的 Key 编码方案，一个表内所有的行都有相同的 Key<br>前缀，一个索引的所有数据也都有相同的前缀。这样具有相同的前缀的数据，在 TiKV 的 Key<br>空间内，是排列在一起的。因此只要小心地设计后缀部分的编码方案，保证编码前和编码后的比较关系不变，就可以将表数据或者索引数据有序地保存在 TiKV<br>中。采用这种编码后，一个表的所有行数据会按照 <code>RowID</code> 顺序地排列在 TiKV 的 Key<br>空间中，某一个索引的数据也会按照索引数据的具体的值（编码方案中的 <code>indexedColumnsValue</code>）顺序地排列在 Key 空间内。</p>
<h4 id="Key-Value-映射关系示例"><a href="#Key-Value-映射关系示例" class="headerlink" title="Key-Value 映射关系示例"></a>Key-Value 映射关系示例</h4><p>最后通过一个简单的例子，来理解 TiDB 的 Key-Value 映射关系。假设 TiDB 中有如下这个表：</p>
<pre><code>CREATE TABLE User (  
    ID int,  
    Name varchar(20),  
    Role varchar(20),  
    Age int,  
    PRIMARY KEY (ID),  
    KEY idxAge (Age)  
);  
</code></pre>
<p>假设该表中有 3 行数据：</p>
<pre><code>1, &quot;TiDB&quot;, &quot;SQL Layer&quot;, 10  
2, &quot;TiKV&quot;, &quot;KV Engine&quot;, 20  
3, &quot;PD&quot;, &quot;Manager&quot;, 30  
  
</code></pre>
<p>首先每行数据都会映射为一个 (Key, Value) 键值对，同时该表有一个 <code>int</code> 类型的主键，所以 <code>RowID</code> 的值即为该主键的值。假设该表的<br><code>TableID</code> 为 10，则其存储在 TiKV 上的表数据为：</p>
<pre><code>t10_r1 --&gt; [&quot;TiDB&quot;, &quot;SQL Layer&quot;, 10]  
t10_r2 --&gt; [&quot;TiKV&quot;, &quot;KV Engine&quot;, 20]  
t10_r3 --&gt; [&quot;PD&quot;, &quot;Manager&quot;, 30]  
</code></pre>
<p>除了主键外，该表还有一个非唯一的普通二级索引 <code>idxAge</code>，假设这个索引的 <code>IndexID</code> 为 1，则其存储在 TiKV 上的索引数据为：</p>
<pre><code>t10_i1_10_1 --&gt; null  
t10_i1_20_2 --&gt; null  
t10_i1_30_3 --&gt; null  
  
</code></pre>
<p>以上例子展示了 TiDB 中关系模型到 Key-Value 模型的映射规则，以及选择该方案背后的考量。</p>
<h4 id="元信息管理"><a href="#元信息管理" class="headerlink" title="元信息管理"></a>元信息管理</h4><p>TiDB 中每个 <code>Database</code> 和 <code>Table</code> 都有元信息，也就是其定义以及各项属性。这些信息也需要持久化，TiDB 将这些信息也存储在了<br>TiKV 中。</p>
<p>每个 <code>Database</code>&#x2F;<code>Table</code> 都被分配了一个唯一的 ID，这个 ID 作为唯一标识，并且在编码为 Key-Value 时，这个 ID<br>都会编码到 Key 中，再加上 <code>m_</code> 前缀。这样可以构造出一个 Key，Value 中存储的是序列化后的元信息。</p>
<p>除此之外，TiDB 还用一个专门的 (Key, Value) 键值对存储当前所有表结构信息的最新版本号。这个键值对是全局的，每次 DDL<br>操作的状态改变时其版本号都会加 1。目前，TiDB 把这个键值对持久化存储在 PD Server 中，其 Key 是<br>“&#x2F;tidb&#x2F;ddl&#x2F;global_schema_version”，Value 是类型为 int64 的版本号值。TiDB 采用 Online Schema<br>变更算法，有一个后台线程在不断地检查 PD Server 中存储的表结构信息的版本号是否发生变化，并且保证在一定时间内一定能够获取版本的变化。</p>
<h4 id="SQL-层简介"><a href="#SQL-层简介" class="headerlink" title="SQL 层简介"></a>SQL 层简介</h4><p>TiDB 的 SQL 层，即 TiDB Server，负责将 SQL 翻译成 Key-Value 操作，将其转发给共用的分布式 Key-Value 存储层<br>TiKV，然后组装 TiKV 返回的结果，最终将查询结果返回给客户端。</p>
<p>这一层的节点都是无状态的，节点本身并不存储数据，节点之间完全对等。</p>
<h4 id="SQL-运算"><a href="#SQL-运算" class="headerlink" title="SQL 运算"></a>SQL 运算</h4><p>最简单的方案就是通过上一节所述的[表数据与 Key-Value<br>的映射关系](<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tidb-">https://docs.pingcap.com/zh/tidb/stable/tidb-</a><br>computing#%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%8E-key-<br>value-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB)方案，将 SQL 查询映射为对 KV 的查询，再通过<br>KV 接口获取对应的数据，最后执行各种计算。</p>
<p>比如 <code>select count(*) from user where name = &quot;TiDB&quot;</code> 这样一个 SQL<br>语句，它需要读取表中所有的数据，然后检查 <code>name</code> 字段是否是 <code>TiDB</code>，如果是的话，则返回这一行。具体流程如下：</p>
<ol>
<li>构造出 Key Range：一个表中所有的 <code>RowID</code> 都在 <code>[0, MaxInt64)</code> 这个范围内，使用 <code>0</code> 和 <code>MaxInt64</code> 根据行数据的 <code>Key</code> 编码规则，就能构造出一个 <code>[StartKey, EndKey)</code>的左闭右开区间。</li>
<li>扫描 Key Range：根据上面构造出的 Key Range，读取 TiKV 中的数据。</li>
<li>过滤数据：对于读到的每一行数据，计算 <code>name = &quot;TiDB&quot;</code> 这个表达式，如果为真，则向上返回这一行，否则丢弃这一行数据。</li>
<li>计算 <code>Count(*)</code>：对符合要求的每一行，累计到 <code>Count(*)</code> 的结果上面。</li>
</ol>
<p><strong>整个流程示意图如下：</strong></p>
<p>![naive sql flow](<a target="_blank" rel="noopener" href="https://download.pingcap.com/images/docs-cn/tidb-computing-">https://download.pingcap.com/images/docs-cn/tidb-computing-</a><br>native-sql-flow.jpeg)</p>
<p>这个方案是直观且可行的，但是在分布式数据库的场景下有一些显而易见的问题：</p>
<ul>
<li>在扫描数据的时候，每一行都要通过 KV 操作从 TiKV 中读取出来，至少有一次 RPC 开销，如果需要扫描的数据很多，那么这个开销会非常大。</li>
<li>并不是所有的行都满足过滤条件 <code>name = &quot;TiDB&quot;</code>，如果不满足条件，其实可以不读取出来。</li>
<li>此查询只要求返回符合要求行的数量，不要求返回这些行的值。</li>
</ul>
<h4 id="分布式-SQL-运算"><a href="#分布式-SQL-运算" class="headerlink" title="分布式 SQL 运算"></a>分布式 SQL 运算</h4><p>为了解决上述问题，计算应该需要尽量靠近存储节点，以避免大量的 RPC 调用。首先，SQL 中的谓词条件 <code>name = &quot;TiDB&quot;</code><br>应被下推到存储节点进行计算，这样只需要返回有效的行，避免无意义的网络传输。然后，聚合函数 <code>Count(*)</code><br>也可以被下推到存储节点，进行预聚合，每个节点只需要返回一个 <code>Count(*)</code> 的结果即可，再由 SQL 层将各个节点返回的 <code>Count(*)</code><br>的结果累加求和。</p>
<p>以下是数据逐层返回的示意图：</p>
<p>![dist sql flow](<a target="_blank" rel="noopener" href="https://download.pingcap.com/images/docs-cn/tidb-computing-">https://download.pingcap.com/images/docs-cn/tidb-computing-</a><br>dist-sql-flow.png)</p>
<h4 id="SQL-层架构"><a href="#SQL-层架构" class="headerlink" title="SQL 层架构"></a>SQL 层架构</h4><p>通过上面的例子，希望大家对 SQL 语句的处理有一个基本的了解。实际上 TiDB 的 SQL<br>层要复杂得多，模块以及层次非常多，下图列出了重要的模块以及调用关系：</p>
<p>![tidb sql layer](<a target="_blank" rel="noopener" href="https://download.pingcap.com/images/docs-cn/tidb-computing-">https://download.pingcap.com/images/docs-cn/tidb-computing-</a><br>tidb-sql-layer.png)</p>
<p>用户的 SQL 请求会直接或者通过 <code>Load Balancer</code> 发送到 TiDB Server，TiDB Server 会解析 <code>MySQL Protocol Packet</code>，获取请求内容，对 SQL 进行语法解析和语义分析，制定和优化查询计划，执行查询计划并获取和处理数据。数据全部存储在<br>TiKV 集群中，所以在这个过程中 TiDB Server 需要和 TiKV 交互，获取数据。最后 TiDB Server 需要将查询结果返回给用户。</p>
<h2 id="TiDB和Mysql的区别"><a href="#TiDB和Mysql的区别" class="headerlink" title="TiDB和Mysql的区别"></a>TiDB和Mysql的区别</h2><p>TiDB 作为开源 NewSQL 数据库的典型代表之一，同样支持 SQL，支持事务 ACID 特性。在通讯协议上，TiDB 选择与 MySQL<br>完全兼容，并尽可能兼容 MySQL 的语法。因此，基于 MySQL 数据库开发的系统，大多数可以平滑迁移至<br>TiDB，而几乎不用修改代码。对用户来说，迁移成本极低，过渡自然。</p>
<p>然而，仍有一些 MySQL 的特性和行为，TiDB 目前暂时不支持或表现与 MySQL 有差异。除此之外，TiDB<br>提供了一些扩展语法和功能，为用户提供更多的便利。</p>
<p>TiDB 仍处在快速发展的道路上，对 MySQL 功能和行为的支持方面，正按 [路线图](<a target="_blank" rel="noopener" href="https://pingcap.com/docs-">https://pingcap.com/docs-</a><br>cn&#x2F;stable&#x2F;roadmap&#x2F;) 的规划在前行。</p>
<h3 id="兼容策略"><a href="#兼容策略" class="headerlink" title="兼容策略"></a>兼容策略</h3><p>先从总体上概括 TiDB 和 MySQL 兼容策略，如下表：</p>
<table>
<thead>
<tr>
<th>通讯协议</th>
<th>SQL语法</th>
<th>功能和行为</th>
</tr>
</thead>
<tbody><tr>
<td>完全兼容</td>
<td>兼容绝大多数</td>
<td>兼容大多数</td>
</tr>
</tbody></table>
<p>截至 4.0 版本，TiDB 与 MySQL 的区别总结如下表：</p>
<p>| MySQL | TiDB<br>—|—|—<br>隔离级别 | 支持读未提交、读已提交、可重复读、串行化，默认为可重复读 | 乐观事务支持快照隔离，悲观事务支持快照隔离和读已提交<br>锁机制 | 悲观锁 | 乐观锁、悲观锁<br>存储过程 | 支持 | 不支持<br>触发器 | 支持 | 不支持<br>事件 | 支持 | 不支持<br>自定义函数 | 支持 | 不支持<br>窗口函数 | 支持 | 部分支持<br>JSON | 支持 | 不支持部分 MySQL 8.0 新增的函数<br>外键约束 | 支持 | 忽略外键约束<br>字符集 |  | 只支持 ascii、latin1、binary、utf8、utf8mb4<br>增加&#x2F;删除主键 | 支持 | 通过 [alter-primary-key](<a target="_blank" rel="noopener" href="https://pingcap.com/docs-">https://pingcap.com/docs-</a><br>cn&#x2F;dev&#x2F;reference&#x2F;configuration&#x2F;tidb-server&#x2F;configuration-file&#x2F;#alter-primary-<br>key) 配置开关提供<br>CREATE TABLE tblName AS SELECT stmt | 支持 | 不支持<br>CREATE TEMPORARY TABLE | 支持 | TiDB 忽略 TEMPORARY 关键字，按照普通表创建<br>DML affected rows | 支持 | 不支持<br>AutoRandom 列属性 | 不支持 | 支持<br>Sequence 序列生成器 | 不支持 | 支持  </p>
<h3 id="区别点详述及应对方案"><a href="#区别点详述及应对方案" class="headerlink" title="区别点详述及应对方案"></a>区别点详述及应对方案</h3><h4 id="字符集支持"><a href="#字符集支持" class="headerlink" title="字符集支持"></a>字符集支持</h4><p>TiDB 目前支持以下字符集：</p>
<pre><code>tidb&gt; SHOW CHARACTER SET;  
+---------|---------------|-------------------|--------+  
| Charset | Description   | Default collation | Maxlen |  
+---------|---------------|-------------------|--------+  
| utf8    | UTF-8 Unicode | utf8_bin          |      3 |  
| utf8mb4 | UTF-8 Unicode | utf8mb4_bin       |      4 |  
| ascii   | US ASCII      | ascii_bin         |      1 |  
| latin1  | Latin1        | latin1_bin        |      1 |  
| binary  | binary        | binary            |      1 |  
+---------|---------------|-------------------|--------+  
5 rows in set (0.00 sec)  
  
</code></pre>
<p>注意：TiDB 的默认字符集为 <code>utf8mb4</code>，MySQL 5.7 中为 <code>latin1</code>，MySQL 8.0 中修改为 <code>utf8mb4</code>。<br>当指定的字符集为 <code>utf8</code> 或 <code>utf8mb4</code> 时，TiDB 仅支持合法的 UTF8 字符。对于不合法的字符，会报错：<code>incorrect utf8 value</code>，该字符合法性检查与 MySQL 8.0 一致。对于 MySQL 5.7 及以下版本，会存在允许插入非法 UTF8 字符，但同步到 TiDB<br>报错的情况。此时，可以通过 TiDB 配置<br>[“tidb_skip_utf8_check”](<a target="_blank" rel="noopener" href="https://pingcap.com/docs/stable/faq/upgrade/#issue-3-error-1366-hy000-incorrect-">https://pingcap.com/docs/stable/faq/upgrade/#issue-3-error-1366-hy000-incorrect-</a><br>utf8-value-f09f8c80-for-column-a) 跳过 UTF8 字符合法性检查强制写入 TiDB。</p>
<p>每一个字符集，都有一个默认的 Collation，例如 <code>utf8</code> 的默认 Collation 为 <code>utf8_bin</code>，TiDB 中字符集的默认<br>Collation 与 MySQL 不一致，具体如下：</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th>TiDB 默认 Collation</th>
<th>MySQL 5.7 默认 Collation</th>
<th>MySQL 8.0 默认 Collation</th>
</tr>
</thead>
<tbody><tr>
<td>utf8</td>
<td>utf8_bin</td>
<td>utf8_general_ci</td>
<td>utf8_general_ci</td>
</tr>
<tr>
<td>utf8mb4</td>
<td>utf8mb4_bin</td>
<td>utf8mb4_general_ci</td>
<td>utf8mb4_0900_ai_ci</td>
</tr>
<tr>
<td>ascii</td>
<td>ascii_bin</td>
<td>ascii_general_ci</td>
<td>ascii_general_ci</td>
</tr>
<tr>
<td>latin1</td>
<td>latin1_bin</td>
<td>latin1_swedish_ci</td>
<td>latin1_swedish_ci</td>
</tr>
<tr>
<td>binary</td>
<td>binary</td>
<td>binary</td>
<td>binary</td>
</tr>
</tbody></table>
<p>在 4.0 版本之前，TiDB 中可以任意指定字符集对应的所有 Collation，并把它们按照默认 Collation<br>处理，即以编码字节序为字符定序。同时，并未像 MySQL 一样，在比较前按照 Collation 的 <code>PADDING</code><br>属性将字符补齐空格。因此，会造成以下的行为区别：</p>
<pre><code>tidb&gt; create table t(a varchar(20) charset utf8mb4 collate utf8mb4_general_ci primary key);  
Query OK, 0 rows affected  
tidb&gt; insert into t values (&#39;A&#39;);  
Query OK, 1 row affected  
tidb&gt; insert into t values (&#39;a&#39;);  
Query OK, 1 row affected // MySQL 中，由于 utf8mb4_general_ci 大小写不敏感，报错 Duplicate entry &#39;a&#39;.  
tidb&gt; insert into t1 values (&#39;a &#39;);  
Query OK, 1 row affected // MySQL 中，由于补齐空格比较，报错 Duplicate entry &#39;a &#39;  
</code></pre>
<p>TiDB 4.0 新增了完整的 Collation 支持框架，允许实现所有 MySQL 中的 Collation，并新增了配置开关<br><code>new_collation_enabled_on_first_boostrap</code>，在集群初次初始化时决定是否启用新 Collation<br>框架。在该配置开关打开之后初始化集群，可以通过 <code>mysql</code>.<code>tidb</code> 表中的 <code>new_collation_enabled</code> 变量确认新<br>Collation 是否启用：</p>
<pre><code>tidb&gt; select VARIABLE_VALUE from mysql.tidb where VARIABLE_NAME=&#39;new_collation_enabled&#39;;  
+----------------+  
| VARIABLE_VALUE |  
+----------------+  
| True           |  
+----------------+  
1 row in set (0.00 sec)  
</code></pre>
<p>在新 Collation 启用后，TiDB 修正了 <code>utf8mb4_general_bin</code> 和 <code>utf8_general_bin</code> 的<br><code>PADDING</code> 行为，会将字符串补齐空格后比较；同时支持了 <code>utf8mb4_general_ci</code> 和 <code>utf8_general_ci</code>，这两个<br>Collation 与 MySQL 保持兼容。</p>
<h4 id="系统时区"><a href="#系统时区" class="headerlink" title="系统时区"></a>系统时区</h4><p>在 MySQL 中，系统时区 <code>system_time_zone</code> 在 MySQL 服务启动时通过 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">环境变量 <code>TZ</code> 或命令行参数<br><code>--timezone</code></a><br>指定。</p>
<p>对于 TiDB 而言，作为一个分布式数据库，TiDB 需要保证整个集群的系统时区始终一致。因此 TiDB 的系统时区在集群初始化时，由负责初始化的 TiDB<br>节点环境变量 <code>TZ</code> 决定。集群初始化后，固定在集群状态表 <code>mysql</code>.<code>tidb</code> 中：</p>
<pre><code>tidb&gt; select VARIABLE_VALUE from mysql.tidb where VARIABLE_NAME=&#39;system_tz&#39;;  
+----------------+  
| VARIABLE_VALUE |  
+----------------+  
| Asia/Shanghai  |  
+----------------+  
1 row in set (0.00 sec)  
  
</code></pre>
<p>通过查看 <code>system_time_zone</code> 变量，可以看到该值与状态表中的 <code>system_tz</code> 保持一致：</p>
<pre><code>tidb&gt; select @@system_time_zone;  
+--------------------+  
| @@system_time_zone |  
+--------------------+  
| Asia/Shanghai      |  
+--------------------+  
1 row in set (0.00 sec)  
</code></pre>
<p>请注意，这意味着 TiDB 的系统时区在初始化后不再更改。若需要改变集群的时区，可以显式指定 <code>time_zone</code> 系统变量，例如：</p>
<pre><code>tidb&gt; set @@global.time_zone=&#39;UTC&#39;;  
Query OK, 0 rows affected (0.00 sec)  
</code></pre>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="乐观事务"><a href="#乐观事务" class="headerlink" title="乐观事务"></a>乐观事务</h3><p>事务是数据库的基础，提供高效的、支持完整 ACID 的分布式事务更是分布式数据库的立足之本。本章节会首先介绍事务的基本概念，然后介绍 TiDB 基于<br>Percolator 实现的乐观事务以及在使用上的最佳实践。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>对用户来说，最友好的并发事务执行顺序为每个事务独占整个数据库，并发事务执行的结果与一个个串行执行相同，也就是串行化，能够避免所有的异常情况。但在这种隔离级别下，并发执行的事务性能较差，提供更弱保证的隔离级别能够显著提升系统的性能。根据允许出现的异常，SQL-92<br>标准定义了 4 种隔离级别：读未提交 (READ UNCOMMITTED)、读已提交 (READ COMMITTED)、可重复读 (REPEATABLE<br>READ)、串行化 (SERIALIZABLE)。详见下表：</p>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Dirty Write</th>
<th>Dirty Read</th>
<th>Fuzzy Read</th>
<th>Phantom</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>Not Possible</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>Not Possible</td>
<td>Not possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>Not Possible</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Possible</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>Not Possible</td>
<td>Not possible</td>
<td>Not possible</td>
<td>Not possible</td>
</tr>
</tbody></table>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>数据库有多种并发控制方法，这里只介绍以下两种：</p>
<ul>
<li>乐观并发控制（OCC）：在事务提交阶段检测冲突</li>
<li>悲观并发控制（PCC）：在事务执行阶段检测冲突</li>
</ul>
<p>乐观并发控制期望事务间数据冲突不多，只在提交阶段检测冲突能够获取更高的性能。悲观并发控制更适合数据冲突较多的场景，能够避免乐观事务在这类场景下事务因冲突而回滚的问题，但相比乐观并发控制，在没有数据冲突的场景下，性能相对要差。</p>
<h3 id="TiDB-乐观事务实现"><a href="#TiDB-乐观事务实现" class="headerlink" title="TiDB 乐观事务实现"></a>TiDB 乐观事务实现</h3><p>TiDB 基于 Google [Percolator](<a target="_blank" rel="noopener" href="https://storage.googleapis.com/pub-tools-public-">https://storage.googleapis.com/pub-tools-public-</a><br>publication-data&#x2F;pdf&#x2F;36726.pdf) 实现了支持完整 ACID、基于快照隔离级别（Snapshot<br>Isolation）的分布式乐观事务。TiDB 乐观事务需要将事务的所有修改都保存在内存中，直到提交时才会写入 TiKV 并检测冲突。</p>
<h4 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h4><p>Percolator 使用多版本并发控制（MVCC）来实现快照隔离级别，与可重复读的区别在于整个事务是在一个一致的快照上执行。TiDB 使用<br><a target="_blank" rel="noopener" href="https://github.com/pingcap/pd">PD</a> 作为全局授时服务（TSO）来提供单调递增的版本号：</p>
<ul>
<li>事务开始时获取 start timestamp，也是快照的版本号；事务提交时获取 commit timestamp，同时也是数据的版本号</li>
<li>事务只能读到在事务 start timestamp 之前最新已提交的数据</li>
<li>事务在提交时会根据 timestamp 来检测数据冲突</li>
</ul>
<h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><p>TiDB 使用两阶段提交(Two-Phase Commit）来保证分布式事务的原子性，分为 Prewrite 和 Commit 两个阶段：</p>
<ul>
<li>Prewrite：对事务修改的每个 Key 检测冲突并写入 lock 防止其他事务修改。对于每个事务，TiDB 会从涉及到改动的所有 Key 中选中一个作为当前事务的 Primary Key，事务提交或回滚都需要先修改 Primary Key，以它的提交与否作为整个事务执行结果的标识。</li>
<li>Commit：Prewrite 全部成功后，先同步提交 Primary Key，成功后事务提交成功，其他 Secondary Keys 会异步提交。</li>
</ul>
<p>Percolator<br>将事务的所有状态都保存在底层支持高可用、强一致性的存储系统中，从而弱化了传统两阶段提交中协调者（Coordinator）的作用，所有的客户端都可以根据存储系统中的事务状态对事务进行提交或回滚。</p>
<h4 id="两阶段提交过程"><a href="#两阶段提交过程" class="headerlink" title="两阶段提交过程"></a>两阶段提交过程</h4><p>事务的两阶段提交过程如下：</p>
<p><img src="https://book.tidb.io/res/session1/chapter6/optimistic-txn/1.png" alt="1.png"></p>
<ol>
<li><p>客户端开始一个事务。</p>
</li>
<li><p>TiDB 向 PD 获取 tso 作为当前事务的 start timestamp。</p>
</li>
<li><p>客户端发起读或写请求。</p>
</li>
<li><p>客户端发起 Commit。</p>
</li>
<li><p>TiDB 开始 <strong>两阶段提交</strong> ，保证分布式事务的原子性，让数据真正落盘。</p>
</li>
</ol>
<p>i. TiDB 从当前要写入的数据中选择一个 Key 作为当前事务的 Primary Key。</p>
<p>ii. TiDB 并发地向所有涉及的 TiKV 发起 Prewrite 请求。TiKV 收到 Prewrite<br>请求后，检查数据版本信息是否存在冲突，符合条件的数据会被加锁。</p>
<p>iii. TiDB 收到所有 Prewrite 响应且所有 Prewrite 都成功。</p>
<p>iv. TiDB 向 PD 获取第二个全局唯一递增版本号，定义为本次事务的 commit timestamp。</p>
<p>v. TiDB 向 Primary Key 所在 TiKV 发起第二阶段提交。TiKV 收到 Commit 操作后，检查锁是否存在并清理 Prewrite<br>阶段留下的锁。</p>
<ol start="6">
<li><p>TiDB 向客户端返回事务提交成功的信息。</p>
</li>
<li><p>TiDB 异步清理本次事务遗留的锁信息。</p>
</li>
</ol>
<h3 id="悲观事务"><a href="#悲观事务" class="headerlink" title="悲观事务"></a>悲观事务</h3><p>乐观事务模型在分布式系统中有着极大的性能优势，但为了让 TiDB 的使用方式更加贴近传统单机数据库，更好的适配用户场景，TiDB v3.0<br>及之后版本在乐观事务模型的基础上实现了悲观事务模型。本文将介绍 TiDB 悲观事务模型特点。</p>
<h4 id="悲观锁解决的问题"><a href="#悲观锁解决的问题" class="headerlink" title="悲观锁解决的问题"></a>悲观锁解决的问题</h4><p>通过支持悲观事务，降低用户修改代码的难度甚至不用修改代码：</p>
<ul>
<li>在 v3.0.8 之前，TiDB 默认使用的乐观事务模式会导致事务提交时因为冲突而失败。为了保证事务的成功率，需要修改应用程序，加上重试的逻辑。</li>
<li>乐观事务模型在冲突严重的场景和重试代价大的场景无法满足用户需求，支持悲观事务可以 弥补这方面的缺陷，拓展 TiDB 的应用场景。</li>
</ul>
<p>以发工资场景为例：对于一个用人单位来说，发工资的过程其实就是从企业账户给多个员工的个人账户转账的过程，一般来说都是批量操作，在一个大的转账事务中可能涉及到成千上万的更新，想象一下如果这个大事务执行的这段时间内，某个个人账户发生了消费（变更），如果这个大事务是乐观事务模型，提交的时候肯定要回滚，涉及上万个个人账户发生消费是大概率事件，如果不做任何处理，最坏的情况是这个大事务永远没办法执行，一直在重试和回滚（饥饿）。</p>
<h4 id="基于-Percolator-的悲观事务"><a href="#基于-Percolator-的悲观事务" class="headerlink" title="基于 Percolator 的悲观事务"></a>基于 Percolator 的悲观事务</h4><p>悲观事务在 Percolator 乐观事务基础上实现，在 Prewrite 之前增加了 Acquire Pessimistic Lock 阶段用于避免<br>Prewrite 时发生冲突：</p>
<ul>
<li>每个 DML 都会加悲观锁，锁写到 TiKV 里，同样会通过 raft 同步。</li>
<li>悲观事务在加悲观锁时检查各种约束，如 Write Conflict、key 唯一性约束等。</li>
<li>悲观锁不包含数据，只有锁，只用于防止其他事务修改相同的 Key，不会阻塞读，但 Prewrite 后会阻塞读（和 Percolator 相同，但有了大事务支持后将不会阻塞读）。</li>
<li>提交时同 Percolator，悲观锁的存在保证了 Prewrite 不会发生 Write Conflict，保证了提交一定成功。</li>
</ul>
<p><img src="https://book.tidb.io/res/session1/chapter6/pessimistic-txn/1.png" alt="1.png"></p>
<h4 id="等锁顺序"><a href="#等锁顺序" class="headerlink" title="等锁顺序"></a>等锁顺序</h4><p>TiKV 中实现了 <code>Waiter Manager</code> 用于管理等锁的事务，当悲观事务加锁遇到其他事务的锁时，将会进入 <code>Waiter Manager</code><br>中等待锁被释放，TiKV 会尽可能按照事务 start timestamp 的顺序来依次获取锁，从而避免事务间无用的竞争。</p>
<h4 id="分布式死锁检测"><a href="#分布式死锁检测" class="headerlink" title="分布式死锁检测"></a>分布式死锁检测</h4><p>在 <code>Waiter Manager</code> 中等待锁的事务间可能发生死锁，而且可能发生在不同的机器上，<code>TiDB</code> 采用分布式死锁检测来解决死锁问题：</p>
<ul>
<li>在整个 TiKV 集群中，有一个死锁检测器 leader。</li>
<li>当要等锁时，其他节点会发送检测死锁的请求给 leader。</li>
</ul>
<p><img src="https://book.tidb.io/res/session1/chapter6/pessimistic-txn/2.png" alt="2.png"></p>
<p>死锁检测器基于 Raft 实现了高可用，等锁事务也会定期发送死锁检测请求给死锁检测器的 leader，从而保证了即使之前 leader<br>宕机的情况下也能检测到死锁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/HIVE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/HIVE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Hive学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-29 22:30:00" itemprop="dateCreated datePublished" datetime="2022-12-29T22:30:00+00:00">2022-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>因为工作中用到了通过Hive从公司数据仓库拉取数据，而之前也没有接触过大数据相关知识，了解了一下Hadoop相关原理，并没有实际使用Hadoop做过什么，或者实现Hive直接功能实现，所以这篇总结可能也很皮毛</p>
<h1 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h1><p>自己了解Hive之前先读了一遍《Hadoop权威指南》，里面的基本下载启动是照着做了，不过有的代码编写没做，Hadoop的总结写到这里吧，毕竟刚入门，能总结的东西也不是很多很深入。</p>
<p><img src="/images/hadoop%E6%9E%B6%E6%9E%84.png" alt="hadoop架构"></p>
<p>我们遇到的问题很简单：在硬盘存储容量多年不断提升的同时，访问速度（硬盘数据读取速度）却没有与时俱进。1990年，一个普通硬盘可以存储1370MB的数据，传输速度为4.4MB&#x2F;S,因此只需要5分钟就可以读完整个硬盘中的数据。20年过了，1TB的硬盘已然成为主流，氮气数据传输速度为100MB&#x2F;S,读完整个硬盘中的数据至少得花2.5个小时。</p>
<p>读完整个硬盘中的数据需要更长时间。写入数据就更别提了。一个很简单的，减少读取时间的办法是同时从多个硬盘上读数据。试想，如果我们有100个硬盘。每个硬盘存储1%的数据，并行读取，那么不到两分钟就可以读完所有数据。</p>
<p>仅使用硬盘容量的1%似乎很浪费，但是我们可以存储100个数据集，每个数据集1TB。并实现共享硬盘的读取。可以想象，用户肯定很乐于通过硬盘共享来缩短数据分析时间；并且，从统计角度来看，用户的分析工作都是在不同时间点进行的，所以彼此之间的干扰并不大。</p>
<p>虽然如此，但要对多个硬盘中的数据并行进行读写数据，还有更多问题要解决。第一个需要解决的是硬件故障问题，一旦开始使用多个硬件，其中个别硬件就很有可能发生故障。为了避免数据丢失，最常用的做法是复制：系统保存数据的复本。一旦有系统发生故障，就可以使用另外保存的复本。例如，冗余硬盘阵列（RAID）就是按这个原理实现的，另外，Hadoop文件系统（HDFS，Hadoop<br>Distributed[分布式的] File System）也是一类，不过它采用的方法稍有不同，这个在后面会详细说明。</p>
<p>第二个问题是大多数分析任务需要以某种方式结合大部分数据来共同完成分析，即从一个硬盘读取的数据可能需要与从另外99个硬盘中读取的数据结合使用，各种分布式系统允许结合不同来源的数据进行分析，但保证其正确性是一个非常大的挑战。MapReduce提出一个编程模型，该模型抽象出这些硬盘读写问题并将其转化为对一个数据集（由键值对组成）的计算。后面会详细讨论这个模型，这样的计算由map和reduce两部分组成，而且只有这两部分提供对外的接口。与HDFS类似，MapReduce自身也有很高的可靠性。</p>
<p>简而言之，Hadoop为我们提供了一个可靠的共享存储和分析系统，HDFS实现数据的存储，MapReduce实现数据的分析和处理。虽然Hadoop还有其他功能，但HDFS和MapReduce是它的核心价值。</p>
<p>MapReduce看似采用一种蛮力方法。每个查询需要处理整个数据集或至少一个数据集的绝大部分。但反过来想，这也正是它的能力。MapReduce是一个批量查询处理器，能够在合理的时间范围内处理针对整个数据集的动态查询【这里指查询的内容是动态的，Hadoop并不能处理动态的数据，处理动态的数据用Spark】。它改变了我们队数据的传统看法，解放了以前只是保存在磁带和硬盘上的数据。它让我们有机会对数据进行创新。以前需要很长时间处理才能获得结果的问题，到现在变得顷刻之间就迎刃而解，同时还可以引发新的问题和新的见解。</p>
<p>1.3.1关系型数据库管理系统（简称RDBMS r&#x3D;relationnal关系 db&#x3D;database数据库 m&#x3D;management管理<br>s&#x3D;system系统）</p>
<p>为什么不能用数据库来对大量硬盘上的大规模数据进行批量分析呢？我们为什么需要MapReduce?</p>
<p>这两个问题的答案来自于计算机硬盘的另一个发展趋势，寻址时间的提升远远不低敌于传输速率的提升。寻址是将磁头移动到特定硬盘位置进行读写操作的过程。它是导致磁盘操作延迟的主要原因，而传输速率取决于硬盘的贷款。</p>
<p>如果数据访问模式中包含大量的硬盘寻址，那么读取大量数据集j就必然会花更长的时间（相较于流数据读取模式，流读取主要取决于传输速率）。另一方面，如果数据库系统只更新一小部分记录，那么传统的B树就更有优势（关系型数据库中使用的一种数据结构，受限于寻址的比例）。但数据库系统如果有大量数据更新时，B树的效率就明显落后于MapReduce，因为需要使用“排序&#x2F;合并”(sort&#x2F;merge:合并)来重建数据库。</p>
<p>在许多情况下，可以将MapReduce视为关系型数据库管理系统的补充。两个系统之间的差异如表：<br><img src="/images/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CMapReduce%E5%B7%AE%E5%BC%82.jpg" alt="关系型数据库和MapReduce差异"></p>
<p>MapReduce比较适合批处理方式处理需要分析整个数据集的问题，尤其是动态分析。RDBMS适用于点查询和更新，数据集被索引之后，数据库系统能够提供延迟的数据检索和快速的少量数据更新。MapReduce适合一次写入、多次读取数据的应用，关系型数据库则更适合持续更新的数据集。</p>
<p>MapReduce和关系型数据库之间的另一个区别在于它们所操作的数据集的机构化程度。结构化程度是具有既定格式的实体化数据，如XML文档或满足特定格式的数据库表。这是RDBMS包括的内容。另一方面，半结构化数据比较松散，虽然可能有格式，但经常被忽略，所以它只能作为对数据结构的一般性指导。例如电子表格，它在结构上是由单元格组成的网格，但是每个单元格内可以保证任何形式的数据。非结构化数据没有什么特别的内部结构，例如纯文本或图像数据。MapReduce对非结构化或半结构化数据非常有效，因为它是在处理数据时才对数据进行解释。换句话说，MapReduce输入的键和值并不是数据固有的属性，而是分析数据的人来选的。</p>
<p>关系型数据往往是规范的，以保证其数据的完整性且不含冗余。规范给MapReduce带来了问题，因为它使记录读取成为非本地操作，而MapReduce的核心假设之一偏偏就是可以进行（高速的）流读写操作。</p>
<p>Web服务器日志是典型非规范化数据记录（例如，每次都需要记录客户端主机全名，只会导致同一客户端的全名多次出现），这也是MapReduce非常适用于分析各种日志文件的原因之一。</p>
<p>MapReduce是一种线性的可伸缩编程模型。程序员要写两个函数，分别为map函数和reduce函数，每个函数定义从一个键值对集合到另一个键值对集合的映射，这些函数不必关注数据集及其所用集群的大小，可以原封不动地应用于小规模数据集或大规模的数据集。更重要的是，如果输入的数据量是原来的两倍，那么运行的时间也需要两倍，但如果集群是原来的两倍，作业的运行速度却仍然与原来一样快。SQL查询一般不具备该特性。</p>
<p>但是，在不久的将来，关系型数据库和MapReduce系统之间的差异很可能变得模糊。关系型数据库都开始吸收MapReduce的一些思路m另一方面，基于MapReduce的高级查询语言使传统数据库的程序员更容易接受MapReduce系统。</p>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>MapReduce是一种 <strong>适合处理大量数据的编程模型</strong><br>。Hadoop能够运行用各种语言编写的MapReduce程序：Java，Ruby，Python和C++。 <strong>MapReduce程序本质上是并行的</strong><br>，因此对于使用群集中的多台机器执行大规模数据分析非常有用。</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>MapReduce 处理数据过程主要分成 <strong>Map</strong> 和 <strong>Reduce</strong> 两个阶段。首先执行 Map 阶段，再执行 Reduce 阶段。Map 和<br>Reduce 的处理逻辑由用户自定义实现，但要符合 MapReduce 框架的约定。处理流程如下所示：</p>
<ol>
<li>在正式执行 Map 前，需要将输入数据进行 <strong>分片</strong> 。所谓分片，就是将输入数据切分为大小相等的数据块，每一块作为单个 Map Task 的输入被处理，以便于多个 Map Task 同时工作。</li>
<li>分片完毕后，多个 Map Task 便可同时工作。每个 Map Task 在读入各自的数据后，进行计算处理，最终输出给 Reduce。Map Task 在输出数据时，需要为每一条输出数据指定一个 Key，这个 Key 值决定了这条数据将会被发送给哪一个 Reduce Task。 <strong>Key 值和 Reduce Task 是多对一的关系</strong> ，具有相同 Key 的数据会被发送给同一个 Reduce Task，单个 Reduce Task 有可能会接收到多个 Key 值的数据。</li>
<li>在进入 Reduce 阶段之前，MapReduce 框架会对数据按照 Key 值 <strong>排序</strong> ，使得具有相同 Key 的数据彼此相邻。如果指定了 <strong>合并操作（Combiner）</strong> ，框架会调用 Combiner，它负责对中间过程的输出具有相同 Key 的数据进行本地的聚集，这会有助于降低从Mapper到 Reducer数据传输量。Combiner 的逻辑可以自定义实现。这部分的处理通常也叫做 <strong>洗牌（Shuffle）</strong> 。</li>
<li>接下来进入 Reduce 阶段。相同 Key 的数据会到达同一个 Reduce Task。同一个 Reduce Task 会接收来自多个 Map Task 的数据。每个 Reduce Task 会对 Key 相同的多个数据进行 Reduce 操作。最后，一个 Key 的多条数据经过 Reduce 的作用后，将变成一个值。</li>
</ol>
<p><img src="/images/Map%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86.jpg" alt="Map任务处理"></p>
<p><img src="/images/reduce%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86.jpg" alt="reduce任务处理"></p>
<h2 id="MapReduce运行过程的深入了解"><a href="#MapReduce运行过程的深入了解" class="headerlink" title="MapReduce运行过程的深入了解"></a>MapReduce运行过程的深入了解</h2><p>从前面的WordCount可以看出， 一个MapReduce作业经过了input,map,combine,reduce,output<br>五个阶段,其中combine阶段并不一定发生， map输出的中间结果被分发到reducer的过程被称为shuffle （数据混洗）。</p>
<h5 id="从输入到输出的状态"><a href="#从输入到输出的状态" class="headerlink" title="从输入到输出的状态"></a>从输入到输出的状态</h5><p><img src="/images/Mapreduce%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Mapreduce运行过程"></p>
<p>在shuffle阶段还会发生copy（复制）和sort（排序)。<br>在MapReduce<br>的过程中，一个作业被分成Map和Reduce计算两个阶段，它们分别由两个或者多个Map任务和Reduce任务组成，这个在前面已经说过了。Reduce任务默认会在Map任务数量完成5%后才开始启动。</p>
<p>Map任务的执行过程可概括为：</p>
<ol>
<li>首先通过用户指定的Inputformat类中的getSplits方法和next方法将输入文件切片并解析成键值对作为map函数的输入。</li>
<li>然后map函数经过处理之后输出并将中间结果交给指定的Partitioner处理，确保中间结果分发到指定的Reduce任务处理，此时如果用户指定了Combiner，将执行combine操作。</li>
<li>最后map函数将中间结果保存到本地。</li>
</ol>
<p>Reduce 任务的执行过程可概括为：</p>
<p>首先需要将已经完成的Map任务的中问结果复制到Reduce任务所在的节点，待数据复制完成后，再以key进行排序，通过排序，将所有key相同的数据交给reduce函数处理，处理完成后，结果直接输出到HDFS上。</p>
<hr>
<p>。。。这里更详细的有看到，但是没仔细看，又到了源码部分，暂时先了解这么多。</p>
<hr>
<h2 id="mapReduce的局限性"><a href="#mapReduce的局限性" class="headerlink" title="mapReduce的局限性"></a>mapReduce的局限性</h2><ol>
<li><p>从MapReduce 的特点可以看出MapReduce 的优点非常明显，但是MapReduce 也有其局限性，井不是处理海量数据的普适方法。它的局限性主要体现在以下几点：<br>MapReduce<br>的执行速度慢。一个普通的MapReduce作业一般在分钟级别完成，复杂的作业或者数据量更大的情况下，也可能花费一小时或者更多，好在离线计算对于时间远没有OLTP那么敏感。所以MapReduce<br>现在不是，以后也不会是关系型数据库的终结者。MapReduce的慢主要是由于磁盘I&#x2F;0 , MapReduce<br>作业通常都是数据密集型作业，大量的中间结果需要写到磁盘上并通过网络进行传输，这耗去了大量的时间。</p>
</li>
<li><p>MapReduce过于底层。与SQL相比，MapReduce显得过于底层。对于普通的查询，一般人是不会希望写一个map 函数和reduce函数的。对于习惯于关系型数据库的用户，或者数据分析师来说，编写map 函数和reduce 函数无疑是一件头疼的事情。好在Hive的出现，大大改善了这种状况。</p>
</li>
<li><p>不是所有算法都能用MapReduce 实现。这意味着，不是所有算法都能实现并行。例如机器学习的模型训练， 这些算法需要状态共享或者参数间有依赖，且需要集中维护和更新。</p>
</li>
</ol>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>HDFS是Hadoop项目的核心子项目，是分布式计算中数据存储管理的基础，是基于流数据模式访问和处理超大文件的需求而开发的，可以运行于廉价的商用服务器上。它所具有的高容错、高可靠性、高可扩展性、高获得性、高吞吐率等特征为海量数据提供了不怕故障的存储，为超大数据集（Large<br>Data Set）的应用处理带来了很多便利。</p>
<p>这里重点介绍其中涉及到的几个概念：（1） <strong>超大文件</strong> 。目前的hadoop集群能够存储几百TB甚至PB级的数据。（2） <strong>流式数据访问</strong><br>。HDFS的访问模式是： <strong>一次写入，多次读取</strong> ，更加关注的是读取整个数据集的整体时间。（3） <strong>商用硬件。</strong><br>HDFS集群的设备不需要多么昂贵和特殊，只要是一些日常使用的普通硬件即可，正因为如此，hdfs节点故障的可能性还是很高的，所以<br><strong>必须要有机制来处理这种单点故障</strong> ，保证数据的可靠。（4） <strong>不支持低时间延迟的数据访问</strong><br>。hdfs关心的是高数据吞吐量，不适合那些要求低时间延迟数据访问的应用。（5） <strong>单用户写入，不支持任意修改。</strong><br>hdfs的数据以读为主，只支持单个写入者，并且写操作总是以添加的形式在文末追加，不支持在任意位置进行修改。</p>
<h2 id="HDFS数据块"><a href="#HDFS数据块" class="headerlink" title="HDFS数据块"></a>HDFS数据块</h2><p>每个磁盘都有默认的数据块大小，这是文件系统进行数据读写的最小单位。这涉及到磁盘的相应知识，这里我们不多讲，后面整理一篇博客来记录一下磁盘的相应知识。</p>
<p>HDFS同样也有数据块的概念，默认一个块（block）的大小为128MB（HDFS的块这么大主要是为了最小化寻址开销），要在HDFS中存储的文件可以划分为多个分块，每个分块可以成为一个独立的存储单元。与本地磁盘不同的是，HDFS中小于一个块大小的文件并不会占据整个HDFS数据块。</p>
<p>对HDFS存储进行分块有很多好处：</p>
<ul>
<li>一个文件的大小可以大于网络中任意一个磁盘的容量，文件的块可以利用集群中的任意一个磁盘进行存储。</li>
<li>使用抽象的块，而不是整个文件作为存储单元，可以简化存储管理，使得文件的元数据可以单独管理。</li>
<li>冗余备份。数据块非常适合用于数据备份，进而可以提供数据容错能力和提高可用性。每个块可以有多个备份（默认为三个），分别保存到相互独立的机器上去，这样就可以保证单点故障不会导致数据丢失。</li>
</ul>
<h2 id="namenode和datanode"><a href="#namenode和datanode" class="headerlink" title="namenode和datanode"></a>namenode和datanode</h2><p>HDFS集群的节点分为两类：namenode和datanode，以管理节点-<br>工作节点的模式运行，即一个namenode和多个datanode，理解这两类节点对理解HDFS工作机制非常重要。</p>
<p>namenode作为管理节点，它负责整个文件系统的命名空间，并且维护着文件系统树和整棵树内所有的文件和目录，这些信息以两个文件的形式（命名空间镜像文件和编辑日志文件）永久存储在namenode<br>的本地磁盘上。除此之外，同时，namenode也记录每个文件中各个块所在的数据节点信息，但是不永久存储块的位置信息，因为块的信息可以在系统启动时重新构建。</p>
<p>datanode作为文件系统的工作节点，根据需要存储并检索数据块，定期向namenode发送他们所存储的块的列表。</p>
<p><img src="/images/nameNode%E5%92%8CdateNode.png" alt="nameNode和dateNode"></p>
<p>由此可见，namenode作为管理节点，它的地位是非同寻常的，一旦namenode宕机，那么所有文件都会丢失，因为namenode是唯一存储了元数据、文件与数据块之间对应关系的节点，所有文件信息都保存在这里，namenode毁坏后无法重建文件。因此，必须高度重视namenode的容错性。</p>
<p>为了使得namenode更加可靠，hadoop提供了两种机制：</p>
<ul>
<li><p>第一种机制是备份那些组成文件系统元数据持久状态的文件，比如：将文件系统的信息写入本地磁盘的同时，也写入一个远程挂载的网络文件系统（NFS），这些写操作实时同步并且保证原子性。</p>
</li>
<li><p>第二种机制是运行一个辅助namenode，用以保存命名空间镜像的副本，在namenode发生故障时启用。（也可以使用热备份namenode代替辅助namenode）。</p>
</li>
</ul>
<p><img src="/images/nameNode%E5%92%8CdataNode.png" alt="nameNode和dataNode"></p>
<h2 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h2><p>数据通常情况下都保存在磁盘，但是对于访问频繁的文件，其对应的数据块可能被显式的缓存到datanode的内存中，以堆外缓存的方式存在，一些计算任务（比如mapreduce）可以在缓存了数据的datanode上运行，利用块的缓存优势提高读操作的性能。</p>
<h2 id="联邦HDFS"><a href="#联邦HDFS" class="headerlink" title="联邦HDFS"></a>联邦HDFS</h2><p>namenode在内存中保存了文件系统中每个文件和每个数据块的引用关系，这意味着，当文件足够多时，namenode的内存将成为限制系统横向扩展的瓶颈。hadoop2.0引入了联邦HDFS允许系统通过添加namenode的方式实现扩展，每个namenode管理文件系统命名空间中的一部分，比如：一个namenode管理&#x2F;usr下的文件，另外一个namenode管理&#x2F;share目录下的文件。</p>
<h2 id="HDFS的高可用性"><a href="#HDFS的高可用性" class="headerlink" title="HDFS的高可用性"></a>HDFS的高可用性</h2><p>通过备份namenode存储的文件信息或者运行辅助namenode可以防止数据丢失，但是依旧没有保证了系统的高可用性。一旦namenode发生了单点失效，那么必须能够快速的启动一个拥有文件系统信息副本的新namenode，而这个过程需要以下几步：（1）将命名空间的副本映像导入内存<br>（2）重新编辑日志 （3）接收足够多来自datanode的数据块报告，从而重建起数据块与位置的对应关系。</p>
<p>上述实际上就是一个namenode的冷启动过程，但是在数据量足够大的情况下，这个冷启动可能需要30分钟以上的时间，这是无法忍受的。</p>
<p>Hadoop2.0开始，增加了对高可用性的支持。采用了双机热备份的方式。同时使用一对活动-<br>备用namenode，当活动namenode失效后，备用namenode可以迅速接管它的任务，这中间不会有任何的中断，以至于使得用户根本无法察觉。</p>
<p>为了实现这种双机热备份，HDFS架构需要作出以下几个改变：</p>
<ul>
<li>两个namenode之间要通过高可用共享存储来实现编辑日志的共享</li>
<li>datanode要同时向两个namenode发送数据块的报告信息</li>
<li>客户端要使用特定机制来处理namenode的失效问题</li>
<li>备用namenode要为活动namenode设置周期性的检查点，从中判断活动namenode是否失效</li>
</ul>
<p>HDFS系统中运行着一个故障转移控制器，管理着将活动namenode转移为备用namenode的转换过程。同时，每一个namenode也运行着一个轻量级的故障转移控制器，主要目的就是监视宿主namenode是否失效，并在失效时实现迅速切换。</p>
<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p><strong>传统mysql无法处理大数据，而大数据文件系统HDFS不能使用SQL，Hive就是一种可以用类SQL语句对大数据文件系统中的结构化数据进行操作的工具</strong></p>
<h2 id="Hive的系统架构"><a href="#Hive的系统架构" class="headerlink" title="Hive的系统架构"></a>Hive的系统架构</h2><p><img src="/images/hive%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="hive的系统架构"></p>
<ul>
<li>用户接口，包括CLI，JDBC&#x2F;ODBC，WebUI</li>
<li>metastore，Hive将元数据存储在数据库中(metastore)，目前只支持 mysql、derby(Derby引擎的缺点：一次只能打开一个会话。使用Mysql作为外置存储引擎，多用户同时访问)。Hive 中的元数据包括表名、列、分区及其属性、表的属性（是否为外部表等）、表数据所在目录等</li>
<li>Driver 解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划（plan）的生成。生成的查询计划存储在 <strong>HDFS</strong> 中，并在随后有 MapReduce 调用执行</li>
<li>Hive的数据存储在HDFS中，大部分的查询由MapReduce完成（包含 * 的查询，比如select * from tb不会生成MapReduce任务）</li>
</ul>
<h2 id="Hive和普通数据库的异同"><a href="#Hive和普通数据库的异同" class="headerlink" title="Hive和普通数据库的异同"></a>Hive和普通数据库的异同</h2><ol>
<li><strong>查询语言</strong> 。由于SQL被广泛的应用在数据仓库中，因此，专门针对Hive的特性设计了类SQL的查询语言HQL。熟悉SQL开发就很容易入手Hive开发。</li>
<li><strong>数据仓库位置</strong> 。Hive是建立在Hadoop之上的，所有Hive的数据都是存储在HDFS中的。而数据库则可以将数据保存在块设备或者本地文件系统中。</li>
<li><strong>数据格式</strong> 。 Hive中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性，列分隔符（通常为空格）、行分隔符（“\n”）以及读取文件数据的方法（Hive中默认有三个文件格式TextFile,SequenceFile以及RCFile）。由于在加载数据的过程中，不需要从用户数据格式到Hive定义的数据格式的转换，因此，Hive在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的HDFS目录中。</li>
<li><strong>数据更新</strong> 。由于Hive是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此， <strong>Hive中不支持对数据的改写和添加</strong> ，所有的数据都是在加载的时候中确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET修改数据。</li>
<li><strong>索引</strong> 。Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key建立索引。Hive要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。</li>
<li><strong>执行</strong> 。Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的（类似 select * from tbl的查询不需要MapReduce）。而数据库通常有自己的执行引擎。</li>
<li><strong>执行延迟</strong> 。Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce框架。由于MapReduce 本身具有较高的延迟，因此在利用MapReduce 执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时 候，Hive的并行计算显然能体现出优势。</li>
<li><strong>可扩展性</strong> 。由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有100台左右。</li>
<li><strong>规模</strong> 。由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在对Hive进行操作之前，首先要明白Hive数据类型有哪些。</p>
<ul>
<li>tinyint&#x2F;smallint&#x2F;int&#x2F;bigint</li>
<li>float&#x2F;double</li>
<li>boolean</li>
<li>DECIMAL －用户可以指定范围和小数点位数</li>
<li>STRING －在特定的字符集中的一个字符串序列</li>
<li>VARCHAR －在特定的字符集中的一个有最大长度限制的字符串序列</li>
<li>CHAR －在特定的字符集中的一个指定长度的字符串序列</li>
<li>BINARY －一个二进制位序列</li>
<li>结构体类型（Stuct): 使用点（.)来访问类型内部的元素。例如，有一列c，它是一个结构体类型{a INT; b INT}，字段a可以使用表达式c.a来访问。</li>
<li>Map(key-value键值对)：使用[‘元素名’]来访问元素。例如，有一个MapM，包含’group’-&gt;gid的映射，则gid的值可以使用M[‘group’]来访问。</li>
<li>数组：数组中的元素是相同的类型。可以使用[n]来访问数组元素，n是数组下标，以0开始。例如有一个数组A，有元素[‘a’,’b’,’c’]，则A[1]返回’b’。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8BKafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8BKafka/" class="post-title-link" itemprop="url">总结一下Kafka</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-28 22:10:00" itemprop="dateCreated datePublished" datetime="2022-10-28T22:10:00+00:00">2022-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础架构及术语"><a href="#基础架构及术语" class="headerlink" title="基础架构及术语"></a>基础架构及术语</h2><p>话不多说，先看图，通过这张图我们来捋一捋相关的概念及之间的关系：</p>
<p><img src="/images/Kafka%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png" alt="Kafka基础架构"></p>
<p><strong>Producer</strong> ：Producer即生产者，消息的产生者，是消息的入口。</p>
<p><strong>kafka cluster</strong> ：<br><strong>Broker</strong><br>：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个<br><strong>不重复</strong> 的编号，如图中的broker-0、broker-1等……<br><strong>Topic</strong> ：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。<br><strong>Partition</strong><br>：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！<br><strong>Replication</strong><br>:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。<br><strong>Message</strong> ：每一条发送的消息主体。</p>
<p>Leader： <strong>每个分区多个副本的“主”</strong> ， <strong>生产者发送数据的对象，以及消费者消费数据的对象都是Leader</strong> 。</p>
<p>Follower：每个分区多个副本中的“从”，实时从Leader中同步数据，保持和Leader数据的同步。Leader发生故障时，某个Follower会成为新的Leader。</p>
<p><strong>Consumer</strong> ：消费者，即消息的消费方，是消息的出口。<br><strong>Consumer Group</strong><br>：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</p>
<p><strong>Zookeeper</strong> ：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</p>
<h2 id="工作流程分析"><a href="#工作流程分析" class="headerlink" title="工作流程分析"></a>工作流程分析</h2><p>上面介绍了kafka的基础架构及基本概念，不知道大家看完有没有对kafka有个大致印象，如果对还比较懵也没关系！我们接下来再结合上面的结构图分析kafka的工作流程，最后再回来整个梳理一遍我相信你会更有收获！</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，Producer在写入数据的时候 <strong>永远的找leader</strong><br>，不会直接将数据写入follower！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：</p>
<p><img src="/images/Kafka%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE.png" alt="Kafka发送数据"></p>
<p>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证<br><strong>同一分区</strong> 内的数据是有序的！写入示意图如下：</p>
<p><img src="/images/%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E8%BF%BD%E5%8A%A0%E5%88%B0%E5%88%86%E5%8C%BA%E4%B8%AD.png" alt="每条消息追加到分区中"></p>
<p>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：<br><strong>1、 方便扩展</strong> 。因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。<br><strong>2、 提高并发</strong> 。以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</p>
<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：<br>1、 partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。<br>2、 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。<br>3、 如果既没指定partition，又没有设置key，则会轮询选出一个partition。</p>
<p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<br><strong>0</strong> 、 <strong>1</strong> 、 <strong>all</strong> 。<br>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。<br>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。<br>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</p>
<p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p>
<h3 id="数据传递语义"><a href="#数据传递语义" class="headerlink" title="数据传递语义"></a>数据传递语义</h3><ul>
<li>至少一次（AtLeastOnce）&#x3D;ACK级别设置为-1+分区副本大于等于2+ISR里应答的最小副本数量大于等于2。可以保证数据不丢失，但是不能保证数据不重复；</li>
<li>最多一次（AtMostOnce）&#x3D;ACK级别设置为0。可以保证数据不重复，但是不能保证数据不丢失。</li>
<li>精确一次（ExactlyOnce）： <strong>精确一次（ExactlyOnce）&#x3D;幂等性+至少一次（ack&#x3D;-1+分区副本数 &gt;&#x3D;2+ISR最小副本数量&gt;&#x3D;2）</strong>。对于一些非常重要的信息，比如和钱相关的数据， <strong>要求数据既不能重复也不丢失。</strong></li>
</ul>
<p>Kafka0.11版本以后，引入了一项重大特性： <strong>幂等性和事务。</strong></p>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h3><p> <strong>幂等性：就是指Producer不论向Broker发送多少次重复数据，Broker端都只会持久化一条，保证了不重复</strong></p>
<p><strong>重复数据的判断标准</strong> ：具有&lt;**PID,Partition,SeqNumber**&gt;相同主键的消息提交时，Broker只会持久化一条。其中<br><strong>PID是Kafka每次重启都会分配一个新的</strong> ； <strong>Partition表示分区号；SequenceNumber是单调自增的。</strong></p>
<p><strong>所以幂等性只能保证的是在单分区单会话内不重复。</strong></p>
<p><img src="/images/Kafka%E5%B9%82%E7%AD%89%E6%80%A7.png" alt="Kafka幂等性"></p>
<p><strong>如何使用幂等性？</strong></p>
<p>开启参数enable.idempotence 默认为true，false关闭。</p>
<pre><code>// 8.开启幂等性（开启事务，必须开启幂等性，默认为true）  
properties.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG,true);  
</code></pre>
<h3 id="生产者事务"><a href="#生产者事务" class="headerlink" title="生产者事务"></a>生产者事务</h3><p> <strong>1）Kafka事务原理</strong> ， <strong>开启事务，必须开启幂等性。</strong></p>
<p><strong>Kafka事务一共有5个API</strong></p>
<pre><code>/**  
     * See &#123;@link KafkaProducer#initTransactions()&#125;  
     */  
    void initTransactions();  
  
    /**  
     * See &#123;@link KafkaProducer#beginTransaction()&#125;  
     */  
    void beginTransaction() throws ProducerFencedException;  
  
    /**  
     * See &#123;@link KafkaProducer#sendOffsetsToTransaction(Map, String)&#125;  
     */  
    @Deprecated  
    void sendOffsetsToTransaction(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,  
                                  String consumerGroupId) throws ProducerFencedException;  
  
    /**  
     * See &#123;@link KafkaProducer#sendOffsetsToTransaction(Map, ConsumerGroupMetadata)&#125;  
     */  
    void sendOffsetsToTransaction(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,  
                                  ConsumerGroupMetadata groupMetadata) throws ProducerFencedException;  
  
    /**  
     * See &#123;@link KafkaProducer#commitTransaction()&#125;  
     */  
    void commitTransaction() throws ProducerFencedException;  
  
    /**  
     * See &#123;@link KafkaProducer#abortTransaction()&#125;  
     */  
    void abortTransaction() throws ProducerFencedException;   
</code></pre>
<p>3）使用kafka事务配置如下</p>
<pre><code>// 7.设置事务id（必须）  
properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG,&quot;transaction_id_0&quot;);  
  
// 8.开启幂等性（开启事务，必须开启幂等性，默认为true）  
properties.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG,true);   
</code></pre>
<p>4）自定类 ：CustomProducerTransactions 实现kafka事务</p>
<pre><code>import ch.qos.logback.classic.Level;  
import ch.qos.logback.classic.Logger;  
import ch.qos.logback.classic.LoggerContext;  
import org.apache.kafka.clients.producer.Callback;  
import org.apache.kafka.clients.producer.KafkaProducer;  
import org.apache.kafka.clients.producer.ProducerRecord;  
import org.apache.kafka.clients.producer.RecordMetadata;  
import org.slf4j.LoggerFactory;  
  
import java.util.List;  
  
/**  
 * @author huangdh  
 * @version 1.0  
 * @description:  
 * @date 2022-11-10 21:45  
 */  
public class CustomProducerTransactions &#123;  
  
    // 修改日志打印级别，默认为debug级别  
    static &#123;  
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();  
        List&lt;Logger&gt; loggerList = loggerContext.getLoggerList();  
        loggerList.forEach(logger -&gt; &#123;  
            logger.setLevel(Level.INFO);  
        &#125;);  
    &#125;  
  
    public static void main(String[] args) &#123;  
  
        KafkaProducer&lt;String, String&gt; producer = KafkaProducerFactory.getProducer();  
  
        // 初始化事务  
        producer.initTransactions();  
        // 开启事务  
        producer.beginTransaction();  
        try &#123;  
            for (int i = 0; i &lt; 5; i++) &#123;  
                producer.send(new ProducerRecord&lt;&gt;(&quot;kafka&quot;, &quot;study hard everyday&quot; + i), new Callback() &#123;  
                    @Override  
                    public void onCompletion(RecordMetadata recordMetadata, Exception e) &#123;  
                        if (e == null) &#123;  
                            System.out.println(&quot;主题：&quot; + recordMetadata.topic() + &quot;-&gt;&quot; + &quot;分区：&quot; + recordMetadata.partition());  
                        &#125; else &#123;  
                            e.printStackTrace();  
                        &#125;  
                    &#125;  
                &#125;);  
            &#125;  
  
//            int i = 1/0;  
            // 提交事务  
            producer.commitTransaction();  
        &#125; catch (Exception e) &#123;  
            // 终止事务  
            producer.abortTransaction();  
            e.printStackTrace();  
        &#125;finally &#123;  
            producer.close();  
        &#125;  
    &#125;  
&#125;  
  
</code></pre>
<p>执行结果如下：</p>
<pre><code>23:04:15.842 [kafka-producer-network-thread | producer-transaction_id_0] INFO org.apache.kafka.clients.producer.internals.TransactionManager - [Producer clientId=producer-transaction_id_0, transactionalId=transaction_id_0] Discovered transaction coordinator 8.8.80.8:9092 (id: 0 rack: null)  
23:04:15.979 [kafka-producer-network-thread | producer-transaction_id_0] INFO org.apache.kafka.clients.producer.internals.TransactionManager - [Producer clientId=producer-transaction_id_0, transactionalId=transaction_id_0] ProducerId set to 1000 with epoch 4  
主题：kafka-&gt;分区：1  
主题：kafka-&gt;分区：1  
主题：kafka-&gt;分区：1  
主题：kafka-&gt;分区：1  
主题：kafka-&gt;分区：1  
</code></pre>
<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p>
<p><strong>Partition 结构</strong><br>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件，<br>log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。</p>
<p><img src="/images/Partition%E7%BB%93%E6%9E%84.png" alt="Partition结构"></p>
<p>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>
<p><strong>Message结构</strong><br>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：<br>1、 offset：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！<br>2、 消息大小：消息大小占用4byte，用于描述消息的大小。<br>3、 消息体：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</p>
<p><strong>存储策略</strong><br>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？<br>1、 基于时间，默认配置是168小时（7天）。<br>2、 基于大小，默认配置是1073741824。<br>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>
<h3 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h3><h4 id="kafka副本"><a href="#kafka副本" class="headerlink" title="kafka副本"></a>kafka副本</h4><ol>
<li><strong>Kafka副本作用：提高数据可靠性。</strong></li>
<li>Kafka默认副本1个，生产环境一般配置为2个，保证数据可靠性；太多副本会增加磁盘存储空间，增加网络上数据传输，降低效率。</li>
<li>Kafka中副本分为：Leader和Follower。Kafka生产者只会把数据发往Leader，然后Follower找Leader进行同步数据。 </li>
<li><strong>Kafka分区中的所有副本统称为AR（Assigned Repllicas），AR &#x3D; ISR + OSR。</strong><br>1. <strong>ISR，表示和Leader保持同步的Follower集合</strong> 。 <strong>如果Follower长时间未向Leader发送通信请求或同步数据，则该Follower将被踢出ISR</strong>** 。该时间阈值由replica.lag.time.max.ms参数设定，默认30s**。Leader发生故障之后，就会从ISR中选举新的Leader。<br>2. <strong>OSR，表示Follower与Leader副本同步时，延迟过多的副本。</strong></li>
</ol>
<h4 id="Leader选举流程"><a href="#Leader选举流程" class="headerlink" title="Leader选举流程"></a>Leader选举流程</h4><p>Kafka集群中有一个broker的Controller会被选举为Controller Leader，<br><strong>负责管理集群broker的上下线，所有topic的分区副本分配和Leader选举等工作</strong><br>。Controller的信息同步工作是依赖于Zookeeper的。</p>
<h4 id="Leader和Follower故障处理细节"><a href="#Leader和Follower故障处理细节" class="headerlink" title="Leader和Follower故障处理细节"></a>Leader和Follower故障处理细节</h4><p> <strong>LEO（Log End Offset）：每个副本的最后一个offset，LEO其实就是最新的offset+1。</strong></p>
<p><strong>HW（High Watermark）：所有副本中最小的LEO。</strong></p>
<p><img src="/images/Leader%E5%92%8CFollower%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82.png" alt="Leader和Follower故障处理细节"></p>
<p><strong>Follower故障</strong></p>
<p>（1）Follower发生故障后会被临时踢出ISR。</p>
<p>（2）这个期间Leader和Follower继续接收数据。</p>
<p><img src="/images/Follower%E6%95%85%E9%9A%9C.png" alt="Follower故障"></p>
<p>（3）待该Follower恢复后，Follower会读取本地磁盘记录上次的HW，并将log文件高于HW的部分截取掉，从HW开始向Leader进行同步。</p>
<p><img src="/images/%E4%BB%8EHW%E5%BC%80%E5%A7%8B%E5%90%91Leader%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5.png" alt="从HW开始向Leader进行同步"></p>
<p>（4）等该Follower的LEO大于等于该Partition的HW，即Follower追上Leader之后，就可以重新加入ISR了。</p>
<p><img src="/images/Follower%E8%BF%BD%E4%B8%8ALeader.png" alt="Follower追上Leader"></p>
<p><strong>Leader故障处理机制</strong></p>
<p>（1）Leader发生故障之后，会从ISR中选出一个新的Leader。</p>
<p><img src="/images/%E4%BB%8EISR%E4%B8%AD%E9%80%89%E5%87%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Leader.png" alt="从ISR中选出一个新的Leader"></p>
<p>（2）为保证多个副本之间的数据一致性，其余的Follower会先将各自的log文件高于HW的部分截掉，然后从新的Leader同步数据。</p>
<p><img src="/images/%E9%AB%98%E4%BA%8EHW%E7%9A%84%E9%83%A8%E5%88%86%E6%88%AA%E6%8E%89.png" alt="高于HW的部分截掉"></p>
<p><strong>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</strong></p>
<h3 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h3><p>消息存储在log文件后，消费者就可以进行消费了。与生产消息相同的是，消费者在拉取消息的时候也是 <strong>找leader</strong> 去拉取。</p>
<p>多个消费者可以组成一个消费者组（consumer<br>group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！是不是有点绕。我们看下图：</p>
<p><img src="/images/%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE.png" alt="消费数据"></p>
<p>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，建议<br><strong>消费者组的consumer的数量与partition的数量一致</strong> ！<br>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：</p>
<p><img src="/images/Kafka%E6%9F%A5%E6%89%BE%E6%B6%88%E6%81%AF.png" alt="Kafka查找消息"></p>
<p>1、 先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。<br>2、<br>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5&#x3D;368801，所以这里要查找的<br><strong>相对offset</strong><br>为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。<br>3、<br>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</p>
<p>这套机制是建立在offset为有序的基础上，利用 <strong>segment</strong> + <strong>有序offset</strong> + <strong>稀疏索引</strong> + <strong>二分查找</strong> +<br><strong>顺序查找</strong><br>等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafka集群的__consumer_offsets这个topic中！</p>
<h2 id="Kafka-Broker"><a href="#Kafka-Broker" class="headerlink" title="Kafka Broker"></a>Kafka Broker</h2><h3 id="Kafka-Broker工作流程"><a href="#Kafka-Broker工作流程" class="headerlink" title="Kafka Broker工作流程"></a>Kafka Broker工作流程</h3><h4 id="Zookeeper存储的Kafka信息"><a href="#Zookeeper存储的Kafka信息" class="headerlink" title="Zookeeper存储的Kafka信息"></a>Zookeeper存储的Kafka信息</h4><p><img src="/images/Zookeeper%E5%AD%98%E5%82%A8%E7%9A%84Kafka%E4%BF%A1%E6%81%AF.png" alt="Zookeeper存储的Kafka信息"></p>
<ol>
<li><strong>&#x2F;kafka&#x2F;brokers&#x2F;ids：[0,1,2]，记录有哪些服务器。</strong></li>
<li><strong>&#x2F;kafka&#x2F;brokers&#x2F;topics&#x2F;first&#x2F;partitions&#x2F;0&#x2F;state：{“leader”:1,”isr”:[1,0,2] } 记录谁是Leader，有哪些服务器可用。</strong></li>
<li><strong>&#x2F;kafka&#x2F;controller：{“brokerid”:0} 辅助选举Leader</strong></li>
</ol>
<h4 id="Kafka-Broker工作流程-1"><a href="#Kafka-Broker工作流程-1" class="headerlink" title="Kafka Broker工作流程"></a>Kafka Broker工作流程</h4><p><img src="/images/Broker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Broker工作流程"></p>
<ol>
<li>broker启动后在zk中注册</li>
<li>controller谁先注册，谁说了算</li>
<li>由选举出来的controller监听brokers节点变化</li>
<li>controller决定Leader选举</li>
<li>controller将节点信息上传到zk中</li>
<li>其他controller从zk同步相关信息</li>
<li>假设broker1中Leader挂了</li>
<li>controller监听到节点发生变化</li>
<li>获取ISR</li>
<li>选举新的Leader（在isr中存活为前提，按照AR中排在前面的优先，例如：ar[1,0,2]，那么leader就会按照1,0,2的顺序轮询）</li>
<li>更新Leader及ISR</li>
</ol>
<h2 id="Kafka核心特性"><a href="#Kafka核心特性" class="headerlink" title="Kafka核心特性"></a>Kafka核心特性</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>我们上面已经知道了Kafka支持以集合（batch）为单位发送消息，在此基础上，Kafka还支持对消息集合进行压缩，Producer端可以通过GZIP或Snappy格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是CPU（压缩和解压会耗掉部分CPU资源）。<br>那么如何区分消息是压缩的还是未压缩的呢，Kafka在消息头部添加了一个描述压缩属性字节，这个字节的后两位表示消息的压缩采用的编码，如果后两位为0，则表示消息未被压缩。</p>
<h3 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h3><p>在消息系统中，保证消息在生产和消费过程中的可靠性是十分重要的，在实际消息传递过程中，可能会出现如下三中情况：</p>
<ul>
<li>一个消息发送失败</li>
<li>一个消息被发送多次</li>
<li>最理想的情况：exactly-once ,一个消息发送成功且仅发送了一次</li>
</ul>
<p>有许多系统声称它们实现了exactly-<br>once，但是它们其实忽略了生产者或消费者在生产和消费过程中有可能失败的情况。比如虽然一个Producer成功发送一个消息，但是消息在发送途中丢失，或者成功发送到broker，也被consumer成功取走，但是这个consumer在处理取过来的消息时失败了。<br>从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会等待broker成功接收到消息的反馈（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息）。<br>从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以通过这个offset值重新找到上一个消息再进行处理。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p>
<h3 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h3><p>备份机制是Kafka0.8版本的新特性，备份机制的出现大大提高了Kafka集群的可靠性、稳定性。有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。一个备份数量为n的集群允许n-1个节点失败。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。下面这幅图解释了Kafka的备份机制:</p>
<p><img src="/images/Kafka%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6.png" alt="Kafka备份机制"></p>
<h3 id="Kafka高效性相关设计"><a href="#Kafka高效性相关设计" class="headerlink" title="Kafka高效性相关设计"></a>Kafka高效性相关设计</h3><h2 id="高效读写数据"><a href="#高效读写数据" class="headerlink" title="高效读写数据"></a>高效读写数据</h2><ol>
<li>Kafka是分布式集群，可以采用分区技术，并行度高。</li>
<li>读数据采用稀疏索引，可以快速定位到要消费的数据。</li>
<li>顺序写磁盘。</li>
</ol>
<p>Kafka的producer生产数据，要 <strong>写入到log文件中，写的过程是一直追加到文件末端，为顺序写</strong> 。<br><strong>官网有数据表明，同样的磁盘，顺序写能到600M&#x2F;s，而随机写只有100K&#x2F;s</strong><br>。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p>
<p><strong>页缓存 + 零拷贝技术</strong></p>
<p><strong>零拷贝：</strong> Kafka的数据加工处理操作交由Kafka生产者和Kafka消费者处理。Kafka<br>Broker应用层不关心存储的数据，所以就不用走应用层，传输效率高。</p>
<p><strong>PageCache页缓存</strong><br>：Kafka重度依赖底层操作系统提供的PageCache功能。当上层有写操作时，操作系统只是将数据写入PageCache。当读操作发生时，先从PageCache中查找，如果找不到，再去磁盘中读取。<br><strong>实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。</strong></p>
<p><img src="/images/%E6%98%AF%E5%90%A6%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94.png" alt="是否零拷贝工作流程对比"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/zk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/zk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">zk学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-17 22:30:00" itemprop="dateCreated datePublished" datetime="2022-10-17T22:30:00+00:00">2022-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">数据库与中间件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ZooKeeper之前也是Hadoop下的一个子项目，在读《Hadoop权威指南》时也有简单的介绍，感觉ZooKeeper还是在很多大公司属于经常用的基础，现在公司有用到但是自己接触的比较少，所以也正好网上查查相关资料做一个大概的总结。</p>
<h1 id="分布式协调技术"><a href="#分布式协调技术" class="headerlink" title="分布式协调技术"></a><strong>分布式协调技术</strong></h1><p>在介绍ZooKeeper之前先来给大家介绍一种技术——分布式协调技术。那么什么是分布式协调技术？其实分布式协调技术主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成”脏数据”的后果。这时，有人可能会说这个简单，写一个调度算法就轻松解决了。说这句话的人，可能对分布式系统不是很了解，所以才会出现这种误解。如果这些进程全部是跑在一台机上的话，相对来说确实就好办了，问题就在于他是在一个分布式的环境下，这时问题又来了，那什么是分布式呢？来咱们看一下这张图</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9B%BE.png" alt="分布式系统图"></p>
<p>在这图中有三台机器，每台机器各跑一个应用程序。然后我们将这三台机器通过网络将其连接起来，构成一个系统来为用户提供服务，对用户来说这个系统的架构是透明的，他感觉不到我这个系统是一个什么样的架构。那么我们就可以把这种系统称作一个<br><strong>分布式系统</strong> 。</p>
<p>那我们接下来再分析一下，在这个分布式系统中如何对进程进行调度，我假设在第一台机器上挂载了一个资源，然后这三个物理分布的进程都要竞争这个资源，但我们又不希望他们同时进行访问，这时候我们就需要一个<br><strong>协调器</strong> ，来让他们有序的来访问这个资源。这个协调器就是我们经常提到的那个 <strong>锁</strong><br>，比如说”进程-1”在使用该资源的时候，会先去获得锁，”进程1”获得锁以后会对该资源保持 <strong>独占</strong><br>，这样其他进程就无法访问该资源，”进程1”用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作<br><strong>分布式锁</strong> 。这个分布式锁也就是我们 <strong>分布式协调技术</strong> 实现的核心内容，那么如何实现这个分布式呢，那就是我们后面要讲的内容。</p>
<p>好我们知道，为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分<br><strong>布式锁</strong> 。那么这个锁怎么实现呢？这实现起来确实相对来说比较困难的。</p>
<p>有人可能会感觉这不是很难。无非是将原来在同一台机器上对进程调度的原语，通过网络实现在分布式环境中。是的，表面上是可以这么说。但是问题就在网络这，在分布式系统中，所有在同一台机器上的假设都不存在：因为网络是不可靠的。</p>
<p>比如，在同一台机器上，你对一个服务的调用如果成功，那就是成功，如果调用失败，比如抛出异常那就是调用失败。但是在分布式环境中，由于网络的不可靠，你对一个服务的调用失败了并不表示一定是失败的，可能是执行成功了，但是响应返回的时候失败了。还有，A和B都去调用C服务，在时间上<br>A还先调用一些，B后调用，那么最后的结果是不是一定A的请求就先于B到达呢？<br>这些在同一台机器上的种种假设，我们都要重新思考，我们还要思考这些问题给我们的设计和编码带来了哪些影响。还有，在分布式环境中为了提升可靠性，我们往往会部署多套服务，但是如何在多套服务中达到一致性，这在同一台机器上多个进程之间的同步相对来说比较容易办到，但在分布式环境中确实一个大难题。</p>
<p>所以分布式协调远比在同一台机器上对多个进程的调度要难得多，而且如果为每一个分布式应用都开发一个独立的协调程序。一方面，协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器。另一方面，协调程序开销比较大，会影响系统原有的性能。所以，急需一种高可靠、高可用的通用协调机制来用以协调分布式应用。</p>
<p>目前，在分布式协调技术方面做得比较好的就是Google的Chubby还有Apache的ZooKeeper他们都是分布式锁的实现者。有人会问既然有了Chubby为什么还要弄一个ZooKeeper，难道Chubby做得不够好吗？不是这样的，主要是Chbby是非开源的，Google自家用。后来雅虎模仿Chubby开发出了ZooKeeper，也实现了类似的分布式锁的功能，并且将ZooKeeper作为一种开源的程序捐献给了Apache，那么这样就可以使用ZooKeeper所提供锁服务。而且在分布式领域久经考验，它的可靠性，可用性都是经过理论和实践的验证的。所以我们在构建一些分布式系统的时候，就可以以这类系统为起点来构建我们的系统，这将节省不少成本，而且bug也<br>将更少。</p>
<h1 id="什么是ZooKeeper"><a href="#什么是ZooKeeper" class="headerlink" title="什么是ZooKeeper"></a>什么是ZooKeeper</h1><p>从本质上来说，Zookeeper就是一种分布式协调服务，在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决了这个问题。<br>ZooKeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。Zookeeper最早的应用是在Hadoop生态中，Apache<br>HBase使用ZooKeeper跟踪分布式数据的状态。</p>
<p>实际上从它的名字上就很好理解，Zoo - 动物园，Keeper -<br>管理员，动物园中有很多种动物，这里的动物就可以比作分布式环境下多种多样的服务，而Zookeeper做的就是管理这些服务。</p>
<p><strong>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</strong></p>
<blockquote>
<p>原语：<br>操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p><strong>Zookeeper提供服务主要就是通过：数据结构 + 原语集 + watcher机制达到的。</strong></p>
<p>分布式应用程序结合Zookeeper可以实现诸如<br><strong>数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master选举、分布式锁和分布式队列</strong> 等功能。</p>
<h1 id="ZooKeeper的数据模型"><a href="#ZooKeeper的数据模型" class="headerlink" title="ZooKeeper的数据模型"></a>ZooKeeper的数据模型</h1><p><img src="/images/ZooKeeper%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt="ZooKeeper数据模型"></p>
<p>从上图可以看到，Zookeeper的数据模型和Unix的文件系统目录树很类似，拥有一个层次的命名空间。这里面的每一个节点都被称为 - ZNode，<br>节点可以拥有子节点，同时也允许少量数据节点存储在该节点之下。（可以理解成一个允许一个文件也可以是一个目录的文件系统）</p>
<h2 id="节点引用方式"><a href="#节点引用方式" class="headerlink" title="节点引用方式"></a>节点引用方式</h2><p>ZNode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须有斜杠字符<code>/</code>来开头,除此之外，路径名必须是唯一的，且不能更改。</p>
<h2 id="ZNode结构"><a href="#ZNode结构" class="headerlink" title="ZNode结构"></a>ZNode结构</h2><p>Node兼具文件和目录两种特点，既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p>
<p>ZNode由以下几部分组成：</p>
<ol>
<li>Stat数据结构</li>
</ol>
<pre><code>* 操作控制列表（ACL） - 每个节点都有一个ACL来做节点的操作控制，这个列表规定了用户的权限，限定了特定用户对目标节点的操作

  * CREATE - 创建子节点的权限
  * READ - 获取节点数据和子节点列表的权限
  * WRITE - 更新节点数据的权限
  * DELETE - 删除子节点的权限
  * ADMIN - 设置节点ACL的权限
* 版本 - ZNode有三个数据版本

  * **version** \- 当前ZNode的版本
  * **cversion** \- 当前ZNode子节点的版本
  * **aversion** \- 当前ACL列表的版本
* Zxid

  * 可以理解成Zookeeper中 **时间戳的一种表现形式** ，也可以理解成 **事务ID** 的概念

  * 如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。

  * ZooKeeper的每个节点维护着三个Zxid值，分别为：cZxid、mZxid、pZxid。

    * **cZxid** ：节点创建时间 create
    * **mZxid** ：节点最近一次修改时间 modify
    * **pZxid** ：该节点的子节点列表最后一次被修改时的时间，子节点内容变更不会变更pZxid
</code></pre>
<ol start="2">
<li><p>data域</p>
</li>
<li><p>children节点</p>
</li>
</ol>
<p>其中，</p>
<p>Stat。是状态信息&#x2F;节点属性；</p>
<p>Data域，Zookeeper中每个节点存储的数据要被 <strong>原子性的操作</strong><br>，也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。值得注意的是，Zookeeper虽然可以存储数据，但是<br><strong>从设计目的上，并不是为了做数据库或者大数据存储，相反，它是用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等</strong><br>，这些数据通常是很小的数据，KB为大小单位。ZNode对数据大小也有限制，至多1M。实际上从这里，就可以推导出Zookeeper用于分布式配置中心的可行性。</p>
<p>Zxid，在ZooKeeper中，<br><strong>能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作</strong><br>。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的 <strong>事务ID</strong> ，用Zxid表示。Zxid是一个64位的数字。 <strong>前32位</strong><br>叫做epoch，用来 <strong>标识Zookeeper 集群中的<code>Leader</code>节点，当<code>Leader</code>节点更换时，就会有一个新的epoch</strong>。<br><strong>后32位</strong> 则为递增序列。从这些Zxid中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>ZNode节点类型严格来说有四种： <strong>持久节点、临时节点、持久顺序节点、临时顺序节点</strong></p>
<ul>
<li><strong>PERSISTENT 持久节点</strong> - 该节点的生命周期不依赖于session，创建之后客户端断开连接，节点依旧存在，只有客户端执行删除操作，节点才能被删除；</li>
<li><strong>EPHEMERAL 临时节点</strong> - 该节点的声明周期依赖于session，客户端断开连接，临时节点就会自动删除。另外， <strong>临时节点不允许有子节点。</strong></li>
<li><strong>SEQUENTIAL 顺序节点</strong> - 当选择创建顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 <code>/myapp</code> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <code>/myapp0000000001</code> ，并将下一个序列号设置为<code>0000000002</code>。如果两个顺序节点是同时创建的，那么ZooKeeper不会对每个znode使用相同的数字。 <strong>顺序节点在锁定和同步中起重要作用。</strong> 这个计数 <strong>对于此节点的父节点来说</strong> 是唯一的，它的格式为”%10d”(10位数字，没有数值的数位用0补充，例如”0000000001”)。当计数值大于2^32-1时，计数器将溢出。</li>
</ul>
<h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><p><img src="/images/znode%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png" alt="znode节点属性"></p>
<h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>客户端可以在节点上设置watch，我们称之为 <strong>监视器</strong><br>。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。</p>
<h1 id="Zookeeper服务基本操作"><a href="#Zookeeper服务基本操作" class="headerlink" title="Zookeeper服务基本操作"></a>Zookeeper服务基本操作</h1><p><img src="/images/ZooKeeper%E6%9C%8D%E5%8A%A1%E4%B8%AD%E6%93%8D%E4%BD%9C.png" alt="ZooKeeper服务中操作"></p>
<p>更新ZooKeeper操作是有限制的。delete或setData必须明确要更新的Znode的版本号，我们可以调用exists找到。如果版本号不匹配，更新将会失败。</p>
<p>更新ZooKeeper操作是非阻塞式的。因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。</p>
<p>尽管ZooKeeper可以被看做是一个文件系统，但是处于便利，摒弃了一些文件系统地操作原语。因为文件非常的小并且使整体读写的，所以不需要打开、关闭或是寻地的操作。</p>
<h1 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h1><p>在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 <strong>TCP 长连接</strong> 。客户端启动的时候，首先会与服务器建立一个 TCP<br>连接，从第一次连接建立开始，客户端会话的生命周期也开始了。<br><strong>通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。</strong></p>
<p>客户端以特定的时间间隔发送心跳以保持会话有效。如果ZooKeeper Server<br>Ensembles在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。</p>
<p>会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。</p>
<h1 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h1><p> <strong>Watches - 监听事件</strong> ，是Zookeeper中一个很重要的特性，也是实现Zookeeper大多数功能的核心特性之一。简单来说，<br><strong>Zookeeper允许Client端在指定节点上注册Watches，在某些特定事件触发的时候，Zookeeper服务端会将事件异步通知到感兴趣（即注册了Watches）的客户端上去</strong><br>。可以理解成一个订阅&#x2F;发布系统，是不是。</p>
<p>Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。</p>
<p>下面说完简单的，来说点复杂的部分。</p>
<p>几个特性先了解下：</p>
<ul>
<li><strong>One-time trigger</strong> 一次watch时间只会被触发一遍，如果节点再次发生变化，除非之前有重新设置过watches，不然会收到通知；</li>
<li><strong>Sent to Client</strong> 当watch的对象状态发生改变时，将会触发此对象上watch所对应的事件。watch事件将被异步地发送给客户端，并且ZooKeeper为watch机制提供了**有序的一致性保证(Ordering guarantee)**。</li>
<li><strong>The data for which the watch was set</strong> 发送给客户端的数据信息，实际上就是你这个watch监视的类型，见下文介绍</li>
</ul>
<p>Zookeeper的Watches 分为两种， <strong>数据监听器（Data Watches）和子节点监听器（Children Watches）</strong><br>。即你可以对某个节点的Data设置watches，也可以对某个子节点设置watches。</p>
<p>可以看下Zookeeper Java 客户端 <code>Zkclient</code> 中的设置watches的代码:</p>
<pre><code>// listener 监听器  
// path 节点路径  
  
// 子节点监听器  
private List&lt;String&gt; addTargetChildListener(String path, IZkChildListener listener) &#123;  
    return client.subscribeChildChanges(path, listener);  
&#125;  
  
// 节点数据的监听器  
public void addChildDataListener(String path, IZkDataListener listener) &#123;  
    try &#123;  
        // 递归创建节点  
        client.subscribeDataChanges(path, listener);  
    &#125; catch (ZkNodeExistsException e) &#123;  
    &#125;  
&#125;  
  
</code></pre>
<p>作为开发者，需要知道监控节点的什么操作会触发你设置的watches。</p>
<ol>
<li>一个成功的setData操作将触发Znode的数据watches</li>
<li>一个成功的create操作将触发Znode的数据watches以及子节点watches</li>
<li>一个成功的delete操作将触发Znode的数据watches和子节点watches</li>
</ol>
<p>再看下ZkClient中的数据监听器接口<code>IZkDataListener</code></p>
<pre><code>public interface IZkDataListener &#123;  
    // 监控节点数据更新的时候会触发 这段逻辑  
    public void handleDataChange(String dataPath, Object data) throws Exception;  
    // 监控节点被删除的时候会触发 这段逻辑  
    public void handleDataDeleted(String dataPath) throws Exception;  
&#125;  
  
</code></pre>
<p>再看下ZkClient中的子节点监听器接口<code>IZkChildListener</code></p>
<pre><code>public interface IZkChildListener &#123;  
  
    /**  
     * Called when the children of the given path changed.  
     * 监控节点的子节点列表改变时会触发这段逻辑  
     *   
     * @param parentPath  
     *            The parent path  
     * @param currentChilds  
     *            The children or null if the root node (parent path) was deleted.  
     * @throws Exception  
     */  
    public void handleChildChange(String parentPath, List&lt;String&gt; currentChilds) throws Exception;  
&#125;  
</code></pre>
<p>实际上看到这就能联想到，Zookeeper是可以当做分布式配置中心来使用的，只不过你需要自己扩展他异步通知节点数据变化之后的逻辑，更新你的配置。</p>
<p><strong>(1) watch概述</strong></p>
<p>ZooKeeper可以为所有的 <strong>读操作</strong><br>设置watch，这些读操作包括：exists()、getChildren()及getData()。watch事件是 <strong>一次性的触发器</strong><br>，当watch的对象状态发生改变时，将会触发此对象上watch所对应的事件。watch事件将被 <strong>异步</strong><br>地发送给客户端，并且ZooKeeper为watch机制提供了有序的 <strong>一致性保证</strong><br>。理论上，客户端接收watch事件的时间要快于其看到watch对象状态变化的时间。</p>
<p><strong>(2) watch类型</strong></p>
<p>ZooKeeper所管理的watch可以分为两类：</p>
<p><strong>①</strong> 数据watch(data watches)： <strong>getData</strong> 和 <strong>exists</strong> 负责设置数据watch<br> <strong>②</strong> 孩子watch(child watches)： <strong>getChildren</strong> 负责设置孩子watch</p>
<p>我们可以通过操作 <strong>返回的数据</strong> 来设置不同的watch：</p>
<p><strong>① getData和exists：</strong> 返回关于节点的数据信息<br> <strong>② getChildren：</strong> 返回孩子列表</p>
<p>因此</p>
<p><strong>①</strong> 一个成功的 <strong>setData操作</strong> 将触发Znode的数据watch</p>
<p><strong>②</strong> 一个成功的 <strong>create操作</strong> 将触发Znode的数据watch以及孩子watch</p>
<p><strong>③</strong> 一个成功的 <strong>delete操作</strong> 将触发Znode的数据watch以及孩子watch</p>
<p><strong>(3) watch注册与处触发</strong></p>
<p><img src="/images/watch%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%BA%94%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="watch设置操作及相应的触发器"></p>
<p><strong>①</strong> exists操作上的watch，在被监视的Znode <strong>创建</strong> 、 <strong>删除</strong> 或 <strong>数据更新</strong> 时被触发。<br> <strong>②</strong> getData操作上的watch，在被监视的Znode <strong>删除</strong> 或 <strong>数据更新</strong><br>时被触发。在被创建时不能被触发，因为只有Znode一定存在，getData操作才会成功。<br> <strong>③</strong> getChildren操作上的watch，在被监视的Znode的子节点 <strong>创建</strong> 或 <strong>删除</strong> ，或是这个Znode自身被<br><strong>删除</strong><br>时被触发。可以通过查看watch事件类型来区分是Znode，还是他的子节点被删除：NodeDelete表示Znode被删除，NodeDeletedChanged表示子节点被删除。</p>
<p>Watch由客户端所连接的ZooKeeper服务器在本地维护，因此watch可以非常容易地设置、管理和分派。当客户端连接到一个新的服务器时，任何的会话事件都将可能触发watch。另外，当从服务器断开连接的时候，watch将不会被接收。但是，当一个客户端重新建立连接的时候，任何先前注册过的watch都会被重新注册。</p>
<p><strong>(4) 需要注意的几点</strong></p>
<p><strong>Zookeeper的watch实际上要处理两类事件：</strong></p>
<p><strong>① 连接状态事件</strong> (type&#x3D;None, path&#x3D;null)</p>
<p>这类事件不需要注册，也不需要我们连续触发，我们只要处理就行了。</p>
<p><strong>② 节点事件</strong></p>
<p>节点的建立，删除，数据的修改。它是one time trigger，我们需要不停的注册触发，还可能发生事件丢失的情况。</p>
<p>上面2类事件都在Watch中处理，也就是重载的 <strong>process(Event event)</strong></p>
<p><strong>节点事件的触发，通过函数exists，getData或getChildren来处理这类函数，有双重作用：</strong></p>
<p><strong>① 注册触发事件</strong></p>
<p><strong>② 函数本身的功能</strong></p>
<p>函数的本身的功能又可以用异步的回调函数来实现,重载processResult()过程中处理函数本身的的功能。</p>
<h1 id="Zookeeper特性总结"><a href="#Zookeeper特性总结" class="headerlink" title="Zookeeper特性总结"></a>Zookeeper特性总结</h1><p>现在我们再回过头来看看Zookeeper的特性：</p>
<blockquote>
<p>① 顺序一致性 从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中。</p>
</blockquote>
<blockquote>
<p>② 原子性<br>所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</p>
</blockquote>
<blockquote>
<p>③ 单一视图 无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</p>
</blockquote>
<blockquote>
<p>④ 可靠性 一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
</blockquote>
<blockquote>
<p>⑤ 实时性<br>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p>
</blockquote>
<p><strong>顺序一致性</strong> 是通过ZXid来实现的，全局唯一，顺序递增，同一个session中请求是FIFO的； <strong>可靠性</strong><br>的描述也可以通过今天的知识进行理解，一次事务的应用，服务端状态的变更会以Zxid、Znode数据版本、数据、节点路径的形式保存下来。剩下的几种特性是怎么实现的，后面会进行介绍</p>
<h1 id="Zookeeper运行模式"><a href="#Zookeeper运行模式" class="headerlink" title="Zookeeper运行模式"></a>Zookeeper运行模式</h1><p>Zookeeper 有两种运行模式， <strong>单点模式</strong> 和 <strong>集群模式</strong> 。</p>
<ul>
<li><p>单点模式（standalone mode）- Zookeeper 只运行在单个服务器上，常用于开发测试阶段，这种模式比较简单，但是不能保证Zookeeper服务的高可用性和恢复性。</p>
</li>
<li><p>集群模式（replicated mode）- 英文原文这种模式叫做“复制模式”；这个模式下，Zookeeper运行于一个集群上，适合生产环境。</p>
</li>
</ul>
<p>同一个集群下的server节点被称为 <em>quorum</em> ，翻译过来就是“一个正式会议的法定人数”，如果你看完下一章介绍的 <strong>ZAB协议的两种模式</strong><br>之后，应该会觉得这个比喻实际上很形象。</p>
<blockquote>
<p>NOTE:<br>在集群模式下，最少需要三个server节点。并且官方推荐你使用奇数数量的server节点来组成集群。至于为什么，和Zookeeper的读写策略和一致性协议有关，在后面的章节会介绍。</p>
</blockquote>
<h1 id="Zookeeper的集群架构"><a href="#Zookeeper的集群架构" class="headerlink" title="Zookeeper的集群架构"></a>Zookeeper的集群架构</h1><p><img src="/images/Zookeeper%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="Zookeeper集群架构"></p>
<h2 id="Zookeeper集群中的角色"><a href="#Zookeeper集群中的角色" class="headerlink" title="Zookeeper集群中的角色"></a>Zookeeper集群中的角色</h2><blockquote>
<p>Zookeeper中，<br><strong>能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作</strong> 。</p>
</blockquote>
<ul>
<li><strong>Leader 领导者</strong> ：Leader 节点负责Zookeeper集群内部投票的发起和决议（一次事务操作），更新系统的状态；同时它也能接收并且响应Client端发送的请求。</li>
<li>Learner 学习者<ul>
<li><strong>Follower 跟随者</strong> ： Follower 节点用于接收并且响应Client端的请求，如果是事务操作，会将请求转发给Leader节点，发起投票，参与集群的内部投票，</li>
<li><strong>Observer 观察者</strong> ：Observer 节点功能和Follower相同，只是Observer 节点不参与投票过程，只会同步Leader节点的状态。</li>
</ul>
</li>
<li><strong>Client 客户端</strong></li>
</ul>
<p>Zookeeper 通过 <strong>复制</strong> 来实现 <strong>高可用</strong> 。在上面提到的集群模式（replicated<br>mode）下，以<code>Leader</code>节点为准，Zookeeper的<code>ZNode</code>树上面的每一个修改都会被同步（复制）到其他的Server 节点上面。</p>
<blockquote>
<p>上面实际上只是一个概念性的简单叙述，在看完下文的 <strong>读写机制</strong> 和 <strong>ZAB协议的两种模式</strong> 之后，你就会对这几种角色有一个更加深刻的认识。</p>
</blockquote>
<h2 id="Zookeeper-读写机制"><a href="#Zookeeper-读写机制" class="headerlink" title="Zookeeper 读写机制"></a>Zookeeper 读写机制</h2><p>下图就是集群模式下一个Zookeeper Server节点提供读写服务的一个流程。</p>
<p><img src="/images/%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="读写流程"></p>
<p>如上图所示，每个Zookeeper<br>Server节点除了包含一个请求处理器来处理请求以外，都会有一个**内存数据库(ReplicatedDatabase)**用于持久化数据。ReplicatedDatabase<br>包含了整个Data Tree。</p>
<p>来自于Client的读服务（Read Requst），是直接由对应Server的本地副本来进行服务的。</p>
<p>至于来自于Client的写服务（Write<br>Requst），因为Zookeeper要保证每台Server的本地副本是一致的（单一系统映像），需要通过一致性协议（后文提到的ZAB协议）来处理，成功处理的写请求（数据更新）会先序列化到每个Server节点的本地磁盘（为了再次启动的数据恢复）再保存到内存数据库中。</p>
<p>集群模式下，Zookeeper使用简单的同步策略，通过以下三条基本保证来实现 <strong>数据的一致性</strong> ：</p>
<ul>
<li>全局 <strong>串行化</strong> 所有的 <strong>写操作</strong></li>
</ul>
<blockquote>
<p>串行化可以把变量包括对象,转化成连续bytes数据. 你可以将串行化后的变量存在一个文件里或在网络上传输. 然后再反串行化还原为原来的数据。</p>
</blockquote>
<ul>
<li>保证 <strong>同一客户</strong> 端的指令被FIFO执行（以及消息通知的FIFO）</li>
</ul>
<blockquote>
<p>FIFO -先入先出</p>
</blockquote>
<ul>
<li>自定义的原子性消息协议</li>
</ul>
<p>简单来说，对数据的写请求，都会被转发到Leader节点来处理，Leader节点会对这次的更新发起投票，并且发送提议消息给集群中的其他节点，当半数以上的Follower节点将本次修改持久化之后，Leader<br>节点会认为这次写请求处理成功了，提交本次的事务。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>Zookeeper 的核心思想就是，提供一个 <strong>非锁机制的Wait Free 的用于分布式系统同步的核心服务</strong> 。其核心对于文件、数据的读写服务，并<br><strong>不提供加锁互斥的服务</strong> 。</p>
<p>但是由于Zookeeper的每次更新操作都会更新ZNode的版本，也就是客户端可以自己基于版本的对比，来实现更新数据时的加锁逻辑。例如下图。</p>
<p><img src="/images/zookeeper%E6%B5%81%E7%A8%8B.png" alt="zookeeper流程"></p>
<p>就像我们更新数据库时，会新增一个version字段，通过更新前后的版本对比来实现乐观锁。</p>
<h1 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h1><p>ZAB 协议是为分布式协调服务ZooKeeper专门设计的一种 <strong>支持崩溃恢复</strong> 的 <strong>一致性协议</strong><br>，这个机制保证了各个server之间的同步。全称 Zookeeper Atomic Broadcast Protocol - Zookeeper<br>原子广播协议。</p>
<h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>Zab协议有两种模式，它们分别是 <strong>恢复模式</strong> 和 <strong>广播模式</strong> 。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>广播模式类似于分布式事务中的 Two-phase commit<br>（两阶段式提交），因为Zookeeper中一次写操作就是被当做一个事务，所以这实际上本质是相同的。</p>
<p>在 <strong>广播模式</strong> ，一次写请求要经历以下的步骤</p>
<ol>
<li>ZooKeeper Server接受到Client的写请求</li>
<li>写请求都被转发给<code>Leader</code>节点</li>
<li><code>Leader</code>节点先将更新持久化到本地</li>
<li><code>Leader</code>节点将此次更新提议(propose)给<code>Followers</code>，进入收集选票的流程</li>
<li><code>Follower</code>节点接收请求，成功将修改持久化到本地，发送一个ACK给<code>Leader</code></li>
<li><code>Leader</code>接收到半数以上的ACK时，<code>Leader</code>将广播commit消息并在本地deliver该消息。</li>
<li>当收到<code>Leader</code>发来的commit消息时，<code>Follower</code>也会deliver该消息。</li>
</ol>
<p>广播协议在所有的通讯过程中使用TCP的FIFO信道，通过使用该信道，使保持有序性变得非常的容易。通过FIFO信道，消息被有序的deliver。只要收到的消息一被处理，其顺序就会被保存下来。</p>
<p>但是这种模式下，如果<code>Leader</code>自身发生了故障，Zookeeper的集群不就提供不了写服务了吗？这就引入了下面的恢复模式。</p>
<h3 id="恢复模式"><a href="#恢复模式" class="headerlink" title="恢复模式"></a>恢复模式</h3><p>简单点来说，当集群中的<code>Leader</code> <strong>故障</strong> 或者 <strong>服务启动</strong><br>的时候，ZAB就会进入恢复模式，其中包括<code>Leader</code>选举和完成其他Server和<code>Leader</code>之间的 <strong>状态同步</strong> 。</p>
<h4 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h4><p>在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行 <strong>Master选举</strong> ，来解决分布式系统中的 <strong>单点故障</strong><br>。什么是分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。</p>
<p><img src="/images/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.png" alt="主从模式分布式系统"><img src="/images/%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C1.png" alt="单点故障1"></p>
<h4 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h4><p>传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。</p>
<p><img src="/images/%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="传统解决方案"></p>
<p>当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点</p>
<p><img src="/images/%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.png" alt="传统解决方案1"></p>
<p>但是这种方式就是有一个隐患，就是网络问题，来看一看网络问题会造成什么后果</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C.png" alt="网络故障"></p>
<p>也就是说我们的主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是—<br><strong>双Master</strong><br>，出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。为了防止出现这种情况，我们引入了ZooKeeper，它虽然不能避免网络故障，但它能够保证每时每刻只有一个Master。我么来看一下ZooKeeper是如何实现的。</p>
<h4 id="zookeeper解决方案"><a href="#zookeeper解决方案" class="headerlink" title="zookeeper解决方案"></a>zookeeper解决方案</h4><p>首先每个Server在工作过程中有四种状态：<br>LOOKING：竞选状态，当前Server不知道leader是谁，正在搜寻。<br>LEADING：领导者状态，表明当前服务器角色是leader。<br>FOLLOWING：随从状态，表明当前服务器角色是follower，同步leader状态，参与投票。<br>OBSERVING，观察状态，表明当前服务器角色是observer，同步leader状态，不参与投票。</p>
<p><img src="/images/%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B.png" alt="选举流程"></p>
<p>假设我们目前有一个3个节点构成的ZooKeeper集群，myid的编号分别是0,1,2，又因为集群当前是一个空的集群，所以<br><strong>每个节点的ZXID初始都为0</strong> ，该集群启动的时候Leader的选举流程如下：</p>
<ol>
<li><p>我们首先启动myid为0的服务，但是目前只有一台ZooKeeper服务，所以是无法完成Leader选举的，ZooKeeper集群要求Leader进行投票选举条件是至少有2台服务才行，不然都没法进行通信投票。</p>
</li>
<li><p>启动myid为1的服务，第二台启动了以后，这两台ZooKeeper就可以相互通信了，接下来就可以进行投票选举了。</p>
</li>
<li><p>2台ZooKeeper进行投票选举的时候，第一次都是推荐自己为Leader，投票包含的信息是：服务器本身的myid和ZXID。比如第一台投自己的话，它会发送给第二台机器的投票是(0,0)，第一个0代表的是机器的myid，第二个0代表是的ZXID。故两台机器收到的投票情况如下：</p>
</li>
</ol>
<p>第一台：(1,0)</p>
<p>第二台：(0,0)</p>
<ol start="4">
<li>两台服务器在接收到投票后，将别人的票和自己的投票进行PK。PK的是规则是：</li>
</ol>
<p>（a）优先对比ZXID，ZXID大的优先作为Leader（ZXID大的表示数据多）</p>
<p>（b）如果ZXID一样的话，那么就比较myid，让myid大的作为Leader服务器。</p>
<p>那根据这个规则的话，第一台服务器，接受到的投票是(1,0)，跟自己的投票（0,0）比，ZXID是一样的，但是myid比接收到的投票的小，所以第一台原先是推荐自己投票为(0,0),现在进行了PK以后，投票修改为(1,0)。第二台服务器，接受到的投票是(0,0),跟自己的投票(1,0)比，ZXID是一样的，但是myid是比接受到的投票的大，所以坚持自己的投票(1,0)。两台服务器再次进行投票。</p>
<ol start="5">
<li>每次投票以后，服务器都会统计所有的投票，只要过半的机器投了相同的机器，那么Leader就选举成功了，上面的两台服务器进行第二次投票之后，两台服务器都会收到相同的投票(1,0)。那么此时myid为1的服务器就是Leader了。</li>
</ol>
<p>如上的Leader选举其实在集群启动的过程中只需要几毫秒就完成了，所以如果有搭建ZooKeeper集群经验的同学会发现，我们如果按顺序启动服务的话，启动到第二台机器的时候，Leader就已经选出来了，所以大家会看到一般第二台就是Leader。第三台启动的时候就作为Follower。</p>
<p>上面我们描述的是集群在初始化过程中Leader的选举流程，如果集群在运行的过程中Follower节点宕机了，对Leader节点是不影响的，如果集群在运行的过程中Leader节点宕机了，就会进行重新选举，重新选举的流程跟上述一致。</p>
<p><img src="/images/leader%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B.jpeg" alt="leader选举流程"></p>
<h1 id="关于Zookeeper-集群的一些其他讨论"><a href="#关于Zookeeper-集群的一些其他讨论" class="headerlink" title="关于Zookeeper 集群的一些其他讨论"></a>关于Zookeeper 集群的一些其他讨论</h1><h2 id="Zookeeper（读性能）可伸缩性-和-Observer节点"><a href="#Zookeeper（读性能）可伸缩性-和-Observer节点" class="headerlink" title="Zookeeper（读性能）可伸缩性 和 Observer节点"></a>Zookeeper（读性能）可伸缩性 和 Observer节点</h2><p>一个集群的可伸缩性即可以引入更多的集群节点，来提升某种性能。Zookeeper实际上就是提供读服务和写服务。在最早的时候，Zookeeper是通过引入<code>Follower</code>节点来提升<br><strong>读服务</strong> 的性能。但是根据我们之前学习过的读写机制和ZAB协议的内容，引入新的<code>Follower</code>节点，会造成Zookeeper<br>写服务的下降，因为<code>Leader</code>发起的投票是要半数以上的<code>Follower</code>节点响应才会成功，你<code>Follower</code>多了，就增加了协议中投票过程的压力，可能会拖慢整个投票响应的速度。结果就是，**<code>Follower</code>节点增加，集群的写操作吞吐会下降**。</p>
<p>在这种情况下，Zookeeper<br>在3.3.3版本之后，在集群架构中引入了<code>Observer</code>角色，和<code>Follower</code>唯一的区别的就是不参与投票不参与选主。这样既提升了读性能，又不会影响写性能。</p>
<p>另外提一句，Zookeeper的写性能是不能被扩展的，这也是他不适合当做服务注册发现中心的一个原因之一，在服务发现和健康监测场景下，随着服务规模的增大，无论是应用频繁发布时的服务注册带来的写请求，还是刷毫秒级的服务健康状态带来的写请求，都会Zookeeper带来很大的写压力，因为它本身的写性能是无法扩展的。后文引的文章会详细介绍。</p>
<h2 id="Zookeeper-与-CAP-理论"><a href="#Zookeeper-与-CAP-理论" class="headerlink" title="Zookeeper 与 CAP 理论"></a>Zookeeper 与 CAP 理论</h2><p>分布式领域中存在CAP理论：</p>
<ul>
<li><strong>C：Consistency</strong> ，一致性，数据一致更新，所有数据变动都是同步的。</li>
<li><strong>A：Availability</strong> ，可用性，系统具有好的响应性能。</li>
<li><strong>P：Partition tolerance</strong> ，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/cap.html">CAP 定理的含义 – 阮一峰</a></p>
</blockquote>
<p>该理论已被 <strong>证明</strong> ：任何分布式系统只可同时满足两点，无法三者兼顾。<br>因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。</p>
<p>根据我们前面学习过的读写机制和ZAB协议的内容，Zookeeper本质应该是一个偏向CP的分布式系统。因为广播协议本质上是牺牲了系统的响应性能的。另外从它的以下几个特点也可以看出。也就是在第一章最后提出的几个特点。</p>
<blockquote>
<p>① 顺序一致性 从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中。</p>
</blockquote>
<blockquote>
<p>② 原子性<br>所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</p>
</blockquote>
<blockquote>
<p>③ 单一视图 无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</p>
</blockquote>
<blockquote>
<p>④ 可靠性 一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
</blockquote>
<h2 id="Zookeeper-作为-服务注册中心的局限性"><a href="#Zookeeper-作为-服务注册中心的局限性" class="headerlink" title="Zookeeper 作为 服务注册中心的局限性"></a>Zookeeper 作为 服务注册中心的局限性</h2><p>直接引一篇阿里中间件的文章吧，讲的比我好。实际在生产情况下，大多数公司没有达到像大公司那样的微服务量级，Zookeeper是完全能满足服务注册中心的需求的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/599997">阿里巴巴为什么不用 ZooKeeper 做服务发现？</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">RPC和HTTP调用对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-27 22:30:00" itemprop="dateCreated datePublished" datetime="2022-08-27T22:30:00+00:00">2022-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>现在的公司基本上都是HTTP调用，个别服务会有RPC，突然发现之前自己知道这两个调用方式是不同的，具体有哪些不同还有点模糊，了解了之后发现难怪大厂都用RPC调用，包括gRPC和dubbo。</p>
<p>先说一下他们最本质的区别，就是RPC主要是基于TCP&#x2F;IP协议的，而HTTP服务主要是基于HTTP协议的，我们都知道HTTP协议是在传输层协议TCP之上的，所以效率来看的话，RPC当然是要更胜一筹啦！当然RPC也可以用HTTP调用，像Feign，不过也因此他被叫做伪RPC。下面来具体说一说RPC服务和HTTP服务。</p>
<h1 id="RPC服务"><a href="#RPC服务" class="headerlink" title="RPC服务"></a>RPC服务</h1><h2 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h2><p>一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server<br>Stub，这个Stub大家可以理解为存根。分别说说这几个组件：</p>
<ul>
<li>客户端（Client），服务的调用方。</li>
<li>服务端（Server），真正的服务提供者。<br>客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。<br>服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
<p><img src="/images/RPC%E6%9E%B6%E6%9E%84.jpeg" alt="RPC架构"></p>
<p>RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。</p>
<p>比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的interface），然后将整个项目打包为一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。</p>
<p>为什么这么做？主要是为了减少客户端这边的jar包大小，因为每一次打包发布的时候，jar包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p>
<h2 id="同步调用和异步调用"><a href="#同步调用和异步调用" class="headerlink" title="同步调用和异步调用"></a>同步调用和异步调用</h2><p>同步调用就是客户端等待调用执行完成并返回结果。异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。</p>
<p>这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然啦，callable也是可以的，我们不去获取Future就可以了。</p>
<h2 id="流行的RPC框架"><a href="#流行的RPC框架" class="headerlink" title="流行的RPC框架"></a>流行的RPC框架</h2><ol>
<li>gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。下面放两个文档</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://doc.oschina.net/grpc?t=56831">https://doc.oschina.net/grpc?t=56831</a></p>
<p><a target="_blank" rel="noopener" href="https://www.grpc.io/docs/">https://www.grpc.io/docs/</a></p>
<ol>
<li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li>
<li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>
<p>关于gRPC和Dubbo暂时可能不会写文章总结，因为文档足够详细，自己也还没看完，等看完了并且有了超出文档的理解再进行总结。</p>
<h1 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h1><p>其实在很久以前，我对于企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。</p>
<p>利用现成的http协议进行传输。我们记得之前实习在公司做后台开发的时候，主要就是进行接口的开发，还要写一大份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。</p>
<p>接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。</p>
<p>但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销，虽然HTTP1.1之后也可以长连接了；</p>
<p>其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p>
<h2 id="顺便总结下HTTP版本差别"><a href="#顺便总结下HTTP版本差别" class="headerlink" title="顺便总结下HTTP版本差别"></a>顺便总结下HTTP版本差别</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p>HTTP 0.9 是一个最古老的版本</p>
<ul>
<li>只支持<code>GET</code>请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息</li>
<li>没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力</li>
<li>服务端相响应之后，立即关闭TCP连接</li>
</ul>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>随着 HTTP 1.0 的发布，这个版本:</p>
<ul>
<li>请求方式新增了POST，DELETE，PUT，HEADER等方式</li>
<li>增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)</li>
<li>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输</li>
</ul>
<p>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>一个简单请求的头信息</p>
<pre><code>GET / HTTP/1.0  
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)  
Accept: */*  
</code></pre>
<p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>一个简单响应的头信息(v1.0)</p>
<pre><code>HTTP/1.0 200 OK  
Content-Type: text/plain  
Content-Length: 137582  
Expires: Thu, 05 Dec 1997 16:00:00 GMT  
Last-Modified: Wed, 5 August 1996 15:55:28 GMT  
// 这是一个空行  
...数据内容  
</code></pre>
<p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p>
<p><strong>Content-Type</strong></p>
<p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 <code>Content-Type</code><br>去进行解析的。所以服务端返回时候必须带着这个字段。</p>
<p>一些常见的 <code>Content-Type</code> 可以参考 <a target="_blank" rel="noopener" href="http://tool.oschina.net/commons/">对照表</a>。 这些<br><code>Content-Type</code> 有一个总称叫做<code>MIME type</code>。</p>
<p>关于<code>MIME type</code>，这里想播插一个小插曲:</p>
<blockquote>
<p>在 chrome 浏览器中，当跨域请求回来的数据 MIME type 同跨域标签应有的 MIME type 不匹配时，浏览器会启动 CORB<br>保护数据不被泄漏。被保护的数据有: html、xml、json。(eg: script、img 标签所支持的 MIME<br>type和他们都不一致)，所以服务端在返回资源的时候一定要对应返回正确的 <code>Content-Type</code>，以免浏览器屏蔽返回结果。</p>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>无状态：服务器不跟踪不记录请求过的状态</li>
<li>无连接：浏览器每次请求都需要建立tcp连接</li>
</ul>
<h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>对于无状态的特性可以借助cookie&#x2F;session机制来做身份认证和状态记录</p>
<h5 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h5><p>无连接导致的性能缺陷有两种：</p>
<ul>
<li><p>无法复用连接<br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</p>
</li>
<li><p>队头阻塞<br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</p>
</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开</li>
<li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li>
<li>缓存处理：新增字段cache-control</li>
<li>断点传输</li>
</ul>
<h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据</p>
<h5 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h5><p>基于长连接的基础，我们先看没有管道化请求响应：</p>
<p>tcp没有断开，用的同一个通道</p>
<pre><code>请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3  
  
</code></pre>
<p>管道化的请求响应：</p>
<pre><code>请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3  
</code></pre>
<p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p>
<p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h4 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h4><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p>
<h4 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h4><p>在上传&#x2F;下载资源时，如果资源过大，将其分割为多个部分，分别上传&#x2F;下载，如果遇到网络故障，可以从已经上传&#x2F;下载好的地方继续请求，不用从头开始，提高效率</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><p>2015 年，HTTP&#x2F;2 发布。HTTP&#x2F;2 是现行 HTTP 协议（HTTP&#x2F;1.x）的替代，但它不是重写，HTTP 方法&#x2F;状态码&#x2F;语义都与<br>HTTP&#x2F;1.x 一样。HTTP&#x2F;2 基于 SPDY3，专注于 <strong>性能</strong> ，最大的一个目标是在用户和网站间只用一个连接（connection）。</p>
<p>HTTP&#x2F;2 由两个规范（Specification）组成：</p>
<ol>
<li><p>Hypertext Transfer Protocol version 2 - RFC7540</p>
</li>
<li><p>HPACK - Header Compression for HTTP&#x2F;2 - RFC7541</p>
</li>
</ol>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP &#x2F; 1<br>的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。 <strong>HTTP&#x2F;2<br>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong> 。</p>
<p>接下来我们介绍几个重要的概念：</p>
<ul>
<li>流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</li>
<li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li>
<li>帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等</li>
</ul>
<p><img src="/images/HTTP2%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93.png" alt="HTTP2二进制传输"></p>
<p>HTTP&#x2F;2<br>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在 HTTP&#x2F;2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP<br>连接都需要慢慢提升传输速度。</p>
<p>大家可以通过 <a target="_blank" rel="noopener" href="https://http2.akamai.com/demo">该链接</a> 直观感受下 HTTP&#x2F;2 比 HTTP&#x2F;1 到底快了多少。</p>
<p><img src="/images/HTTP2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.gif" alt="HTTP2多路复用"></p>
<p>在 HTTP&#x2F;2 中，有了二进制分帧之后，HTTP &#x2F;2 不再依赖 TCP 链接去实现多流并行了，在 HTTP&#x2F;2 中：</p>
<ul>
<li>同域名下所有通信都在单个连接上完成。</li>
<li>单个连接可以承载任意数量的双向数据流。</li>
<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li>
</ul>
<p>这一特性，使性能有了极大提升：</p>
<ul>
<li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>并行交错地发送多个请求，请求之间互不影响。</li>
<li>并行交错地发送多个响应，响应之间互不干扰。</li>
<li>在 HTTP&#x2F;2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li>
</ul>
<p><img src="/images/HTTP2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="HTTP2多路复用"></p>
<p>如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。</p>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>在 HTTP&#x2F;1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>为了减少这块的资源消耗并提升性能， HTTP&#x2F;2 对这些首部采取了压缩策略：</p>
<ul>
<li>HTTP&#x2F;2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>
<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p>
<p><img src="/images/HTTP2%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9.png" alt="HTTP2头部压缩"></p>
<h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push<br>的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。<br>例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p>
<p><img src="/images/HTTP2%E6%9C%8D%E5%8A%A1%E6%8E%A8%E9%80%81.png" alt="HTTP2服务推送"></p>
<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM<br>帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。</p>
<p>上文提到 HTTP&#x2F;2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP&#x2F;2<br>的表现情况反倒不如 HTTP&#x2F;1 了。</p>
<p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP&#x2F;1.1 来说，可以开启多个 TCP<br>连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p>
<p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP<br>存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p>
<p>基于这个原因， <strong>Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP&#x2F;3 上</strong> ，HTTP&#x2F;3 之前名为<br>HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP&#x2F;3 最大的改造就是使用了 QUIC。</p>
<p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。</p>
<h4 id="0RTT"><a href="#0RTT" class="headerlink" title="0RTT"></a>0RTT</h4><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。 <strong>0RTT<br>建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong> 。那什么是 0RTT 建连呢？</p>
<p>这里面有两层含义:</p>
<ul>
<li>传输层 0RTT 就能建立连接。</li>
<li>加密层 0RTT 就能建立加密连接。</li>
</ul>
<p><img src="/images/HTTPS%E5%92%8CQUIC%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B.png" alt="HTTPS和QUIC建立过程"></p>
<p>上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是会话复用也需要至少 2 个 RTT。</p>
<p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT<br>就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。</p>
<h4 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h4><p>虽然 HTTP&#x2F;2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC<br>原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p>
<p>同 HTTP2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求，但是，QUIC 是基于 UDP<br>的，一个连接上的多个 stream 之间没有依赖。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和<br>Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待，就可以发给用户。</p>
<p><img src="/images/QUIC%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="QUIC多路复用"></p>
<p>另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC<br>是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p>
<h4 id="加密认证的报文"><a href="#加密认证的报文" class="headerlink" title="加密认证的报文"></a>加密认证的报文</h4><p>TCP<br>协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p>
<p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body<br>都是经过加密的。</p>
<p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
<p><img src="/images/%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8.png" alt="报文头部"></p>
<p>如上图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p>
<h4 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h4><p>QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error<br>Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)</p>
<p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。<br><strong>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</strong> 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/10/%E6%8A%98%E8%85%BE/%E9%80%9A%E8%BF%87acme%E7%BB%99nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/10/%E6%8A%98%E8%85%BE/%E9%80%9A%E8%BF%87acme%E7%BB%99nginx%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/" class="post-title-link" itemprop="url">通过acme对nginx配置SSL证书</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-10 22:53:43" itemprop="dateCreated datePublished" datetime="2021-09-10T22:53:43+00:00">2021-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%98%E8%85%BE/" itemprop="url" rel="index"><span itemprop="name">折腾</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>docker中启动neilpang&#x2F;acme.sh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -itd -v &quot;$(pwd)/out&quot;:/acme.sh --net=host --name=[acme.sh](http://acme.sh/) neilpang/acme.sh daemon</span><br></pre></td></tr></table></figure>
<p>注册</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [acme.sh](http://acme.sh/) --register-account -m [zhangqian9111@gmail.com](mailto:zhangqian9111@gmail.com)</span><br></pre></td></tr></table></figure>
<p>生成证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [acme.sh](http://acme.sh/) --issue -d xx.merric.top --standalone</span><br></pre></td></tr></table></figure>


<p>生成的证书在$(pwd)&#x2F;out目录下</p>
<p>将证书配置到nginx配置</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name xx.<span class="property">merric</span>.<span class="property">top</span>;</span><br><span class="line">        rewrite ^(.*) <span class="attr">https</span>:<span class="comment">//$server_name$1 permanent;</span></span><br><span class="line">    &#125;  </span><br><span class="line">       </span><br><span class="line">    server&#123;</span><br><span class="line">        listen <span class="number">443</span> ssl;   </span><br><span class="line">        server_name xx.<span class="property">merric</span>.<span class="property">top</span>; </span><br><span class="line">        root html;</span><br><span class="line">        index index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        ssl_certificate /app/acme.<span class="property">sh</span>/out/xx.<span class="property">merric</span>.<span class="property">top_ecc</span>/fullchain.<span class="property">cer</span>;  </span><br><span class="line">        ssl_certificate_key /app/acme.<span class="property">sh</span>/out/xx.<span class="property">merric</span>.<span class="property">top_ecc</span>/xx.<span class="property">merric</span>.<span class="property">top</span>.<span class="property">key</span>; </span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers <span class="variable constant_">ECDHE</span>-<span class="variable constant_">RSA</span>-<span class="title class_">AES128</span>-<span class="variable constant_">GCM</span>-<span class="title class_">SHA256</span>:<span class="attr">ECDHE</span>:<span class="attr">ECDH</span>:<span class="attr">AES</span>:<span class="attr">HIGH</span>:!<span class="attr">NULL</span>:!<span class="attr">aNULL</span>:!<span class="title class_">MD5</span>:!<span class="attr">ADH</span>:!<span class="title class_">RC4</span>;</span><br><span class="line">        ssl_protocols <span class="title class_">TLSv1</span><span class="number">.1</span> <span class="title class_">TLSv1</span><span class="number">.2</span> <span class="title class_">TLSv1</span><span class="number">.3</span>;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass <span class="attr">http</span>:<span class="comment">//localhost:8001;</span></span><br><span class="line">            proxy_set_header <span class="variable constant_">HOST</span> $host;</span><br><span class="line">            proxy_set_header X-<span class="title class_">Forwarded</span>-<span class="title class_">Proto</span> $scheme;</span><br><span class="line">            proxy_set_header X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span> $remote_addr;</span><br><span class="line">            proxy_set_header X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span> $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>启动nginx</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%92%8CTCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%92%8CTCP/" class="post-title-link" itemprop="url">TCP和UDP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-15 22:30:00" itemprop="dateCreated datePublished" datetime="2021-05-15T22:30:00+00:00">2021-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>先上两张图。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82.jpg" alt="计算机网络体系结构分层"></p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="计算机网络体系结构"></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP<br>中都没有。</p>
<p>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（<br>主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
<h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><ul>
<li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。 <strong>反之，则数据丢失的可能性很大</strong> 。</li>
<li>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</li>
<li>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</li>
<li>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</li>
<li>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</li>
<li><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></li>
</ul>
<p><img src="/images/%E5%BA%8F%E5%88%97%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94.jpg" alt="序列号和确认应答"></p>
<h2 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h2><ul>
<li><strong>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。</strong> 如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li>
<li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li>
<li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li>
<li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li>
<li>此外， <strong>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></li>
</ul>
<h2 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h2><ul>
<li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li>
<li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li>
<li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li>
</ul>
<h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p>
<p>为解决这个问题，TCP<br>引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p><img src="/images/%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6.jpg" alt="窗口控制"></p>
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p>
<h2 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h2><p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt="滑动窗口"></p>
<p>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
<p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</p>
<h2 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h2><p>在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<ul>
<li>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</li>
</ul>
<p><img src="/images/%E9%83%A8%E5%88%86%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%A2%E5%A4%B1.jpg" alt="部分确认应答丢失"></p>
<ul>
<li>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</li>
</ul>
<p><img src="/images/%E9%AB%98%E9%80%9F%E9%87%8D%E5%8F%91%E6%8E%A7%E5%88%B6.jpg" alt="高速重发控制"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在介绍具体的概念之前，首先我要提到的是TCP中对于拥塞控制的最高思想，主要有三条，那就是既要尽量快的利用信道的最大能力，不要浪费；又要谨慎的控制信道的负载，不要拥堵；同时如果发生了拥堵，必须能够自我调节，不要崩溃。根据这个最高思想，TCP设计了一系列拥塞避免的算法。</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>在一个网络环境下，信道是共享的，也就是说所有发送的数据都会在这个信道上穿梭。这个道理和高速公路是一样的，你只是高速公路上车流中的一辆车。所以说，当你准备开始发送数据的时候，你不能仅仅做到不管三七二十一，就先按自己的节奏发出自己的数据。如果这个时候信道已经很拥挤，你发出的数据一定也会堵在路上，从而造成进一步的重传，这些重传更加加重了网络的负担，本来拥堵不堪的道路只会越来越差。</p>
<p>所以TCP的设计者们设计了一个保守的策略，这种策略带有浓浓的工科生特点，就是先谨慎的试试，再大胆的前进，实践检验效果。具体的说就是TCP的设计者们采用了一个新的窗口，称之为拥塞窗口，记为cwnd，这个cwnd初始设置为一个one<br>segment的大小，在这里我们简单的理解为TCP报文一次允许发送的最大的大小以方便后面叙述。当发出这个一个报文之后，如果发送端能够收到对应的ACK。那么下一次就会发送2个segment的报文，接着如果还是收到这2个segment的ACK，那么说明这个信道还是可以承受当前大小的包的，那么接着进行试探，发送4个segment的包，收到4ACK，就发送8个segment，以此指数级增长的类推。</p>
<p>简单的说，慢启动就是一句话，大胆尝试，小心求证。而且在慢启动算法中，报文的增长速度是很快的，所以说这个算法的过程并不符合这个算法的名称，之所以称之为慢启动，是他小心的去试探网络情况的哲学上的”慢慢来”。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>上面的慢启动很明显可以在很短的时间内让信道的利用率达到一个比较理想的值，由于前面一直强调过，信道的资源总是有限的，所以到某一个阶段，这些快速增长的报文必定会充满信道使得信道变得开始拥挤。TCP的设计者们为了不要使得慢启动算法变成一个只有理论意义，而在很短的时间内又会造成网络崩溃从而导致本末倒置。所以说在慢启动的基础上，设计者们做了一些现实的改进与妥协。除了cwnd这个概念，设计者们还定义了一个叫做ssthresh的概念,slow<br>start thresh,<br>中文一般翻译为慢启动阈值，比如65535个字节。如果cwnd的大小达到了这个阈值，那么就不采用指数增长这样的比较暴力的方法，而是采用每次收到一个ACK，cwnd就扩大1个单位的方法，这样比较保守，目的之一就是慢慢而可靠的试出来信道所能承受的最大的负载，符合前面所说的哲学的第一条。</p>
<p>但是信道资源总是有限的，而cwnd在前面描述的过程中无论是怎样的方式，他一直递增的，所以触碰到天花板是必然，按照前面的“三条不要”的最高思想，在遇到信道已经塞满的情况下，需要做的就是快速的减少对信道的负担并且能够快速的恢复。</p>
<p>TCP怎么知道信道拥堵了呢？反过来问，信道拥堵会给发送端带来什么呢？第一个明显的效应就是发送出去的消息收不到ACK，也就是前面说的超时了，如果连续几个消息都没有收到ACK而不停的发生重传，那么就可以判定为信道已经拥堵了。这个时候，拥塞避免算法会进入恢复阶段，其方法很简单：</p>
<ul>
<li>ssthresh设置为当前发生拥塞cwnd的一般，如果cwnd在30个字节的时候（当然不可能只有这么小）发生了拥堵，那么新的ssthresh就设置为15。</li>
<li>TCP重新进入慢启动阶段，也就是将cwnd设置为1，指数增长知道达到新的ssthresh的15，然后再重新按照拥塞避免第一个阶段，线性增长。<br>这个过程可以用图表示：</li>
</ul>
<p><img src="/images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpeg" alt="拥塞避免"></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>网络是一个很复杂的环境，如果有这么一种情况，网络发生了拥堵但是又那么的拥堵，这种情况的表现是什么呢？按照前面介绍过的滑动窗口，TCP不是one by<br>one的发送数据包的，如果发送的数据包是1,2,3，1和3已经到，但是2没有到，由于拥堵在网络中丢失了，那么接收端会不断告诉发送端下一个需要的报文是2号报文，即使你后面的报文都到了，在2号报文没有收到的情况下，会一直发送对1号报文的ACK，表示需要的是2号报文。如果连续收到三个连续的ACK,就认为网络发生了拥堵。用语言描述有点绕，用图来表示就比较清晰。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A0%B5.jpeg" alt="网络拥堵"></p>
<p>这种情况说明了两种情况：网络确实发生了拥堵，但是又没有完全拥堵。因为如果完全拥堵了，那么发送端也不会受到三个ACK数据报文，所以这种情况没有必要从头再来，因为最高思想的第二点让我们最大的利用信道的能力。按照这个，设计者们又改进了上面的算法，提出了一个快速重传的方案，其思想如下：</p>
<ul>
<li>ssthresh设置为cwnd的一半</li>
<li>cwnd设置为ssthresh的值</li>
<li>不需要重新进入慢启动阶段而是进入拥塞避免阶段<br>用图来表示这个过程如下：</li>
</ul>
<p><img src="/images/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.jpeg" alt="快速重传"></p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传算法已经尽力快的恢复对于网络的传送，但是设计们本着”面包里面抠面粉”的原则，在上面的快速重传算法中尝试想想有没有进步空间，在全面分析之后，提出了快速恢复的算法，其具体做法如下：</p>
<ul>
<li>在收到3个重复的ACK之后，ssthresh设置为cwnd的一半，然后把cwnd设置为ssthresh加3个单位的大小，接着重传丢失的报文段，如果用前面的例子来举例就是重传2号报文。</li>
<li>如果这个时候再次收到重传的ACK，那么拥塞窗口增加1。</li>
<li>如果收到的是新的数据包的ACK，把cwnd设置为第一步的ssthresh的值。为什么这么做，因为如果收到的新的ACK，说明网络已经恢复了，可以进入拥塞避免的线性增长阶段了。<br>第一个例子里为什么加3呢，因为这个时候连续的收到3个ACK包，那么可以认为网络还有3个单位大小的余额，同时也可以这么想，说明有3个“老”的数据包已经从网络上离开了。</li>
</ul>
<h2 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h2><p>首先因为tcp是面向字节流的协议，所以他不保证包的独立性，只能在上层应用层进行拆包处理。</p>
<p>发送粘包的原因：</p>
<ol>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据；</li>
<li>数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去(如果客户端每发送一条数据就睡眠一段时间就不会发生粘包)；</li>
</ol>
<p>拆包：</p>
<ol>
<li>消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；</li>
<li>在包尾增加回车换行符进行分割，例如FTP协议；</li>
<li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；</li>
<li>更复杂的应用层协议。</li>
</ol>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP协议，即用户数据报协议（User Datagram<br>Protocol），是一个简单的面向数据报的传输层协议。UDP协议只在IP数据报服务商增加了很少一点的功能，就是复用和分用，以及差错检测的功能。</p>
<p>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN<br>等特定网络中的应用通信；4.广播通信（广播、多播）。</p>
<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ol>
<li>无连接的</li>
</ol>
<p>发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</p>
<ol start="2">
<li>尽最大努力交付</li>
</ol>
<p>不保证可靠的交付，主机不需要维持复杂的链接状态表。</p>
<ol start="3">
<li>面向报文的</li>
</ol>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p>
<ol start="4">
<li><p>没有拥塞控制。</p>
</li>
<li><p>支持一对一、多对一和多对多的交互通信。</p>
</li>
<li><p>首部开销小，只有8个字节。</p>
</li>
</ol>
<h2 id="UDP首部结构"><a href="#UDP首部结构" class="headerlink" title="UDP首部结构"></a>UDP首部结构</h2><p><img src="/images/UDP%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="UDP首部结构"></p>
<p>UDP首部由4各字段组成，各占两个字节：</p>
<ol>
<li>（1）源端口</li>
</ol>
<p>在需要对方回信时使用，不需要时全为0。</p>
<ol start="2">
<li>目的端口</li>
</ol>
<p>发送UDP数据报的目的地。</p>
<ol start="3">
<li>长度</li>
</ol>
<p>UDP数据报的长度，最短为8个字节，只包含首部。</p>
<ol start="4">
<li>检验和</li>
</ol>
<p>用于检验UDP数据报在传输过程中有没有出差错，有则丢弃。</p>
<h1 id="两者的差别与联系"><a href="#两者的差别与联系" class="headerlink" title="两者的差别与联系"></a>两者的差别与联系</h1><ul>
<li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li>
<li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li>
<li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="merric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myoboku">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Myoboku">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-01 22:30:00" itemprop="dateCreated datePublished" datetime="2021-04-01T22:30:00+00:00">2021-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。</p>
<h2 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h2><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<h2 id="为什么要对网络协议分层？"><a href="#为什么要对网络协议分层？" class="headerlink" title="为什么要对网络协议分层？"></a>为什么要对网络协议分层？</h2><ul>
<li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li>
<li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li>
</ul>
<p>网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。</p>
<p>为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI&#x2F;RM，简称为OSI。</p>
<p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP&#x2F;IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP&#x2F;IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p>
<p>四层协议，五层协议和七层协议的关系如下：</p>
<ul>
<li>TCP&#x2F;IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li>
<li>五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。</li>
<li>OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="图片" title="计算机网络体系结构"></p>
<p>注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</p>
<h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p>
<p>运输层主要使用一下两种协议</p>
<ol>
<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p><strong>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p>
<p>运行在<code>TCP协议</code>上的协议：</p>
<ul>
<li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议）</code>，主要用于普通浏览。</li>
<li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,<code>HTTP</code>协议的安全版本。</li>
<li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li>
<li><code>POP3（Post Office Protocol, version 3，邮局协议）</code>，收邮件用。</li>
<li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li>
<li><code>TELNET（Teletype over the Network，网络电传）</code>，通过一个<code>终端（terminal）</code>登陆到网络。</li>
<li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li>
</ul>
<p>运行在<code>UDP协议</code>上的协议：</p>
<ul>
<li><code>BOOTP（Boot Protocol，启动协议）</code>，应用于无盘设备。</li>
<li><code>NTP（Network Time Protocol，网络时间协议）</code>，用于网络同步。</li>
<li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置IP地址。</li>
</ul>
<p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p>
<ul>
<li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>
<p>一般的web应用的通信传输流是这样的：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ?x-oss-process=image/format,png" alt="图片"></p>
<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="TCP-IP-协议族-1"><a href="#TCP-IP-协议族-1" class="headerlink" title="TCP&#x2F;IP 协议族"></a>TCP&#x2F;IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在人们经常提到的 TCP&#x2F;IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP&#x2F;IP 协议族。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ?x-oss-process=image/format,png" alt="图片"></p>
<blockquote>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写<code>IPS</code>）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP&#x2F;IP协议族（英语：<code>TCP/IP Protocol Suite</code>，或<code>TCP/IP Protocols</code>），简称<code>TCP/IP</code>。因为该协定家族的两个核心协定：<code>TCP（传输控制协议）和IP（网际协议）</code>，为该家族中最早通过的标准。</p>
</blockquote>
<h1 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h1><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p>
<p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p>
<h2 id="TCP报文的头部结构"><a href="#TCP报文的头部结构" class="headerlink" title="TCP报文的头部结构"></a>TCP报文的头部结构</h2><p>在了解TCP连接之前先来了解一下TCP报文的头部结构。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxOWU2YzEzNA?x-oss-process=image/format,png" alt="图片"></p>
<p>上图中有几个字段需要重点介绍下：</p>
<p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1。</p>
<p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>不要将确认序号ack与标志位中的ACK搞混了。</li>
<li>确认方ack&#x3D;发起方seq+1，两端配对。</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote>
<p>三次握手的本质是确认通信双方收发数据的能力</p>
</blockquote>
<p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的</strong>。</p>
<p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以</strong>。</p>
<p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，<strong>他若收到了，他便清楚了他的发件能力和我的收件能力是可以的</strong>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA?x-oss-process=image/format,png" alt="图片"></p>
<ul>
<li><code>第一次握手</code>：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN&#x3D;1)，序列号seq&#x3D;100。</li>
<li><code>第二次握手</code>：服务端收到客户端发过来的报文后，发现SYN&#x3D;1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN&#x3D;1,ACK&#x3D;1)、序列号seq&#x3D;300、确认号ack&#x3D;101(客户端发过来的序列号+1)。</li>
<li><code>第三次握手</code>：客户端收到服务端的回复后发现ACK&#x3D;1并且ack&#x3D;101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN&#x3D;1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK&#x3D;1)、ack&#x3D;301(服务端序列号+1)、seq&#x3D;101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK&#x3D;1并且ack&#x3D;301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote>
<p>四次挥手的目的是关闭一个连接</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw?x-oss-process=image/format,png" alt="图片"></p>
<p>比如客户端初始化的序列号ISA&#x3D;100，服务端初始化的序列号ISA&#x3D;300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li><code>第一次挥手</code>：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN&#x3D;1)、序列号seq&#x3D;1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li>
<li><code>第二次挥手</code>：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;1102(客户端FIN报文序列号1101+1)、序列号seq&#x3D;2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li>
<li><code>第三次挥手</code>：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN&#x3D;1,ACK&#x3D;1)、确认号和第二次挥手一样ack&#x3D;1102、序列号seq&#x3D;2350(2300+50)。</li>
<li><code>第四次挥手</code>：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK&#x3D;1)、确认号ack&#x3D;2351、序列号seq&#x3D;1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li>
</ul>
<h3 id="为什么TCP连接的时候是3次？2次不可以吗？"><a href="#为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="为什么TCP连接的时候是3次？2次不可以吗？"></a>为什么TCP连接的时候是3次？2次不可以吗？</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<h3 id="为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>为什么TCP连接的时候是3次，关闭的时候却是4次？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="什么是HTTP，HTTP-与-HTTPS-的区别"><a href="#什么是HTTP，HTTP-与-HTTPS-的区别" class="headerlink" title="什么是HTTP，HTTP 与 HTTPS 的区别"></a>什么是HTTP，HTTP 与 HTTPS 的区别</h3><p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>运行在 TCP 之上，明文传输，<strong>客户端与服务器端都无法验证对方的身份</strong></td>
<td>身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， <strong>是添加了加密和认证机制的 HTTP</strong>。</td>
</tr>
<tr>
<td>端口</td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td>资源消耗</td>
<td>较少</td>
<td>由于加解密处理，会消耗更多的 CPU 和内存资源</td>
</tr>
<tr>
<td>开销</td>
<td>无需证书</td>
<td>需要证书，而证书一般需要向认证机构购买</td>
</tr>
<tr>
<td>加密机制</td>
<td>无</td>
<td>共享密钥加密和公开密钥加密并用的混合加密机制</td>
</tr>
<tr>
<td>安全性</td>
<td>弱</td>
<td>由于加密机制，安全性强</td>
</tr>
</tbody></table>
<h3 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</p>
<p>状态码的类别：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody></table>
<p>常用HTTP状态码：</p>
<table>
<thead>
<tr>
<th>2XX</th>
<th>成功（这系列表明请求被正常处理了）</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK，表示从客户端发来的请求在服务器端被正确处理</td>
</tr>
<tr>
<td>204</td>
<td>No content，表示请求成功，但响应报文不含实体的主体部分</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content，进行范围请求成功</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>3XX</th>
<th>重定向（表明浏览器要执行特殊处理）</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>moved permanently，永久性重定向，表示资源已被分配了新的 URL</td>
</tr>
<tr>
<td>302</td>
<td>found，临时性重定向，表示资源临时被分配了新的 URL</td>
</tr>
<tr>
<td>303</td>
<td>see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301&#x2F;302&#x2F;303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）</td>
</tr>
<tr>
<td>304</td>
<td>not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）</td>
</tr>
<tr>
<td>307</td>
<td>temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>4XX</th>
<th>客户端错误</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>bad request，请求报文存在语法错误</td>
</tr>
<tr>
<td>401</td>
<td>unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</td>
</tr>
<tr>
<td>403</td>
<td>forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述</td>
</tr>
<tr>
<td>404</td>
<td>not found，表示在服务器上没有找到请求的资源</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>5XX</th>
<th>服务器错误</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>internal sever error，表示服务器端在执行请求时发生了错误</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented，表示服务器不支持当前请求所需要的某个功能</td>
</tr>
<tr>
<td>503</td>
<td>service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</td>
</tr>
</tbody></table>
<h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。</p>
<p>HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。</p>
<p>HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。</p>
<ul>
<li>GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。</li>
<li>POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。</li>
<li>PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。</li>
<li>DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。</li>
</ul>
<p><strong>GET和POST区别</strong></p>
<ol>
<li><p>Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。</p>
</li>
<li><p>Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。</p>
</li>
<li><p>Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。</p>
</li>
<li><p>Get执行效率却比Post方法好。Get是form提交的默认方法。</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</li>
</ol>
<h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，<strong>这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</strong></p>
<p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>
<h3 id="什么是HTTP2"><a href="#什么是HTTP2" class="headerlink" title="什么是HTTP2"></a>什么是HTTP2</h3><p>HTTP2 可以提高了网页的性能。</p>
<p>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</p>
<p>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</p>
<h3 id="Session、Cookie和Token的主要区别"><a href="#Session、Cookie和Token的主要区别" class="headerlink" title="Session、Cookie和Token的主要区别"></a>Session、Cookie和Token的主要区别</h3><p>HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。</p>
<p><strong>什么是cookie</strong></p>
<p>cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。</p>
<p><strong>什么是session</strong></p>
<p>session是依赖Cookie实现的。session是服务器端对象</p>
<p>session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p>
<p><strong>cookie与session区别</strong></p>
<ul>
<li>存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；</li>
<li>存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制</li>
<li>占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<p><strong>什么是Token</strong></p>
<p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>
<p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<p>Token 是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p>
<p><strong>session与token区别</strong></p>
<ul>
<li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li>
<li>session存储在服务器端，token存储在客户端</li>
<li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li>
<li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>
</ul>
<h3 id="Servlet是线程安全的吗"><a href="#Servlet是线程安全的吗" class="headerlink" title="Servlet是线程安全的吗"></a>Servlet是线程安全的吗</h3><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong></p>
<p>解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。</p>
<p>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
<h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求<strong>HttpServletRequest</strong>，在<em>*doGet()**，**doPost()<strong>中做相应的处理，并将回应</strong>HttpServletResponse</em>*反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。</p>
<p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li><strong>void init(ServletConfig config) throws ServletException</strong></li>
<li><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></li>
<li><strong>void destory()</strong></li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p><strong>生命周期：</strong></p>
<p><strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；</p>
<p>请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；</p>
<p>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。</p>
<p><strong>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。</p>
<p>但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p>
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p>
<ol>
<li>手动通过URL传值、隐藏表单传递Session ID。</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">merric</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
